{"version":3,"sources":["jpx.js"],"names":["define","langx","DecodeStream","codec","JpxImage","log2","x","n","i","TagTree","width","height","levelsLength","Math","max","this","levels","level","items","push","ceil","prototype","reset","j","currentLevel","value","length","index","incrementValue","nextLevel","InclusionTree","defaultValue","Uint8Array","jj","stopValue","propagateValues","levelIndex","currentValue","QeTable","qe","nmps","nlps","switchFlag","ArithmeticDecoder","data","start","end","bp","dataEnd","chigh","clow","byteIn","ct","a","readBit","cx","qeIcx","d","exchangeLps","renormD","exchangeMps","mps","qeTableIcx","LLAndLHContextsLabel","HLContextLabel","HHContextLabel","calcSignContribution","significance0","sign0","significance1","sign1","SignContextLabels","contextLabel","xorBit","BitModel","subband","zeroBitPlanes","contextLabelTable","coefficientCount","neighborsSignificance","coefficentsSign","coefficentsMagnitude","Uint32Array","processingFlags","bitsDecoded","ii","setDecoder","decoder","uniformContext","runLengthContext","contexts","setNeighborsSignificance","row","column","runSignificancePropogationPass","contextLabels","labels","q","qq","i0","i1","sign","decodeSignBit","horizontalContribution","verticalContribution","contextLabelAndXor","runMagnitudeRefinementPass","significance","bit","runCleanupPass","significanceState","oneRowDown","twoRowsDown","threeRowsDown","index0","i2","checkSegmentationSymbol","Transform","calculate","subbands","u0","v0","ll","iterate","expand","buffer","bufferPadding","step","j1","j2","hl","lh","hh","llWidth","llHeight","llItems","hlWidth","hlHeight","hlItems","lhWidth","lhHeight","lhItems","hhWidth","hhHeight","hhItems","Float32Array","k","l","bufferLength","bufferOut","v","u","filter","IrreversibleTransform","call","Object","create","y","offset","i0_","floor","i1_","offset_","K","nn","ReversibleTransform","JpxStream","inherit","klassName","init","bytes","dict","overrided","ensureBuffer","req","jpxImage","parse","componentsCount","error","kk","tiles","dataPosition","sourcePosition","data0","data1","data2","data3","rowFeed","tileCompoments","tileWidth","tileHeight","tileLeft","left","tileTop","top","getChar","jpx"],"mappings":";;;;;;;AAAAA,QACE,sBACA,qCACA,WACA,SAASC,EAAMC,EAAaC,GAC5B,aAEF,IAAIC,EAAW,WAiUb,SAASC,EAAKC,GAEZ,IADA,IAAIC,EAAI,EAAGC,EAAI,EACRF,EAAIC,GACTA,IAAM,EACNC,IAEF,OAAOA,GA+sBK,WACZ,SAASC,EAAQC,EAAOC,GACtB,IAAIC,EAAeP,EAAKQ,KAAKC,IAAIJ,EAAOC,IAAW,EACnDI,KAAKC,UACL,IAAK,IAAIR,EAAI,EAAGA,EAAII,EAAcJ,IAAK,CACrC,IAAIS,GACFP,MAAOA,EACPC,OAAQA,EACRO,UAEFH,KAAKC,OAAOG,KAAKF,GACjBP,EAAQG,KAAKO,KAAKV,EAAQ,GAC1BC,EAASE,KAAKO,KAAKT,EAAS,IAGhCF,EAAQY,WACNC,MAAO,SAAuBd,EAAGe,GAE/B,IADA,IAAIC,EAAe,EAAGC,EAAQ,EACvBD,EAAeT,KAAKC,OAAOU,QAAQ,CACxC,IACIC,EAAQnB,EAAIe,GADZN,EAAQF,KAAKC,OAAOQ,IACEd,MAC1B,GAAIiB,KAASV,EAAMC,MAAO,CACxBO,EAAQR,EAAMC,MAAMS,GACpB,MAEFV,EAAMU,MAAQA,EACdnB,IAAM,EACNe,IAAM,EACNC,IAGF,IAAIP,EADJO,KACIP,EAAQF,KAAKC,OAAOQ,IAClBN,MAAMD,EAAMU,OAASF,EAC3BV,KAAKS,aAAeA,SACbT,KAAKU,OAEdG,eAAgB,WACd,IAAIX,EAAQF,KAAKC,OAAOD,KAAKS,cAC7BP,EAAMC,MAAMD,EAAMU,UAEpBE,UAAW,WACT,IAUIZ,EAVAO,EAAeT,KAAKS,aAEpBC,GADAR,EAAQF,KAAKC,OAAOQ,IACNN,MAAMD,EAAMU,OAE9B,QADAH,EACmB,GACjBT,KAAKU,MAAQA,GACN,IAGTV,KAAKS,aAAeA,GAChBP,EAAQF,KAAKC,OAAOQ,IAClBN,MAAMD,EAAMU,OAASF,GACpB,MArDC,GA2DM,WAClB,SAASK,EAAcpB,EAAOC,EAASoB,GACrC,IAAInB,EAAeP,EAAKQ,KAAKC,IAAIJ,EAAOC,IAAW,EACnDI,KAAKC,UACL,IAAK,IAAIR,EAAI,EAAGA,EAAII,EAAcJ,IAAK,CAErC,IADA,IAAIU,EAAQ,IAAIc,WAAWtB,EAAQC,GAC1BY,EAAI,EAAGU,EAAKf,EAAMQ,OAAQH,EAAIU,EAAIV,IACzCL,EAAMK,GAAKQ,EAEb,IAAId,GACFP,MAAOA,EACPC,OAAQA,EACRO,MAAOA,GAETH,KAAKC,OAAOG,KAAKF,GAEjBP,EAAQG,KAAKO,KAAKV,EAAQ,GAC1BC,EAASE,KAAKO,KAAKT,EAAS,IAGhCmB,EAAcT,WACZC,MAAO,SAA6Bd,EAAGe,EAAGW,GAExC,IADA,IAAIV,EAAe,EACZA,EAAeT,KAAKC,OAAOU,QAAQ,CACxC,IAAIT,EAAQF,KAAKC,OAAOQ,GACpBG,EAAQnB,EAAIe,EAAIN,EAAMP,MAC1BO,EAAMU,MAAQA,EACd,IAAIF,EAAQR,EAAMC,MAAMS,GAExB,GAAa,KAATF,EACF,MAEF,GAAIA,EAAQS,EAIV,OAHAnB,KAAKS,aAAeA,EAEpBT,KAAKoB,mBACE,EAGT3B,IAAM,EACNe,IAAM,EACNC,IAGF,OADAT,KAAKS,aAAeA,EAAe,GAC5B,GAETI,eAAgB,SAAsCM,GACpD,IAAIjB,EAAQF,KAAKC,OAAOD,KAAKS,cAC7BP,EAAMC,MAAMD,EAAMU,OAASO,EAAY,EACvCnB,KAAKoB,mBAEPA,gBAAiB,WAIf,IAHA,IAAIC,EAAarB,KAAKS,aAElBa,GADApB,EAAQF,KAAKC,OAAOoB,IACClB,MAAMD,EAAMU,SAC5BS,GAAc,GAAG,CACxB,IAAInB,GAAAA,EAAQF,KAAKC,OAAOoB,IAClBlB,MAAMD,EAAMU,OAASU,IAG/BR,UAAW,WACT,IASIZ,EATAO,EAAeT,KAAKS,aAEpBC,GADAR,EAAQF,KAAKC,OAAOQ,IACNN,MAAMD,EAAMU,OAG9B,OAFAV,EAAMC,MAAMD,EAAMU,OAAS,QAC3BH,EACmB,KAGnBT,KAAKS,aAAeA,GAChBP,EAAQF,KAAKC,OAAOQ,IAClBN,MAAMD,EAAMU,OAASF,GACpB,KAxEO,GA+EI,WACtB,IAAIa,IACDC,GAAI,MAAQC,KAAM,EAAGC,KAAM,EAAGC,WAAY,IAC1CH,GAAI,MAAQC,KAAM,EAAGC,KAAM,EAAGC,WAAY,IAC1CH,GAAI,KAAQC,KAAM,EAAGC,KAAM,EAAGC,WAAY,IAC1CH,GAAI,KAAQC,KAAM,EAAGC,KAAM,GAAIC,WAAY,IAC3CH,GAAI,KAAQC,KAAM,EAAGC,KAAM,GAAIC,WAAY,IAC3CH,GAAI,IAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,MAAQC,KAAM,EAAGC,KAAM,EAAGC,WAAY,IAC1CH,GAAI,MAAQC,KAAM,EAAGC,KAAM,GAAIC,WAAY,IAC3CH,GAAI,MAAQC,KAAM,EAAGC,KAAM,GAAIC,WAAY,IAC3CH,GAAI,MAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,MAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,MAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,MAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,MAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,MAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,MAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,MAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,MAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,MAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,KAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,IAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,IAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,IAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,IAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,IAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,GAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,GAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,GAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,EAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,EAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,EAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAC5CH,GAAI,MAAQC,KAAM,GAAIC,KAAM,GAAIC,WAAY,IAG/C,SAASC,EAAkBC,EAAMC,EAAOC,GACtC/B,KAAK6B,KAAOA,EACZ7B,KAAKgC,GAAKF,EACV9B,KAAKiC,QAAUF,EAEf/B,KAAKkC,MAAQL,EAAKC,GAClB9B,KAAKmC,KAAO,EAEZnC,KAAKoC,SAELpC,KAAKkC,MAAUlC,KAAKkC,OAAS,EAAK,MAAYlC,KAAKmC,MAAQ,EAAK,IAChEnC,KAAKmC,KAAQnC,KAAKmC,MAAQ,EAAK,MAC/BnC,KAAKqC,IAAM,EACXrC,KAAKsC,EAAI,MAGXV,EAAkBtB,WAChB8B,OAAQ,WACN,IAAIP,EAAO7B,KAAK6B,KACZG,EAAKhC,KAAKgC,GACE,KAAZH,EAAKG,GACEH,EAAKG,EAAK,GACV,KACPhC,KAAKmC,MAAQ,MACbnC,KAAKqC,GAAK,IAEVL,IACAhC,KAAKmC,MAASN,EAAKG,IAAO,EAC1BhC,KAAKqC,GAAK,EACVrC,KAAKgC,GAAKA,IAGZA,IACAhC,KAAKmC,MAAQH,EAAKhC,KAAKiC,QAAWJ,EAAKG,IAAO,EAAK,MACnDhC,KAAKqC,GAAK,EACVrC,KAAKgC,GAAKA,GAERhC,KAAKmC,KAAO,QACdnC,KAAKkC,OAAUlC,KAAKmC,MAAQ,GAC5BnC,KAAKmC,MAAQ,QAGjBI,QAAS,SAAmCC,GAC1C,IAAIC,EAAQlB,EAAQiB,EAAG5B,OAAOY,GAG9B,GAFAxB,KAAKsC,GAAKG,EAENzC,KAAKkC,MAAQO,EAAO,CACtB,IAAIC,EAAI1C,KAAK2C,YAAYH,GAEzB,OADAxC,KAAK4C,UACEF,EAGP,GADA1C,KAAKkC,OAASO,EACY,IAAZ,MAATzC,KAAKsC,GAAmB,CACvBI,EAAI1C,KAAK6C,YAAYL,GAEzB,OADAxC,KAAK4C,UACEF,EAEP,OAAOF,EAAGM,KAIhBF,QAAS,WACP,GACkB,IAAZ5C,KAAKqC,IACPrC,KAAKoC,SAEPpC,KAAKsC,IAAM,EACXtC,KAAKkC,MAAUlC,KAAKkC,OAAS,EAAK,MAAYlC,KAAKmC,MAAQ,GAAM,EACjEnC,KAAKmC,KAAQnC,KAAKmC,MAAQ,EAAK,MAC/BnC,KAAKqC,WACwB,IAAZ,MAATrC,KAAKsC,KAEjBO,YAAa,SAAuCL,GAClD,IAAIE,EACAK,EAAaxB,EAAQiB,EAAG5B,OAY5B,OAXIZ,KAAKsC,EAAIS,EAAWvB,IACtBkB,EAAI,EAAIF,EAAGM,IAEkB,GAAzBC,EAAWpB,aACba,EAAGM,IAAM,EAAIN,EAAGM,KAElBN,EAAG5B,MAAQmC,EAAWrB,OAEtBgB,EAAIF,EAAGM,IACPN,EAAG5B,MAAQmC,EAAWtB,MAEjBiB,GAETC,YAAa,SAAuCH,GAClD,IAAIE,EACAK,EAAaxB,EAAQiB,EAAG5B,OAc5B,OAbIZ,KAAKsC,EAAIS,EAAWvB,IACtBxB,KAAKsC,EAAIS,EAAWvB,GACpBkB,EAAIF,EAAGM,IACPN,EAAG5B,MAAQmC,EAAWtB,OAEtBzB,KAAKsC,EAAIS,EAAWvB,GACpBkB,EAAI,EAAIF,EAAGM,IAEkB,GAAzBC,EAAWpB,aACba,EAAGM,IAAM,EAAIN,EAAGM,KAElBN,EAAG5B,MAAQmC,EAAWrB,MAEjBgB,IA3JW,GAmKT,WAIb,IAAIM,EAAuB,IAAI/B,YAC7B,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACxE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACxE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAEtEgC,EAAiB,IAAIhC,YACvB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACxE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACxE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAEtEiC,EAAiB,IAAIjC,YACvB,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACxE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EACxE,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,IAI1E,SAASkC,EAAqBC,EAAeC,EAAOC,EAAeC,GACjE,OAAID,EACGC,EAGIH,EAAkBC,GAAa,EAAL,GAAW,EAFrCD,GAAkBC,EAAY,EAAK,EAIrCD,EAAkBC,GAAa,EAAL,EAAU,EAG/C,IAAIG,IACDC,aAAc,GAAIC,OAAQ,IAC1BD,aAAc,GAAIC,OAAQ,IAC1BD,aAAc,GAAIC,OAAQ,IAC1BD,aAAc,GAAIC,OAAQ,IAC1BD,aAAc,EAAGC,OAAQ,IACzBD,aAAc,GAAIC,OAAQ,IAC1BD,aAAc,GAAIC,OAAQ,IAC1BD,aAAc,GAAIC,OAAQ,IAC1BD,aAAc,GAAIC,OAAQ,IAG7B,SAASC,EAAShE,EAAOC,EAAQgE,EAASC,GACxC7D,KAAKL,MAAQA,EACbK,KAAKJ,OAASA,EAEdI,KAAK8D,kBAA+B,MAAXF,EAAkBV,EAC9B,MAAXU,EAAkBX,EAAiBD,EAErC,IAAIe,EAAmBpE,EAAQC,EAI/BI,KAAKgE,sBAAwB,IAAI/C,WAAW8C,GAC5C/D,KAAKiE,gBAAkB,IAAIhD,WAAW8C,GACtC/D,KAAKkE,qBAAuB,IAAIC,YAAYJ,GAC5C/D,KAAKoE,gBAAkB,IAAInD,WAAW8C,GAGtC,IADA,IAAIM,EAAc,IAAIpD,WAAWjB,KAAKL,MAAQK,KAAKJ,QAC1CH,EAAI,EAAG6E,EAAKD,EAAY1D,OAAQlB,EAAI6E,EAAI7E,IAC/C4E,EAAY5E,GAAKoE,EACnB7D,KAAKqE,YAAcA,EAEnBrE,KAAKO,QAGPoD,EAASrD,WACPiE,WAAY,SAA6BC,GACvCxE,KAAKwE,QAAUA,GAEjBjE,MAAO,WACLP,KAAKyE,gBAAkB7D,MAAO,GAAIkC,IAAK,GACvC9C,KAAK0E,kBAAoB9D,MAAO,EAAGkC,IAAK,GACxC9C,KAAK2E,YACL3E,KAAK2E,SAASvE,MAAMQ,MAAO,EAAGkC,IAAK,IACnC,IAAK,IAAIrD,EAAI,EAAGA,GAAK,GAAIA,IACvBO,KAAK2E,SAASvE,MAAMQ,MAAO,EAAGkC,IAAK,KAEvC8B,yBACE,SAA2CC,EAAKC,GAChD,IAAId,EAAwBhE,KAAKgE,sBAC7BrE,EAAQK,KAAKL,MAAOC,EAASI,KAAKJ,OAClCgB,EAAQiE,EAAMlF,EAAQmF,EACtBD,EAAM,IACJC,EAAS,IACXd,EAAsBpD,EAAQjB,EAAQ,IAAM,IAC1CmF,EAAS,EAAInF,IACfqE,EAAsBpD,EAAQjB,EAAQ,IAAM,IAC9CqE,EAAsBpD,EAAQjB,IAAU,GAEtCkF,EAAM,EAAIjF,IACRkF,EAAS,IACXd,EAAsBpD,EAAQjB,EAAQ,IAAM,IAC1CmF,EAAS,EAAInF,IACfqE,EAAsBpD,EAAQjB,EAAQ,IAAM,IAC9CqE,EAAsBpD,EAAQjB,IAAU,GAEtCmF,EAAS,IACXd,EAAsBpD,EAAQ,IAAM,GAClCkE,EAAS,EAAInF,IACfqE,EAAsBpD,EAAQ,IAAM,GACtCoD,EAAsBpD,IAAU,KAElCmE,+BACE,WAeA,IAdA,IAAIP,EAAUxE,KAAKwE,QACf7E,EAAQK,KAAKL,MAAOC,EAASI,KAAKJ,OAClCsE,EAAuBlE,KAAKkE,qBAC5BD,EAAkBjE,KAAKiE,gBAEvBD,GADgBhE,KAAKgF,cACGhF,KAAKgE,uBAC7BI,EAAkBpE,KAAKoE,gBACvBO,EAAW3E,KAAK2E,SAChBM,EAASjF,KAAK8D,kBACdO,EAAcrE,KAAKqE,YAKda,EAAI,EAAGC,EAAKxF,EAAQC,EAAQsF,EAAIC,EAAID,IAC3Cd,EAAgBc,KAJS,EAM3B,IAAK,IAAIE,EAAK,EAAGA,EAAKxF,EAAQwF,GAAM,EAClC,IAAK,IAAI5E,EAAI,EAAGA,EAAIb,EAAOa,IAEzB,IADA,IAAII,EAAQwE,EAAKzF,EAAQa,EAChB6E,EAAK,EAAGA,EAAK,EAAGA,IAAMzE,GAASjB,EAAO,CAC7C,IAAIF,EAAI2F,EAAKC,EACb,GAAI5F,GAAKG,EACP,MAEF,IAAIsE,EAAqBtD,IAAWoD,EAAsBpD,GAA1D,CAGA,IACI4B,EAAKmC,EADUM,EAAOjB,EAAsBpD,KAGhD,GADe4D,EAAQjC,QAAQC,GACjB,CACZ,IAAI8C,EAAOtF,KAAKuF,cAAc9F,EAAGe,GACjCyD,EAAgBrD,GAAS0E,EACzBpB,EAAqBtD,GAAS,EAC9BZ,KAAK4E,yBAAyBnF,EAAGe,GACjC4D,EAAgBxD,IAvBI,EAyBtByD,EAAYzD,KACZwD,EAAgBxD,IA3BF,KAgCtB2E,cAAe,SAAgCV,EAAKC,GAClD,IAAInF,EAAQK,KAAKL,MAAOC,EAASI,KAAKJ,OAClCgB,EAAQiE,EAAMlF,EAAQmF,EACtBZ,EAAuBlE,KAAKkE,qBAC5BD,EAAkBjE,KAAKiE,gBACvBuB,EAAyBrC,EAC3B2B,EAAS,GAAKZ,EAAqBtD,EAAQ,GAC3CqD,EAAgBrD,EAAQ,GACxBkE,EAAS,EAAInF,GAASuE,EAAqBtD,EAAQ,GACnDqD,EAAgBrD,EAAQ,IACtB6E,EAAuBtC,EACzB0B,EAAM,GAAKX,EAAqBtD,EAAQjB,GACxCsE,EAAgBrD,EAAQjB,GACxBkF,EAAM,EAAIjF,GAAUsE,EAAqBtD,EAAQjB,GACjDsE,EAAgBrD,EAAQjB,IAEtB+F,EAAqBlC,EACvB,GAAK,EAAIgC,IAA2B,EAAIC,IACtChC,EAAeiC,EAAmBjC,aAClCjB,EAAKxC,KAAK2E,SAASlB,GAEvB,OADczD,KAAKwE,QAAQjC,QAAQC,GAClBkD,EAAmBhC,QAEtCiC,2BACE,WAUA,IATA,IAAInB,EAAUxE,KAAKwE,QACf7E,EAAQK,KAAKL,MAAOC,EAASI,KAAKJ,OAClCsE,EAAuBlE,KAAKkE,qBAC5BF,EAAwBhE,KAAKgE,sBAC7BW,EAAW3E,KAAK2E,SAChBN,EAAcrE,KAAKqE,YACnBD,EAAkBpE,KAAKoE,gBAGlBgB,EAAK,EAAGA,EAAKxF,EAAQwF,GAAM,EAClC,IAAK,IAAI5E,EAAI,EAAGA,EAAIb,EAAOa,IACzB,IAAK,IAAI6E,EAAK,EAAGA,EAAK,EAAGA,IAAM,CAC7B,IAAI5F,EAAI2F,EAAKC,EACb,GAAI5F,GAAKG,EACP,MACF,IAAIgB,EAAQnB,EAAIE,EAAQa,EAGxB,GAAK0D,EAAqBtD,IACqB,IAZjC,EAYXwD,EAAgBxD,IADnB,CAIA,IAAI6C,EAAe,GACnB,GAC6B,IAhBP,EAejBW,EAAgBxD,IACW,CAC9BwD,EAAgB3E,EAAIE,EAAQa,IAjBR,EAmBpB,IAAIoF,EAAe5B,EAAsBpD,GAGzC6C,GAFwC,EAAfmC,IACrBA,GAAgB,EAAK,IAAOA,GAAgB,EAAK,IACjB,EAAI,GAAK,GAG/C,IAAIpD,EAAKmC,EAASlB,GACdoC,EAAMrB,EAAQjC,QAAQC,GAC1B0B,EAAqBtD,GAClBsD,EAAqBtD,IAAU,EAAKiF,EACvCxB,EAAYzD,KACZwD,EAAgBxD,IA/BF,KAoCtBkF,eAAgB,WAgBd,IAfA,IAAItB,EAAUxE,KAAKwE,QACf7E,EAAQK,KAAKL,MAAOC,EAASI,KAAKJ,OAClCoE,EAAwBhE,KAAKgE,sBAE7BE,GADoBlE,KAAK+F,kBACF/F,KAAKkE,sBAC5BD,EAAkBjE,KAAKiE,gBACvBU,EAAW3E,KAAK2E,SAChBM,EAASjF,KAAK8D,kBACdO,EAAcrE,KAAKqE,YACnBD,EAAkBpE,KAAKoE,gBAGvB4B,EAAarG,EACbsG,EAAsB,EAARtG,EACduG,EAAwB,EAARvG,EACXyF,EAAK,EAAGA,EAAKxF,EAAQwF,GAAM,EAClC,IAAK,IAAI5E,EAAI,EAAGA,EAAIb,EAAOa,IAAK,CAC9B,IAaIgC,EAAI/C,EAbJ0G,EAASf,EAAKzF,EAAQa,EAYtB6E,EAAK,EAAGzE,EAAQuF,EAEpB,GAXef,EAAK,EAAIxF,GACM,IAA5BwE,EAAgB+B,IACyB,IAAzC/B,EAAgB+B,EAASH,IACiB,IAA1C5B,EAAgB+B,EAASF,IACmB,IAA5C7B,EAAgB+B,EAASD,IACS,IAAlClC,EAAsBmC,IACyB,IAA/CnC,EAAsBmC,EAASH,IACiB,IAAhDhC,EAAsBmC,EAASF,IACmB,IAAlDjC,EAAsBmC,EAASD,GAGnB,CAGZ,GAFA1D,EAAKxC,KAAK0E,kBACqBF,EAAQjC,QAAQC,GAChB,CAC7B6B,EAAY8B,KACZ9B,EAAY8B,EAASH,KACrB3B,EAAY8B,EAASF,KACrB5B,EAAY8B,EAASD,KACrB,SAEF1D,EAAKxC,KAAKyE,eAEVhF,EAAI2F,GADJC,EAAMb,EAAQjC,QAAQC,IAAO,EAAKgC,EAAQjC,QAAQC,IAElD5B,GAASyE,EAAK1F,EAEd,IAAI2F,EAAOtF,KAAKuF,cAAc9F,EAAGe,GACjCyD,EAAgBrD,GAAS0E,EACzBpB,EAAqBtD,GAAS,EAC9BZ,KAAK4E,yBAAyBnF,EAAGe,GACjC4D,EAAgBxD,IAvCM,EAyCtBA,EAAQuF,EACR,IAAK,IAAIC,EAAKhB,EAAIgB,GAAM3G,EAAG2G,IAAMxF,GAASjB,EACxC0E,EAAYzD,KAEdyE,IAEF,KAAOA,EAAK,MACV5F,EAAI2F,EAAKC,IACAzF,GAFIyF,IAAMzE,GAASjB,EAK5B,IAAIuE,EAAqBtD,IACsB,IAtDjC,EAsDXwD,EAAgBxD,IADnB,CAOA,GAFA4B,EAAKmC,EADcM,EAAOjB,EAAsBpD,KAGhC,GADD4D,EAAQjC,QAAQC,GACZ,CACb8C,EAAOtF,KAAKuF,cAAc9F,EAAGe,GACjCyD,EAAgBrD,GAAS0E,EACzBpB,EAAqBtD,GAAS,EAC9BZ,KAAK4E,yBAAyBnF,EAAGe,GACjC4D,EAAgBxD,IAhEI,EAkEtByD,EAAYzD,QAKpByF,wBAAyB,WACvB,IAAI7B,EAAUxE,KAAKwE,QACfhC,EAAKxC,KAAKyE,eAGd,GAAc,KAFAD,EAAQjC,QAAQC,IAAO,EAAMgC,EAAQjC,QAAQC,IAAO,EACpDgC,EAAQjC,QAAQC,IAAO,EAAKgC,EAAQjC,QAAQC,IAExD,KAAM,gCAnTC,GA7Sf,IAwmBI8D,EAAY,WACd,SAASA,KAmHT,OAjHAA,EAAUhG,UAAUiG,UAClB,SAA4BC,EAAUC,EAAIC,GAE1C,IADA,IAAIC,EAAKH,EAAS,GACT/G,EAAI,EAAG6E,EAAKkC,EAAS7F,OAAQH,EAAI,EAAGf,EAAI6E,EAAI7E,GAAK,EAAGe,IAC3DmG,EAAK3G,KAAK4G,QAAQD,EAAIH,EAAS/G,GAAI+G,EAAS/G,EAAI,GAC9B+G,EAAS/G,EAAI,GAAIgH,EAAIC,GAEzC,OAAOC,GAETL,EAAUhG,UAAUuG,OAAS,SAAgBC,EAAQC,EAAeC,GAEhE,IAAI3B,EAAK0B,EAAgB,EAAGE,EAAKF,EAAgB,EAC7CX,EAAKW,EAAgBC,EAAO,EAAGE,EAAKH,EAAgBC,EACxDF,EAAOzB,KAAQyB,EAAOG,KACtBH,EAAOI,KAAQJ,EAAOV,KACtBU,EAAOzB,KAAQyB,EAAOG,KACtBH,EAAOI,KAAQJ,EAAOV,KACtBU,EAAOzB,KAAQyB,EAAOG,KACtBH,EAAOI,KAAQJ,EAAOV,KACtBU,EAAOzB,KAAQyB,EAAOG,KACtBH,EAAOI,KAAQJ,EAAOV,MAE1BE,EAAUhG,UAAUsG,QAAU,SAA2BD,EAAIQ,EAAIC,EAAIC,EACbZ,EAAIC,GAU1D,IATA,IAAIY,EAAUX,EAAGhH,MAAO4H,EAAWZ,EAAG/G,OAAQ4H,EAAUb,EAAGxG,MACvDsH,EAAUN,EAAGxH,MAAO+H,EAAWP,EAAGvH,OAAQ+H,EAAUR,EAAGhH,MACvDyH,EAAUR,EAAGzH,MAAOkI,EAAWT,EAAGxH,OAAQkI,EAAUV,EAAGjH,MACvD4H,EAAUV,EAAG1H,MAAOqI,EAAWX,EAAGzH,OAAQqI,EAAUZ,EAAGlH,MAGvDR,EAAQ2H,EAAUG,EAClB7H,EAAS2H,EAAWM,EACpB1H,EAAQ,IAAI+H,aAAavI,EAAQC,GAC5BH,EAAI,EAAG6E,EAAKiD,EAAU9H,EAAI6E,EAAI7E,IAErC,IADA,IAAI0I,EAAI1I,EAAI6H,EAASc,EAAQ,EAAJ3I,EAAQE,EACxBa,EAAI,EAAGU,EAAKoG,EAAS9G,EAAIU,EAAIV,IAAK2H,IAAKC,GAAK,EACnDjI,EAAMiI,GAAKZ,EAAQW,GAEvB,IAAS1I,EAAI,EAAG6E,EAAKoD,EAAUjI,EAAI6E,EAAI7E,IAErC,IADI0I,EAAI1I,EAAIgI,EAASW,EAAQ,EAAJ3I,EAAQE,EAAQ,EAChCa,EAAI,EAAGU,EAAKuG,EAASjH,EAAIU,EAAIV,IAAK2H,IAAKC,GAAK,EACnDjI,EAAMiI,GAAKT,EAAQQ,GAEvB,IAAS1I,EAAI,EAAG6E,EAAKuD,EAAUpI,EAAI6E,EAAI7E,IAErC,IADI0I,EAAI1I,EAAImI,EAASQ,GAAS,EAAJ3I,EAAQ,GAAKE,EAC9Ba,EAAI,EAAGU,EAAK0G,EAASpH,EAAIU,EAAIV,IAAK2H,IAAKC,GAAK,EACnDjI,EAAMiI,GAAKN,EAAQK,GAEvB,IAAS1I,EAAI,EAAG6E,EAAK0D,EAAUvI,EAAI6E,EAAI7E,IAErC,IADI0I,EAAI1I,EAAIsI,EAASK,GAAS,EAAJ3I,EAAQ,GAAKE,EAAQ,EACtCa,EAAI,EAAGU,EAAK6G,EAASvH,EAAIU,EAAIV,IAAK2H,IAAKC,GAAK,EACnDjI,EAAMiI,GAAKH,EAAQE,GAUvB,IAPA,IACIE,EAAe,IAAIH,aAAapI,KAAKC,IAAIJ,EAAOC,GAClD,GACEkH,EAAS,IAAIoB,aAAaG,GAC1BC,EAAY,IAAIJ,aAAaG,GAGxBE,EAAI,EAAGA,EAAI3I,EAAQ2I,IAC1B,GAAa,GAAT5I,EAAJ,CAQIwI,EAAII,EAAI5I,EACRyI,EAjBc,EAkBlB,IAFA,IAESI,EAAI,EAAGA,EAAI7I,EAAO6I,IAAKL,IAAKC,IACnCtB,EAAOsB,GAAKjI,EAAMgI,GAEpBnI,KAAK6G,OAAOC,EArBM,EAqBiBnH,GACnCK,KAAKyI,OAAO3B,EAtBM,EAsBiBnH,EAAO8G,EAAI6B,GAE9CH,EAAII,EAAI5I,EACRyI,EAzBkB,EA0BlB,IAASI,EAAI,EAAGA,EAAI7I,EAAO6I,IAAKL,IAAKC,IACnCjI,EAAMgI,GAAKG,EAAUF,QAjBhB3B,EAAK,GAAO,IACftG,EAAMoI,EAAI5I,IAAU,GAoB1B,IAAS6I,EAAI,EAAGA,EAAI7I,EAAO6I,IACzB,GAAc,GAAV5I,EAAJ,CAUA,IAFIuI,EAAIK,EACJJ,EAzCc,EA0CTG,EAAI,EAAGA,EAAI3I,EAAQ2I,IAAKJ,GAAKxI,EAAOyI,IAC3CtB,EAAOsB,GAAKjI,EAAMgI,GAEpBnI,KAAK6G,OAAOC,EA7CM,EA6CiBlH,GACnCI,KAAKyI,OAAO3B,EA9CM,EA8CiBlH,EAAQ8G,EAAI4B,GAE/CH,EAAIK,EACJJ,EAjDkB,EAkDlB,IAASG,EAAI,EAAGA,EAAI3I,EAAQ2I,IAAKJ,GAAKxI,EAAOyI,IAC3CjI,EAAMgI,GAAKG,EAAUF,QAjBhB1B,EAAK,GAAO,IACfvG,EAAMqI,IAAM,GAkBlB,OACE7I,MAAOA,EACPC,OAAQA,EACRO,MAAOA,IAGJmG,EApHO,IAwHY,WAC1B,SAASoC,IACPpC,EAAUqC,KAAK3I,MAGjB0I,EAAsBpI,UAAYsI,OAAOC,OAAOvC,EAAUhG,WAC1DoI,EAAsBpI,UAAUmI,OAC9B,SAAqCK,EAAGC,EAAQpI,EAAQyE,EAAI7F,GAc5D,IAbA,IAAIyJ,EAAMlJ,KAAKmJ,MAAM7D,EAAK,GACtB8D,EAAMpJ,KAAKmJ,OAAO7D,EAAKzE,GAAU,GACjCwI,EAAUJ,EAAU3D,EAAK,EAMzBgE,EAAI,kBAIJ5I,EAAI2I,EAAU,EACT3J,EAAIwJ,EAAM,EAAGK,EAAKH,EAAM,EAAG1J,EAAI6J,EAAI7J,IAAKgB,GAAK,EACpDjB,EAAEiB,GAAK4I,EAAIN,EAAEtI,GAIf,IADIA,EAAI2I,EAAU,EACT3J,EAAIwJ,EAAM,EAAGK,EAAKH,EAAM,EAAG1J,EAAI6J,EAAI7J,IAAKgB,GAAK,EACpDjB,EAAEiB,GAVK,kBAUKsI,EAAEtI,GAIhB,IADIA,EAAI2I,EAAU,EACT3J,EAAIwJ,EAAM,EAAGK,EAAKH,EAAM,EAAG1J,EAAI6J,EAAI7J,IAAKgB,GAAK,EACpDjB,EAAEiB,IAjBQ,kBAiBOjB,EAAEiB,EAAI,GAAKjB,EAAEiB,EAAI,IAIpC,IADIA,EAAI2I,EAAU,EACT3J,EAAIwJ,EAAM,EAAGK,EAAKH,EAAM,EAAG1J,EAAI6J,EAAI7J,IAAKgB,GAAK,EACpDjB,EAAEiB,IAvBQ,kBAuBOjB,EAAEiB,EAAI,GAAKjB,EAAEiB,EAAI,IAIpC,IADIA,EAAI2I,EACC3J,EAAIwJ,EAAKK,EAAKH,EAAM,EAAG1J,EAAI6J,EAAI7J,IAAKgB,GAAK,EAChDjB,EAAEiB,KA7BO,kBA6BOjB,EAAEiB,EAAI,GAAKjB,EAAEiB,EAAI,IAInC,IADIA,EAAI2I,EAAU,EACT3J,EAAIwJ,EAAKK,EAAKH,EAAK1J,EAAI6J,EAAI7J,IAAKgB,GAAK,EAC5CjB,EAAEiB,KAnCQ,mBAmCOjB,EAAEiB,EAAI,GAAKjB,EAAEiB,EAAI,MA/CZ,GAsDF,WACxB,SAAS8I,IACPhD,EAAUqC,KAAK3I,MAGjBsJ,EAAoBhJ,UAAYsI,OAAOC,OAAOvC,EAAUhG,WACxDgJ,EAAoBhJ,UAAUmI,OAC5B,SAAmCK,EAAGC,EAAQpI,EAAQyE,EAAI7F,GAK1D,IAJA,IAAIyJ,EAAMlJ,KAAKmJ,MAAM7D,EAAK,GACtB8D,EAAMpJ,KAAKmJ,OAAO7D,EAAKzE,GAAU,GACjCwI,EAAUJ,EAAU3D,EAAK,EAEpB5F,EAAIwJ,EAAKK,EAAKH,EAAM,EAAG1I,EAAI2I,EAAS3J,EAAI6J,EAAI7J,IAAKgB,GAAK,EAC7DjB,EAAEiB,GAAKsI,EAAEtI,GAAKV,KAAKmJ,OAAOH,EAAEtI,EAAI,GAAKsI,EAAEtI,EAAI,GAAK,GAAK,GAEvD,IAAShB,EAAIwJ,EAAKK,EAAKH,EAAK1I,EAAI2I,EAAU,EAAG3J,EAAI6J,EAAI7J,IAAKgB,GAAK,EAC7DjB,EAAEiB,GAAKsI,EAAEtI,GAAKV,KAAKmJ,OAAO1J,EAAEiB,EAAI,GAAKjB,EAAEiB,EAAI,IAAM,IAhB7B,GA5yDb,GA00DP+I,EAAYpK,EAAaqK,SACzBC,UAAY,YAEZC,KAAO,SAASC,EAAOC,GACrB5J,KAAK4J,KAAOA,EACZ5J,KAAK2J,MAAQA,EAEX3J,KAAK6J,aAEXC,aAAe,SAASC,GACpB,IAAI/J,KAAKqI,aAAT,CAGA,IAAI2B,EAAW,IAAI3K,EACnB2K,EAASC,MAAMjK,KAAK2J,OAEpB,IAAIhK,EAAQqK,EAASrK,MACjBC,EAASoK,EAASpK,OAClBsK,EAAkBF,EAASE,gBACR,GAAnBA,GAA2C,GAAnBA,GAA2C,GAAnBA,GAChDC,MAAM,YAAcD,EAAkB,gCAI1C,IAFA,IAAIrI,EAAO,IAAIZ,WAAWtB,EAAQC,EAASsK,GAElC/B,EAAI,EAAGiC,EAAKJ,EAASK,MAAM1J,OAAQwH,EAAIiC,EAAIjC,IAAK,CACrD,IAMImC,EAAcC,EAAgBC,EAAOC,EAAOC,EAAOC,EAAOC,EAN1DC,EAAiBb,EAASK,MAAMlC,GAChC2C,EAAYD,EAAe,GAAGlL,MAC9BoL,EAAaF,EAAe,GAAGjL,OAC/BoL,EAAWH,EAAe,GAAGI,KAC7BC,EAAUL,EAAe,GAAGM,IAGhC,OAAQjB,GACJ,KAAK,EACDM,EAAQK,EAAe,GAAG1K,MAE1BmK,EAAe3K,EAAQuL,EAAUF,EACjCJ,EAAUjL,EAAQmL,EAClBP,EAAiB,EACjB,IAAK,IAAI/J,EAAI,EAAGA,EAAIuK,EAAYvK,IAAK,CACjC,IAAK,IAAIf,EAAI,EAAGA,EAAIqL,EAAWrL,IAC3BoC,EAAKyI,KAAkBE,EAAMD,KACjCD,GAAgBM,EAEpB,MACJ,KAAK,EACDJ,EAAQK,EAAe,GAAG1K,MAC1BsK,EAAQI,EAAe,GAAG1K,MAC1BuK,EAAQG,EAAe,GAAG1K,MAE1BmK,EAA8C,GAA9B3K,EAAQuL,EAAUF,GAClCJ,EAAgC,GAArBjL,EAAQmL,GACnBP,EAAiB,EACjB,IAAS/J,EAAI,EAAGA,EAAIuK,EAAYvK,IAAK,CACjC,IAASf,EAAI,EAAGA,EAAIqL,EAAWrL,IAC3BoC,EAAKyI,KAAkBE,EAAMD,GAC7B1I,EAAKyI,KAAkBG,EAAMF,GAC7B1I,EAAKyI,KAAkBI,EAAMH,GAC7BA,IAEJD,GAAgBM,EAEpB,MACJ,KAAK,EACDJ,EAAQK,EAAe,GAAG1K,MAC1BsK,EAAQI,EAAe,GAAG1K,MAC1BuK,EAAQG,EAAe,GAAG1K,MAC1BwK,EAAQE,EAAe,GAAG1K,MAE1BmK,EAA8C,GAA9B3K,EAAQuL,EAAUF,GAClCJ,EAAgC,GAArBjL,EAAQmL,GACnBP,EAAiB,EACjB,IAAS/J,EAAI,EAAGA,EAAIuK,EAAYvK,IAAK,CACjC,IAASf,EAAI,EAAGA,EAAIqL,EAAWrL,IAC3BoC,EAAKyI,KAAkBE,EAAMD,GAC7B1I,EAAKyI,KAAkBG,EAAMF,GAC7B1I,EAAKyI,KAAkBI,EAAMH,GAC7B1I,EAAKyI,KAAkBK,EAAMJ,GAC7BA,IAEJD,GAAgBM,IAMhC5K,KAAK8G,OAASjF,EACd7B,KAAKqI,aAAexG,EAAKlB,SAG7ByK,QAAU,WACNjB,MAAM,wDAId,OAAO/K,EAAMiM,KACXhM,SAAYA,EACZkK,UAAcA","file":"../jpx.js","sourcesContent":["define([\r\n  \"skylark-langx/langx\",\r\n  \"skylark-utils-streams/DecodeStream\",\r\n  \"./codec\"\r\n],function(langx,DecodeStream,codec){\r\n  'use strict';\r\n\r\nvar JpxImage = (function JpxImageClosure() {\r\n  // Table E.1\r\n  var SubbandsGainLog2 = {\r\n    'LL': 0,\r\n    'LH': 1,\r\n    'HL': 1,\r\n    'HH': 2\r\n  };\r\n  function JpxImage() {\r\n    this.failOnCorruptedImage = false;\r\n  }\r\n  JpxImage.prototype = {\r\n    load: function JpxImage_load(url) {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open('GET', url, true);\r\n      xhr.responseType = 'arraybuffer';\r\n      xhr.onload = (function() {\r\n        // TODO catch parse error\r\n        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\r\n        this.parse(data);\r\n        if (this.onload)\r\n          this.onload();\r\n      }).bind(this);\r\n      xhr.send(null);\r\n    },\r\n    parse: function JpxImage_parse(data) {\r\n      function readUint(data, offset, bytes) {\r\n        var n = 0;\r\n        for (var i = 0; i < bytes; i++)\r\n          n = n * 256 + (data[offset + i] & 0xFF);\r\n        return n;\r\n      }\r\n      var position = 0, length = data.length;\r\n      while (position < length) {\r\n        var headerSize = 8;\r\n        var lbox = readUint(data, position, 4);\r\n        var tbox = readUint(data, position + 4, 4);\r\n        position += headerSize;\r\n        if (lbox == 1) {\r\n          lbox = readUint(data, position, 8);\r\n          position += 8;\r\n          headerSize += 8;\r\n        }\r\n        if (lbox === 0)\r\n          lbox = length - position + headerSize;\r\n        if (lbox < headerSize)\r\n          error('JPX error: Invalid box field size');\r\n        var dataLength = lbox - headerSize;\r\n        var jumpDataLength = true;\r\n        switch (tbox) {\r\n          case 0x6A501A1A: // 'jP\\032\\032'\r\n            // TODO\r\n            break;\r\n          case 0x6A703268: // 'jp2h'\r\n            jumpDataLength = false; // parsing child boxes\r\n            break;\r\n          case 0x636F6C72: // 'colr'\r\n            // TODO\r\n            break;\r\n          case 0x6A703263: // 'jp2c'\r\n            this.parseCodestream(data, position, position + dataLength);\r\n            break;\r\n        }\r\n        if (jumpDataLength)\r\n          position += dataLength;\r\n      }\r\n    },\r\n    parseCodestream: function JpxImage_parseCodestream(data, start, end) {\r\n      var context = {};\r\n      try {\r\n        var position = start;\r\n        while (position < end) {\r\n          var code = readUint16(data, position);\r\n          position += 2;\r\n\r\n          var length = 0, j;\r\n          switch (code) {\r\n            case 0xFF4F: // Start of codestream (SOC)\r\n              context.mainHeader = true;\r\n              break;\r\n            case 0xFFD9: // End of codestream (EOC)\r\n              break;\r\n            case 0xFF51: // Image and tile size (SIZ)\r\n              length = readUint16(data, position);\r\n              var siz = {};\r\n              siz.Xsiz = readUint32(data, position + 4);\r\n              siz.Ysiz = readUint32(data, position + 8);\r\n              siz.XOsiz = readUint32(data, position + 12);\r\n              siz.YOsiz = readUint32(data, position + 16);\r\n              siz.XTsiz = readUint32(data, position + 20);\r\n              siz.YTsiz = readUint32(data, position + 24);\r\n              siz.XTOsiz = readUint32(data, position + 28);\r\n              siz.YTOsiz = readUint32(data, position + 32);\r\n              var componentsCount = readUint16(data, position + 36);\r\n              siz.Csiz = componentsCount;\r\n              var components = [];\r\n              j = position + 38;\r\n              for (var i = 0; i < componentsCount; i++) {\r\n                var component = {\r\n                  precision: (data[j] & 0x7F) + 1,\r\n                  isSigned: !!(data[j] & 0x80),\r\n                  XRsiz: data[j + 1],\r\n                  YRsiz: data[j + 1]\r\n                };\r\n                calculateComponentDimensions(component, siz);\r\n                components.push(component);\r\n              }\r\n              context.SIZ = siz;\r\n              context.components = components;\r\n              calculateTileGrids(context, components);\r\n              context.QCC = [];\r\n              context.COC = [];\r\n              break;\r\n            case 0xFF5C: // Quantization default (QCD)\r\n              length = readUint16(data, position);\r\n              var qcd = {};\r\n              j = position + 2;\r\n              var sqcd = data[j++];\r\n              var spqcdSize, scalarExpounded;\r\n              switch (sqcd & 0x1F) {\r\n                case 0:\r\n                  spqcdSize = 8;\r\n                  scalarExpounded = true;\r\n                  break;\r\n                case 1:\r\n                  spqcdSize = 16;\r\n                  scalarExpounded = false;\r\n                  break;\r\n                case 2:\r\n                  spqcdSize = 16;\r\n                  scalarExpounded = true;\r\n                  break;\r\n                default:\r\n                  throw 'Invalid SQcd value ' + sqcd;\r\n              }\r\n              qcd.noQuantization = spqcdSize == 8;\r\n              qcd.scalarExpounded = scalarExpounded;\r\n              qcd.guardBits = sqcd >> 5;\r\n              var spqcds = [];\r\n              while (j < length + position) {\r\n                var spqcd = {};\r\n                if (spqcdSize == 8) {\r\n                  spqcd.epsilon = data[j++] >> 3;\r\n                  spqcd.mu = 0;\r\n                } else {\r\n                  spqcd.epsilon = data[j] >> 3;\r\n                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];\r\n                  j += 2;\r\n                }\r\n                spqcds.push(spqcd);\r\n              }\r\n              qcd.SPqcds = spqcds;\r\n              if (context.mainHeader)\r\n                context.QCD = qcd;\r\n              else {\r\n                context.currentTile.QCD = qcd;\r\n                context.currentTile.QCC = [];\r\n              }\r\n              break;\r\n            case 0xFF5D: // Quantization component (QCC)\r\n              length = readUint16(data, position);\r\n              var qcc = {};\r\n              j = position + 2;\r\n              var cqcc;\r\n              if (context.SIZ.Csiz < 257)\r\n                cqcc = data[j++];\r\n              else {\r\n                cqcc = readUint16(data, j);\r\n                j += 2;\r\n              }\r\n              var sqcd = data[j++];\r\n              var spqcdSize, scalarExpounded;\r\n              switch (sqcd & 0x1F) {\r\n                case 0:\r\n                  spqcdSize = 8;\r\n                  scalarExpounded = true;\r\n                  break;\r\n                case 1:\r\n                  spqcdSize = 16;\r\n                  scalarExpounded = false;\r\n                  break;\r\n                case 2:\r\n                  spqcdSize = 16;\r\n                  scalarExpounded = true;\r\n                  break;\r\n                default:\r\n                  throw 'Invalid SQcd value ' + sqcd;\r\n              }\r\n              qcc.noQuantization = spqcdSize == 8;\r\n              qcc.scalarExpounded = scalarExpounded;\r\n              qcc.guardBits = sqcd >> 5;\r\n              var spqcds = [];\r\n              while (j < length + position) {\r\n                var spqcd = {};\r\n                if (spqcdSize == 8) {\r\n                  spqcd.epsilon = data[j++] >> 3;\r\n                  spqcd.mu = 0;\r\n                } else {\r\n                  spqcd.epsilon = data[j] >> 3;\r\n                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];\r\n                  j += 2;\r\n                }\r\n                spqcds.push(spqcd);\r\n              }\r\n              qcc.SPqcds = spqcds;\r\n              if (context.mainHeader)\r\n                context.QCC[cqcc] = qcc;\r\n              else\r\n                context.currentTile.QCC[cqcc] = qcc;\r\n              break;\r\n            case 0xFF52: // Coding style default (COD)\r\n              length = readUint16(data, position);\r\n              var cod = {};\r\n              j = position + 2;\r\n              var scod = data[j++];\r\n              cod.entropyCoderWithCustomPrecincts = !!(scod & 1);\r\n              cod.sopMarkerUsed = !!(scod & 2);\r\n              cod.ephMarkerUsed = !!(scod & 4);\r\n              var codingStyle = {};\r\n              cod.progressionOrder = data[j++];\r\n              cod.layersCount = readUint16(data, j);\r\n              j += 2;\r\n              cod.multipleComponentTransform = data[j++];\r\n\r\n              cod.decompositionLevelsCount = data[j++];\r\n              cod.xcb = (data[j++] & 0xF) + 2;\r\n              cod.ycb = (data[j++] & 0xF) + 2;\r\n              var blockStyle = data[j++];\r\n              cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);\r\n              cod.resetContextProbabilities = !!(blockStyle & 2);\r\n              cod.terminationOnEachCodingPass = !!(blockStyle & 4);\r\n              cod.verticalyStripe = !!(blockStyle & 8);\r\n              cod.predictableTermination = !!(blockStyle & 16);\r\n              cod.segmentationSymbolUsed = !!(blockStyle & 32);\r\n              cod.transformation = data[j++];\r\n              if (cod.entropyCoderWithCustomPrecincts) {\r\n                var precinctsSizes = {};\r\n                while (j < length + position) {\r\n                  var precinctsSize = data[j];\r\n                  precinctsSizes.push({\r\n                    PPx: precinctsSize & 0xF,\r\n                    PPy: precinctsSize >> 4\r\n                  });\r\n                }\r\n                cod.precinctsSizes = precinctsSizes;\r\n              }\r\n\r\n              if (cod.sopMarkerUsed || cod.ephMarkerUsed ||\r\n                  cod.selectiveArithmeticCodingBypass ||\r\n                  cod.resetContextProbabilities ||\r\n                  cod.terminationOnEachCodingPass ||\r\n                  cod.verticalyStripe || cod.predictableTermination)\r\n                throw 'Unsupported COD options: ' +\r\n                  globalScope.JSON.stringify(cod);\r\n\r\n              if (context.mainHeader)\r\n                context.COD = cod;\r\n              else {\r\n                context.currentTile.COD = cod;\r\n                context.currentTile.COC = [];\r\n              }\r\n              break;\r\n            case 0xFF90: // Start of tile-part (SOT)\r\n              length = readUint16(data, position);\r\n              var tile = {};\r\n              tile.index = readUint16(data, position + 2);\r\n              tile.length = readUint32(data, position + 4);\r\n              tile.dataEnd = tile.length + position - 2;\r\n              tile.partIndex = data[position + 8];\r\n              tile.partsCount = data[position + 9];\r\n\r\n              context.mainHeader = false;\r\n              if (tile.partIndex === 0) {\r\n                // reset component specific settings\r\n                tile.COD = context.COD;\r\n                tile.COC = context.COC.slice(0); // clone of the global COC\r\n                tile.QCD = context.QCD;\r\n                tile.QCC = context.QCC.slice(0); // clone of the global COC\r\n              }\r\n              context.currentTile = tile;\r\n              break;\r\n            case 0xFF93: // Start of data (SOD)\r\n              var tile = context.currentTile;\r\n              if (tile.partIndex === 0) {\r\n                initializeTile(context, tile.index);\r\n                buildPackets(context);\r\n              }\r\n\r\n              // moving to the end of the data\r\n              length = tile.dataEnd - position;\r\n\r\n              parseTilePackets(context, data, position, length);\r\n              break;\r\n            case 0xFF64: // Comment (COM)\r\n              length = readUint16(data, position);\r\n              // skipping content\r\n              break;\r\n            default:\r\n              throw 'Unknown codestream code: ' + code.toString(16);\r\n          }\r\n          position += length;\r\n        }\r\n      } catch (e) {\r\n        if (this.failOnCorruptedImage)\r\n          error('JPX error: ' + e);\r\n        else\r\n          warn('JPX error: ' + e + '. Trying to recover');\r\n      }\r\n      this.tiles = transformComponents(context);\r\n      this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;\r\n      this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;\r\n      this.componentsCount = context.SIZ.Csiz;\r\n    }\r\n  };\r\n  function readUint32(data, offset) {\r\n    return (data[offset] << 24) | (data[offset + 1] << 16) |\r\n      (data[offset + 2] << 8) | data[offset + 3];\r\n  }\r\n  function readUint16(data, offset) {\r\n    return (data[offset] << 8) | data[offset + 1];\r\n  }\r\n  function log2(x) {\r\n    var n = 1, i = 0;\r\n    while (x > n) {\r\n      n <<= 1;\r\n      i++;\r\n    }\r\n    return i;\r\n  }\r\n  function calculateComponentDimensions(component, siz) {\r\n    // Section B.2 Component mapping\r\n    component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);\r\n    component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);\r\n    component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);\r\n    component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);\r\n    component.width = component.x1 - component.x0;\r\n    component.height = component.y1 - component.y0;\r\n  }\r\n  function calculateTileGrids(context, components) {\r\n    var siz = context.SIZ;\r\n    // Section B.3 Division into tile and tile-components\r\n    var tiles = [];\r\n    var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);\r\n    var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);\r\n    for (var q = 0; q < numYtiles; q++) {\r\n      for (var p = 0; p < numXtiles; p++) {\r\n        var tile = {};\r\n        tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);\r\n        tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);\r\n        tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);\r\n        tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);\r\n        tile.width = tile.tx1 - tile.tx0;\r\n        tile.height = tile.ty1 - tile.ty0;\r\n        tile.components = [];\r\n        tiles.push(tile);\r\n      }\r\n    }\r\n    context.tiles = tiles;\r\n\r\n    var componentsCount = siz.Csiz;\r\n    for (var i = 0, ii = componentsCount; i < ii; i++) {\r\n      var component = components[i];\r\n      var tileComponents = [];\r\n      for (var j = 0, jj = tiles.length; j < jj; j++) {\r\n        var tileComponent = {}, tile = tiles[j];\r\n        tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);\r\n        tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);\r\n        tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);\r\n        tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);\r\n        tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;\r\n        tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;\r\n        tile.components[i] = tileComponent;\r\n      }\r\n    }\r\n  }\r\n  function getBlocksDimensions(context, component, r) {\r\n    var codOrCoc = component.codingStyleParameters;\r\n    var result = {};\r\n    if (!codOrCoc.entropyCoderWithCustomPrecincts) {\r\n      result.PPx = 15;\r\n      result.PPy = 15;\r\n    } else {\r\n      result.PPx = codOrCoc.precinctsSizes[r].PPx;\r\n      result.PPy = codOrCoc.precinctsSizes[r].PPy;\r\n    }\r\n    // calculate codeblock size as described in section B.7\r\n    result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) :\r\n      Math.min(codOrCoc.xcb, result.PPx);\r\n    result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) :\r\n      Math.min(codOrCoc.ycb, result.PPy);\r\n    return result;\r\n  }\r\n  function buildPrecincts(context, resolution, dimensions) {\r\n    // Section B.6 Division resolution to precincts\r\n    var precinctWidth = 1 << dimensions.PPx;\r\n    var precinctHeight = 1 << dimensions.PPy;\r\n    var numprecinctswide = resolution.trx1 > resolution.trx0 ?\r\n      Math.ceil(resolution.trx1 / precinctWidth) -\r\n      Math.floor(resolution.trx0 / precinctWidth) : 0;\r\n    var numprecinctshigh = resolution.try1 > resolution.try0 ?\r\n      Math.ceil(resolution.try1 / precinctHeight) -\r\n      Math.floor(resolution.try0 / precinctHeight) : 0;\r\n    var numprecincts = numprecinctswide * numprecinctshigh;\r\n    var precinctXOffset = Math.floor(resolution.trx0 / precinctWidth) *\r\n      precinctWidth;\r\n    var precinctYOffset = Math.floor(resolution.try0 / precinctHeight) *\r\n      precinctHeight;\r\n    resolution.precinctParameters = {\r\n      precinctXOffset: precinctXOffset,\r\n      precinctYOffset: precinctYOffset,\r\n      precinctWidth: precinctWidth,\r\n      precinctHeight: precinctHeight,\r\n      numprecinctswide: numprecinctswide,\r\n      numprecinctshigh: numprecinctshigh,\r\n      numprecincts: numprecincts\r\n    };\r\n  }\r\n  function buildCodeblocks(context, subband, dimensions) {\r\n    // Section B.7 Division sub-band into code-blocks\r\n    var xcb_ = dimensions.xcb_;\r\n    var ycb_ = dimensions.ycb_;\r\n    var codeblockWidth = 1 << xcb_;\r\n    var codeblockHeight = 1 << ycb_;\r\n    var cbx0 = Math.floor(subband.tbx0 / codeblockWidth);\r\n    var cby0 = Math.floor(subband.tby0 / codeblockHeight);\r\n    var cbx1 = Math.ceil(subband.tbx1 / codeblockWidth);\r\n    var cby1 = Math.ceil(subband.tby1 / codeblockHeight);\r\n    var precinctParameters = subband.resolution.precinctParameters;\r\n    var codeblocks = [];\r\n    var precincts = [];\r\n    for (var j = cby0; j < cby1; j++) {\r\n      for (var i = cbx0; i < cbx1; i++) {\r\n        var codeblock = {\r\n          cbx: i,\r\n          cby: j,\r\n          tbx0: codeblockWidth * i,\r\n          tby0: codeblockHeight * j,\r\n          tbx1: codeblockWidth * (i + 1),\r\n          tby1: codeblockHeight * (j + 1)\r\n        };\r\n        // calculate precinct number\r\n        var pi = Math.floor((codeblock.tbx0 -\r\n          precinctParameters.precinctXOffset) /\r\n          precinctParameters.precinctWidth);\r\n        var pj = Math.floor((codeblock.tby0 -\r\n          precinctParameters.precinctYOffset) /\r\n          precinctParameters.precinctHeight);\r\n        var precinctNumber = pj +\r\n          pi * precinctParameters.numprecinctswide;\r\n        codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);\r\n        codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);\r\n        codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);\r\n        codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);\r\n        codeblock.precinctNumber = precinctNumber;\r\n        codeblock.subbandType = subband.type;\r\n        var coefficientsLength = (codeblock.tbx1_ - codeblock.tbx0_) *\r\n          (codeblock.tby1_ - codeblock.tby0_);\r\n        codeblock.Lblock = 3;\r\n        codeblocks.push(codeblock);\r\n        // building precinct for the sub-band\r\n        var precinct;\r\n        if (precinctNumber in precincts) {\r\n          precinct = precincts[precinctNumber];\r\n          precinct.cbxMin = Math.min(precinct.cbxMin, i);\r\n          precinct.cbyMin = Math.min(precinct.cbyMin, j);\r\n          precinct.cbxMax = Math.max(precinct.cbxMax, i);\r\n          precinct.cbyMax = Math.max(precinct.cbyMax, j);\r\n        } else {\r\n          precincts[precinctNumber] = precinct = {\r\n            cbxMin: i,\r\n            cbyMin: j,\r\n            cbxMax: i,\r\n            cbyMax: j\r\n          };\r\n        }\r\n        codeblock.precinct = precinct;\r\n      }\r\n    }\r\n    subband.codeblockParameters = {\r\n      codeblockWidth: xcb_,\r\n      codeblockHeight: ycb_,\r\n      numcodeblockwide: cbx1 - cbx0 + 1,\r\n      numcodeblockhigh: cby1 - cby1 + 1\r\n    };\r\n    subband.codeblocks = codeblocks;\r\n    for (var i = 0, ii = codeblocks.length; i < ii; i++) {\r\n      var codeblock = codeblocks[i];\r\n      var precinctNumber = codeblock.precinctNumber;\r\n    }\r\n    subband.precincts = precincts;\r\n  }\r\n  function createPacket(resolution, precinctNumber, layerNumber) {\r\n    var precinctCodeblocks = [];\r\n    // Section B.10.8 Order of info in packet\r\n    var subbands = resolution.subbands;\r\n    // sub-bands already ordered in 'LL', 'HL', 'LH', and 'HH' sequence\r\n    for (var i = 0, ii = subbands.length; i < ii; i++) {\r\n      var subband = subbands[i];\r\n      var codeblocks = subband.codeblocks;\r\n      for (var j = 0, jj = codeblocks.length; j < jj; j++) {\r\n        var codeblock = codeblocks[j];\r\n        if (codeblock.precinctNumber != precinctNumber)\r\n          continue;\r\n        precinctCodeblocks.push(codeblock);\r\n      }\r\n    }\r\n    return {\r\n      layerNumber: layerNumber,\r\n      codeblocks: precinctCodeblocks\r\n    };\r\n  }\r\n  function LayerResolutionComponentPositionIterator(context) {\r\n    var siz = context.SIZ;\r\n    var tileIndex = context.currentTile.index;\r\n    var tile = context.tiles[tileIndex];\r\n    var layersCount = tile.codingStyleDefaultParameters.layersCount;\r\n    var componentsCount = siz.Csiz;\r\n    var maxDecompositionLevelsCount = 0;\r\n    for (var q = 0; q < componentsCount; q++) {\r\n      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,\r\n        tile.components[q].codingStyleParameters.decompositionLevelsCount);\r\n    }\r\n\r\n    var l = 0, r = 0, i = 0, k = 0;\r\n\r\n    this.nextPacket = function JpxImage_nextPacket() {\r\n      // Section B.12.1.1 Layer-resolution-component-position\r\n      for (; l < layersCount; l++) {\r\n        for (; r <= maxDecompositionLevelsCount; r++) {\r\n          for (; i < componentsCount; i++) {\r\n            var component = tile.components[i];\r\n            if (r > component.codingStyleParameters.decompositionLevelsCount)\r\n              continue;\r\n\r\n            var resolution = component.resolutions[r];\r\n            var numprecincts = resolution.precinctParameters.numprecincts;\r\n            for (; k < numprecincts;) {\r\n              var packet = createPacket(resolution, k, l);\r\n              k++;\r\n              return packet;\r\n            }\r\n            k = 0;\r\n          }\r\n          i = 0;\r\n        }\r\n        r = 0;\r\n      }\r\n      throw 'Out of packets';\r\n    };\r\n  }\r\n  function ResolutionLayerComponentPositionIterator(context) {\r\n    var siz = context.SIZ;\r\n    var tileIndex = context.currentTile.index;\r\n    var tile = context.tiles[tileIndex];\r\n    var layersCount = tile.codingStyleDefaultParameters.layersCount;\r\n    var componentsCount = siz.Csiz;\r\n    var maxDecompositionLevelsCount = 0;\r\n    for (var q = 0; q < componentsCount; q++) {\r\n      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,\r\n        tile.components[q].codingStyleParameters.decompositionLevelsCount);\r\n    }\r\n\r\n    var r = 0, l = 0, i = 0, k = 0;\r\n\r\n    this.nextPacket = function JpxImage_nextPacket() {\r\n      // Section B.12.1.2 Resolution-layer-component-position\r\n      for (; r <= maxDecompositionLevelsCount; r++) {\r\n        for (; l < layersCount; l++) {\r\n          for (; i < componentsCount; i++) {\r\n            var component = tile.components[i];\r\n            if (r > component.codingStyleParameters.decompositionLevelsCount)\r\n              continue;\r\n\r\n            var resolution = component.resolutions[r];\r\n            var numprecincts = resolution.precinctParameters.numprecincts;\r\n            for (; k < numprecincts;) {\r\n              var packet = createPacket(resolution, k, l);\r\n              k++;\r\n              return packet;\r\n            }\r\n            k = 0;\r\n          }\r\n          i = 0;\r\n        }\r\n        l = 0;\r\n      }\r\n      throw 'Out of packets';\r\n    };\r\n  }\r\n  function buildPackets(context) {\r\n    var siz = context.SIZ;\r\n    var tileIndex = context.currentTile.index;\r\n    var tile = context.tiles[tileIndex];\r\n    var componentsCount = siz.Csiz;\r\n    // Creating resolutions and sub-bands for each component\r\n    for (var c = 0; c < componentsCount; c++) {\r\n      var component = tile.components[c];\r\n      var decompositionLevelsCount =\r\n        component.codingStyleParameters.decompositionLevelsCount;\r\n      // Section B.5 Resolution levels and sub-bands\r\n      var resolutions = [];\r\n      var subbands = [];\r\n      for (var r = 0; r <= decompositionLevelsCount; r++) {\r\n        var blocksDimensions = getBlocksDimensions(context, component, r);\r\n        var resolution = {};\r\n        var scale = 1 << (decompositionLevelsCount - r);\r\n        resolution.trx0 = Math.ceil(component.tcx0 / scale);\r\n        resolution.try0 = Math.ceil(component.tcy0 / scale);\r\n        resolution.trx1 = Math.ceil(component.tcx1 / scale);\r\n        resolution.try1 = Math.ceil(component.tcy1 / scale);\r\n        buildPrecincts(context, resolution, blocksDimensions);\r\n        resolutions.push(resolution);\r\n\r\n        var subband;\r\n        if (r === 0) {\r\n          // one sub-band (LL) with last decomposition\r\n          subband = {};\r\n          subband.type = 'LL';\r\n          subband.tbx0 = Math.ceil(component.tcx0 / scale);\r\n          subband.tby0 = Math.ceil(component.tcy0 / scale);\r\n          subband.tbx1 = Math.ceil(component.tcx1 / scale);\r\n          subband.tby1 = Math.ceil(component.tcy1 / scale);\r\n          subband.resolution = resolution;\r\n          buildCodeblocks(context, subband, blocksDimensions);\r\n          subbands.push(subband);\r\n          resolution.subbands = [subband];\r\n        } else {\r\n          var bscale = 1 << (decompositionLevelsCount - r + 1);\r\n          var resolutionSubbands = [];\r\n          // three sub-bands (HL, LH and HH) with rest of decompositions\r\n          subband = {};\r\n          subband.type = 'HL';\r\n          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);\r\n          subband.tby0 = Math.ceil(component.tcy0 / bscale);\r\n          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);\r\n          subband.tby1 = Math.ceil(component.tcy1 / bscale);\r\n          subband.resolution = resolution;\r\n          buildCodeblocks(context, subband, blocksDimensions);\r\n          subbands.push(subband);\r\n          resolutionSubbands.push(subband);\r\n\r\n          subband = {};\r\n          subband.type = 'LH';\r\n          subband.tbx0 = Math.ceil(component.tcx0 / bscale);\r\n          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);\r\n          subband.tbx1 = Math.ceil(component.tcx1 / bscale);\r\n          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);\r\n          subband.resolution = resolution;\r\n          buildCodeblocks(context, subband, blocksDimensions);\r\n          subbands.push(subband);\r\n          resolutionSubbands.push(subband);\r\n\r\n          subband = {};\r\n          subband.type = 'HH';\r\n          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);\r\n          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);\r\n          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);\r\n          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);\r\n          subband.resolution = resolution;\r\n          buildCodeblocks(context, subband, blocksDimensions);\r\n          subbands.push(subband);\r\n          resolutionSubbands.push(subband);\r\n\r\n          resolution.subbands = resolutionSubbands;\r\n        }\r\n      }\r\n      component.resolutions = resolutions;\r\n      component.subbands = subbands;\r\n    }\r\n    // Generate the packets sequence\r\n    var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;\r\n    var packetsIterator;\r\n    switch (progressionOrder) {\r\n      case 0:\r\n        tile.packetsIterator =\r\n          new LayerResolutionComponentPositionIterator(context);\r\n        break;\r\n      case 1:\r\n        tile.packetsIterator =\r\n          new ResolutionLayerComponentPositionIterator(context);\r\n        break;\r\n      default:\r\n        throw 'Unsupported progression order ' + progressionOrder;\r\n    }\r\n  }\r\n  function parseTilePackets(context, data, offset, dataLength) {\r\n    var position = 0;\r\n    var buffer, bufferSize = 0, skipNextBit = false;\r\n    function readBits(count) {\r\n      while (bufferSize < count) {\r\n        var b = data[offset + position];\r\n        position++;\r\n        if (skipNextBit) {\r\n          buffer = (buffer << 7) | b;\r\n          bufferSize += 7;\r\n          skipNextBit = false;\r\n        } else {\r\n          buffer = (buffer << 8) | b;\r\n          bufferSize += 8;\r\n        }\r\n        if (b == 0xFF) {\r\n          skipNextBit = true;\r\n        }\r\n      }\r\n      bufferSize -= count;\r\n      return (buffer >>> bufferSize) & ((1 << count) - 1);\r\n    }\r\n    function alignToByte() {\r\n      bufferSize = 0;\r\n      if (skipNextBit) {\r\n        position++;\r\n        skipNextBit = false;\r\n      }\r\n    }\r\n    function readCodingpasses() {\r\n      var value = readBits(1);\r\n      if (value === 0)\r\n        return 1;\r\n      value = (value << 1) | readBits(1);\r\n      if (value == 0x02)\r\n        return 2;\r\n      value = (value << 2) | readBits(2);\r\n      if (value <= 0x0E)\r\n        return (value & 0x03) + 3;\r\n      value = (value << 5) | readBits(5);\r\n      if (value <= 0x1FE)\r\n        return (value & 0x1F) + 6;\r\n      value = (value << 7) | readBits(7);\r\n      return (value & 0x7F) + 37;\r\n    }\r\n    var tileIndex = context.currentTile.index;\r\n    var tile = context.tiles[tileIndex];\r\n    var packetsIterator = tile.packetsIterator;\r\n    while (position < dataLength) {\r\n      var packet = packetsIterator.nextPacket();\r\n      if (!readBits(1)) {\r\n        alignToByte();\r\n        continue;\r\n      }\r\n      var layerNumber = packet.layerNumber;\r\n      var queue = [];\r\n      for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {\r\n        var codeblock = packet.codeblocks[i];\r\n        var precinct = codeblock.precinct;\r\n        var codeblockColumn = codeblock.cbx - precinct.cbxMin;\r\n        var codeblockRow = codeblock.cby - precinct.cbyMin;\r\n        var codeblockIncluded = false;\r\n        var firstTimeInclusion = false;\r\n        if ('included' in codeblock) {\r\n          codeblockIncluded = !!readBits(1);\r\n        } else {\r\n          // reading inclusion tree\r\n          var precinct = codeblock.precinct;\r\n          var inclusionTree, zeroBitPlanesTree;\r\n          if ('inclusionTree' in precinct) {\r\n            inclusionTree = precinct.inclusionTree;\r\n          } else {\r\n            // building inclusion and zero bit-planes trees\r\n            var width = precinct.cbxMax - precinct.cbxMin + 1;\r\n            var height = precinct.cbyMax - precinct.cbyMin + 1;\r\n            inclusionTree = new InclusionTree(width, height, layerNumber);\r\n            zeroBitPlanesTree = new TagTree(width, height);\r\n            precinct.inclusionTree = inclusionTree;\r\n            precinct.zeroBitPlanesTree = zeroBitPlanesTree;\r\n          }\r\n\r\n          if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {\r\n            while (true) {\r\n              if (readBits(1)) {\r\n                var valueReady = !inclusionTree.nextLevel();\r\n                if (valueReady) {\r\n                  codeblock.included = true;\r\n                  codeblockIncluded = firstTimeInclusion = true;\r\n                  break;\r\n                }\r\n              } else {\r\n                inclusionTree.incrementValue(layerNumber);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        if (!codeblockIncluded)\r\n          continue;\r\n        if (firstTimeInclusion) {\r\n          zeroBitPlanesTree = precinct.zeroBitPlanesTree;\r\n          zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);\r\n          while (true) {\r\n            if (readBits(1)) {\r\n              var valueReady = !zeroBitPlanesTree.nextLevel();\r\n              if (valueReady)\r\n                break;\r\n            } else\r\n              zeroBitPlanesTree.incrementValue();\r\n          }\r\n          codeblock.zeroBitPlanes = zeroBitPlanesTree.value;\r\n        }\r\n        var codingpasses = readCodingpasses();\r\n        while (readBits(1))\r\n          codeblock.Lblock++;\r\n        var codingpassesLog2 = log2(codingpasses);\r\n        // rounding down log2\r\n        var bits = ((codingpasses < (1 << codingpassesLog2)) ?\r\n          codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;\r\n        var codedDataLength = readBits(bits);\r\n        queue.push({\r\n          codeblock: codeblock,\r\n          codingpasses: codingpasses,\r\n          dataLength: codedDataLength\r\n        });\r\n      }\r\n      alignToByte();\r\n      while (queue.length > 0) {\r\n        var packetItem = queue.shift();\r\n        var codeblock = packetItem.codeblock;\r\n        if (!('data' in codeblock))\r\n          codeblock.data = [];\r\n        codeblock.data.push({\r\n          data: data,\r\n          start: offset + position,\r\n          end: offset + position + packetItem.dataLength,\r\n          codingpasses: packetItem.codingpasses\r\n        });\r\n        position += packetItem.dataLength;\r\n      }\r\n    }\r\n    return position;\r\n  }\r\n  function copyCoefficients(coefficients, x0, y0, width, height,\r\n                            delta, mb, codeblocks, transformation,\r\n                            segmentationSymbolUsed) {\r\n    var r = 0.5; // formula (E-6)\r\n    for (var i = 0, ii = codeblocks.length; i < ii; ++i) {\r\n      var codeblock = codeblocks[i];\r\n      var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;\r\n      var blockHeight = codeblock.tby1_ - codeblock.tby0_;\r\n      if (blockWidth === 0 || blockHeight === 0)\r\n        continue;\r\n      if (!('data' in codeblock))\r\n        continue;\r\n\r\n      var bitModel, currentCodingpassType;\r\n      bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType,\r\n        codeblock.zeroBitPlanes);\r\n      currentCodingpassType = 2; // first bit plane starts from cleanup\r\n\r\n      // collect data\r\n      var data = codeblock.data, totalLength = 0, codingpasses = 0;\r\n      for (var q = 0, qq = data.length; q < qq; q++) {\r\n        var dataItem = data[q];\r\n        totalLength += dataItem.end - dataItem.start;\r\n        codingpasses += dataItem.codingpasses;\r\n      }\r\n      var encodedData = new Uint8Array(totalLength), k = 0;\r\n      for (var q = 0, qq = data.length; q < qq; q++) {\r\n        var dataItem = data[q];\r\n        var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);\r\n        encodedData.set(chunk, k);\r\n        k += chunk.length;\r\n      }\r\n      // decoding the item\r\n      var decoder = new ArithmeticDecoder(encodedData, 0, totalLength);\r\n      bitModel.setDecoder(decoder);\r\n\r\n      for (var q = 0; q < codingpasses; q++) {\r\n        switch (currentCodingpassType) {\r\n          case 0:\r\n            bitModel.runSignificancePropogationPass();\r\n            break;\r\n          case 1:\r\n            bitModel.runMagnitudeRefinementPass();\r\n            break;\r\n          case 2:\r\n            bitModel.runCleanupPass();\r\n            if (segmentationSymbolUsed)\r\n              bitModel.checkSegmentationSymbol();\r\n            break;\r\n        }\r\n        currentCodingpassType = (currentCodingpassType + 1) % 3;\r\n      }\r\n\r\n      var offset = (codeblock.tbx0_ - x0) + (codeblock.tby0_ - y0) * width;\r\n      var position = 0;\r\n      for (var j = 0; j < blockHeight; j++) {\r\n        for (var k = 0; k < blockWidth; k++) {\r\n          var n = (bitModel.coefficentsSign[position] ? -1 : 1) *\r\n            bitModel.coefficentsMagnitude[position];\r\n          var nb = bitModel.bitsDecoded[position], correction;\r\n          if (transformation === 0 || mb > nb) {\r\n            // use r only if transformation is irreversible or\r\n            // not all bitplanes were decoded for reversible transformation\r\n            n += n < 0 ? n - r : n > 0 ? n + r : 0;\r\n            correction = 1 << (mb - nb);\r\n          } else\r\n            correction = 1;\r\n          coefficients[offset++] = n * correction * delta;\r\n          position++;\r\n        }\r\n        offset += width - blockWidth;\r\n      }\r\n    }\r\n  }\r\n  function transformTile(context, tile, c) {\r\n    var component = tile.components[c];\r\n    var codingStyleParameters = component.codingStyleParameters;\r\n    var quantizationParameters = component.quantizationParameters;\r\n    var decompositionLevelsCount =\r\n      codingStyleParameters.decompositionLevelsCount;\r\n    var spqcds = quantizationParameters.SPqcds;\r\n    var scalarExpounded = quantizationParameters.scalarExpounded;\r\n    var guardBits = quantizationParameters.guardBits;\r\n    var transformation = codingStyleParameters.transformation;\r\n    var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;\r\n    var precision = context.components[c].precision;\r\n\r\n    var subbandCoefficients = [];\r\n    var k = 0, b = 0;\r\n    for (var i = 0; i <= decompositionLevelsCount; i++) {\r\n      var resolution = component.resolutions[i];\r\n\r\n      for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {\r\n        var mu, epsilon;\r\n        if (!scalarExpounded) {\r\n          // formula E-5\r\n          mu = spqcds[0].mu;\r\n          epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);\r\n        } else {\r\n          mu = spqcds[b].mu;\r\n          epsilon = spqcds[b].epsilon;\r\n        }\r\n\r\n        var subband = resolution.subbands[j];\r\n        var width = subband.tbx1 - subband.tbx0;\r\n        var height = subband.tby1 - subband.tby0;\r\n        var gainLog2 = SubbandsGainLog2[subband.type];\r\n\r\n        // calulate quantization coefficient (Section E.1.1.1)\r\n        var delta = Math.pow(2, (precision + gainLog2) - epsilon) *\r\n          (1 + mu / 2048);\r\n        var mb = (guardBits + epsilon - 1);\r\n\r\n        var coefficients = new Float32Array(width * height);\r\n        copyCoefficients(coefficients, subband.tbx0, subband.tby0,\r\n          width, height, delta, mb, subband.codeblocks, transformation,\r\n          segmentationSymbolUsed);\r\n\r\n        subbandCoefficients.push({\r\n          width: width,\r\n          height: height,\r\n          items: coefficients\r\n        });\r\n\r\n        b++;\r\n      }\r\n    }\r\n\r\n    var transformation = codingStyleParameters.transformation;\r\n    var transform = transformation === 0 ? new IrreversibleTransform() :\r\n      new ReversibleTransform();\r\n    var result = transform.calculate(subbandCoefficients,\r\n      component.tcx0, component.tcy0);\r\n    return {\r\n      left: component.tcx0,\r\n      top: component.tcy0,\r\n      width: result.width,\r\n      height: result.height,\r\n      items: result.items\r\n    };\r\n  }\r\n  function transformComponents(context) {\r\n    var siz = context.SIZ;\r\n    var components = context.components;\r\n    var componentsCount = siz.Csiz;\r\n    var resultImages = [];\r\n    for (var i = 0, ii = context.tiles.length; i < ii; i++) {\r\n      var tile = context.tiles[i];\r\n      var result = [];\r\n      for (var c = 0; c < componentsCount; c++) {\r\n        var image = transformTile(context, tile, c);\r\n        result.push(image);\r\n      }\r\n\r\n      // Section G.2.2 Inverse multi component transform\r\n      if (tile.codingStyleDefaultParameters.multipleComponentTransform) {\r\n        var y0items = result[0].items;\r\n        var y1items = result[1].items;\r\n        var y2items = result[2].items;\r\n        for (var j = 0, jj = y0items.length; j < jj; j++) {\r\n          var y0 = y0items[j], y1 = y1items[j], y2 = y2items[j];\r\n          var i1 = y0 - ((y2 + y1) >> 2);\r\n          y1items[j] = i1;\r\n          y0items[j] = y2 + i1;\r\n          y2items[j] = y1 + i1;\r\n        }\r\n      }\r\n\r\n      // Section G.1 DC level shifting to unsigned component values\r\n      for (var c = 0; c < componentsCount; c++) {\r\n        var component = components[c];\r\n        if (component.isSigned)\r\n          continue;\r\n\r\n        var offset = 1 << (component.precision - 1);\r\n        var tileImage = result[c];\r\n        var items = tileImage.items;\r\n        for (var j = 0, jj = items.length; j < jj; j++)\r\n          items[j] += offset;\r\n      }\r\n\r\n      // To simplify things: shift and clamp output to 8 bit unsigned\r\n      for (var c = 0; c < componentsCount; c++) {\r\n        var component = components[c];\r\n        var offset = component.isSigned ? 128 : 0;\r\n        var shift = component.precision - 8;\r\n        var tileImage = result[c];\r\n        var items = tileImage.items;\r\n        var data = new Uint8Array(items.length);\r\n        for (var j = 0, jj = items.length; j < jj; j++) {\r\n          var value = (items[j] >> shift) + offset;\r\n          data[j] = value < 0 ? 0 : value > 255 ? 255 : value;\r\n        }\r\n        result[c].items = data;\r\n      }\r\n\r\n      resultImages.push(result);\r\n    }\r\n    return resultImages;\r\n  }\r\n  function initializeTile(context, tileIndex) {\r\n    var siz = context.SIZ;\r\n    var componentsCount = siz.Csiz;\r\n    var tile = context.tiles[tileIndex];\r\n    var resultTiles = [];\r\n    for (var c = 0; c < componentsCount; c++) {\r\n      var component = tile.components[c];\r\n      var qcdOrQcc = c in context.currentTile.QCC ?\r\n        context.currentTile.QCC[c] : context.currentTile.QCD;\r\n      component.quantizationParameters = qcdOrQcc;\r\n      var codOrCoc = c in context.currentTile.COC ?\r\n        context.currentTile.COC[c] : context.currentTile.COD;\r\n      component.codingStyleParameters = codOrCoc;\r\n    }\r\n    tile.codingStyleDefaultParameters = context.currentTile.COD;\r\n  }\r\n\r\n  // Section B.10.2 Tag trees\r\n  var TagTree = (function TagTreeClosure() {\r\n    function TagTree(width, height) {\r\n      var levelsLength = log2(Math.max(width, height)) + 1;\r\n      this.levels = [];\r\n      for (var i = 0; i < levelsLength; i++) {\r\n        var level = {\r\n          width: width,\r\n          height: height,\r\n          items: []\r\n        };\r\n        this.levels.push(level);\r\n        width = Math.ceil(width / 2);\r\n        height = Math.ceil(height / 2);\r\n      }\r\n    }\r\n    TagTree.prototype = {\r\n      reset: function TagTree_reset(i, j) {\r\n        var currentLevel = 0, value = 0;\r\n        while (currentLevel < this.levels.length) {\r\n          var level = this.levels[currentLevel];\r\n          var index = i + j * level.width;\r\n          if (index in level.items) {\r\n            value = level.items[index];\r\n            break;\r\n          }\r\n          level.index = index;\r\n          i >>= 1;\r\n          j >>= 1;\r\n          currentLevel++;\r\n        }\r\n        currentLevel--;\r\n        var level = this.levels[currentLevel];\r\n        level.items[level.index] = value;\r\n        this.currentLevel = currentLevel;\r\n        delete this.value;\r\n      },\r\n      incrementValue: function TagTree_incrementValue() {\r\n        var level = this.levels[this.currentLevel];\r\n        level.items[level.index]++;\r\n      },\r\n      nextLevel: function TagTree_nextLevel() {\r\n        var currentLevel = this.currentLevel;\r\n        var level = this.levels[currentLevel];\r\n        var value = level.items[level.index];\r\n        currentLevel--;\r\n        if (currentLevel < 0) {\r\n          this.value = value;\r\n          return false;\r\n        }\r\n\r\n        this.currentLevel = currentLevel;\r\n        var level = this.levels[currentLevel];\r\n        level.items[level.index] = value;\r\n        return true;\r\n      }\r\n    };\r\n    return TagTree;\r\n  })();\r\n\r\n  var InclusionTree = (function InclusionTreeClosure() {\r\n    function InclusionTree(width, height,  defaultValue) {\r\n      var levelsLength = log2(Math.max(width, height)) + 1;\r\n      this.levels = [];\r\n      for (var i = 0; i < levelsLength; i++) {\r\n        var items = new Uint8Array(width * height);\r\n        for (var j = 0, jj = items.length; j < jj; j++)\r\n          items[j] = defaultValue;\r\n\r\n        var level = {\r\n          width: width,\r\n          height: height,\r\n          items: items\r\n        };\r\n        this.levels.push(level);\r\n\r\n        width = Math.ceil(width / 2);\r\n        height = Math.ceil(height / 2);\r\n      }\r\n    }\r\n    InclusionTree.prototype = {\r\n      reset: function InclusionTree_reset(i, j, stopValue) {\r\n        var currentLevel = 0;\r\n        while (currentLevel < this.levels.length) {\r\n          var level = this.levels[currentLevel];\r\n          var index = i + j * level.width;\r\n          level.index = index;\r\n          var value = level.items[index];\r\n\r\n          if (value == 0xFF)\r\n            break;\r\n\r\n          if (value > stopValue) {\r\n            this.currentLevel = currentLevel;\r\n            // already know about this one, propagating the value to top levels\r\n            this.propagateValues();\r\n            return false;\r\n          }\r\n\r\n          i >>= 1;\r\n          j >>= 1;\r\n          currentLevel++;\r\n        }\r\n        this.currentLevel = currentLevel - 1;\r\n        return true;\r\n      },\r\n      incrementValue: function InclusionTree_incrementValue(stopValue) {\r\n        var level = this.levels[this.currentLevel];\r\n        level.items[level.index] = stopValue + 1;\r\n        this.propagateValues();\r\n      },\r\n      propagateValues: function InclusionTree_propagateValues() {\r\n        var levelIndex = this.currentLevel;\r\n        var level = this.levels[levelIndex];\r\n        var currentValue = level.items[level.index];\r\n        while (--levelIndex >= 0) {\r\n          var level = this.levels[levelIndex];\r\n          level.items[level.index] = currentValue;\r\n        }\r\n      },\r\n      nextLevel: function InclusionTree_nextLevel() {\r\n        var currentLevel = this.currentLevel;\r\n        var level = this.levels[currentLevel];\r\n        var value = level.items[level.index];\r\n        level.items[level.index] = 0xFF;\r\n        currentLevel--;\r\n        if (currentLevel < 0)\r\n          return false;\r\n\r\n        this.currentLevel = currentLevel;\r\n        var level = this.levels[currentLevel];\r\n        level.items[level.index] = value;\r\n        return true;\r\n      }\r\n    };\r\n    return InclusionTree;\r\n  })();\r\n\r\n  // Implements C.3. Arithmetic decoding procedures\r\n  var ArithmeticDecoder = (function ArithmeticDecoderClosure() {\r\n    var QeTable = [\r\n      {qe: 0x5601, nmps: 1, nlps: 1, switchFlag: 1},\r\n      {qe: 0x3401, nmps: 2, nlps: 6, switchFlag: 0},\r\n      {qe: 0x1801, nmps: 3, nlps: 9, switchFlag: 0},\r\n      {qe: 0x0AC1, nmps: 4, nlps: 12, switchFlag: 0},\r\n      {qe: 0x0521, nmps: 5, nlps: 29, switchFlag: 0},\r\n      {qe: 0x0221, nmps: 38, nlps: 33, switchFlag: 0},\r\n      {qe: 0x5601, nmps: 7, nlps: 6, switchFlag: 1},\r\n      {qe: 0x5401, nmps: 8, nlps: 14, switchFlag: 0},\r\n      {qe: 0x4801, nmps: 9, nlps: 14, switchFlag: 0},\r\n      {qe: 0x3801, nmps: 10, nlps: 14, switchFlag: 0},\r\n      {qe: 0x3001, nmps: 11, nlps: 17, switchFlag: 0},\r\n      {qe: 0x2401, nmps: 12, nlps: 18, switchFlag: 0},\r\n      {qe: 0x1C01, nmps: 13, nlps: 20, switchFlag: 0},\r\n      {qe: 0x1601, nmps: 29, nlps: 21, switchFlag: 0},\r\n      {qe: 0x5601, nmps: 15, nlps: 14, switchFlag: 1},\r\n      {qe: 0x5401, nmps: 16, nlps: 14, switchFlag: 0},\r\n      {qe: 0x5101, nmps: 17, nlps: 15, switchFlag: 0},\r\n      {qe: 0x4801, nmps: 18, nlps: 16, switchFlag: 0},\r\n      {qe: 0x3801, nmps: 19, nlps: 17, switchFlag: 0},\r\n      {qe: 0x3401, nmps: 20, nlps: 18, switchFlag: 0},\r\n      {qe: 0x3001, nmps: 21, nlps: 19, switchFlag: 0},\r\n      {qe: 0x2801, nmps: 22, nlps: 19, switchFlag: 0},\r\n      {qe: 0x2401, nmps: 23, nlps: 20, switchFlag: 0},\r\n      {qe: 0x2201, nmps: 24, nlps: 21, switchFlag: 0},\r\n      {qe: 0x1C01, nmps: 25, nlps: 22, switchFlag: 0},\r\n      {qe: 0x1801, nmps: 26, nlps: 23, switchFlag: 0},\r\n      {qe: 0x1601, nmps: 27, nlps: 24, switchFlag: 0},\r\n      {qe: 0x1401, nmps: 28, nlps: 25, switchFlag: 0},\r\n      {qe: 0x1201, nmps: 29, nlps: 26, switchFlag: 0},\r\n      {qe: 0x1101, nmps: 30, nlps: 27, switchFlag: 0},\r\n      {qe: 0x0AC1, nmps: 31, nlps: 28, switchFlag: 0},\r\n      {qe: 0x09C1, nmps: 32, nlps: 29, switchFlag: 0},\r\n      {qe: 0x08A1, nmps: 33, nlps: 30, switchFlag: 0},\r\n      {qe: 0x0521, nmps: 34, nlps: 31, switchFlag: 0},\r\n      {qe: 0x0441, nmps: 35, nlps: 32, switchFlag: 0},\r\n      {qe: 0x02A1, nmps: 36, nlps: 33, switchFlag: 0},\r\n      {qe: 0x0221, nmps: 37, nlps: 34, switchFlag: 0},\r\n      {qe: 0x0141, nmps: 38, nlps: 35, switchFlag: 0},\r\n      {qe: 0x0111, nmps: 39, nlps: 36, switchFlag: 0},\r\n      {qe: 0x0085, nmps: 40, nlps: 37, switchFlag: 0},\r\n      {qe: 0x0049, nmps: 41, nlps: 38, switchFlag: 0},\r\n      {qe: 0x0025, nmps: 42, nlps: 39, switchFlag: 0},\r\n      {qe: 0x0015, nmps: 43, nlps: 40, switchFlag: 0},\r\n      {qe: 0x0009, nmps: 44, nlps: 41, switchFlag: 0},\r\n      {qe: 0x0005, nmps: 45, nlps: 42, switchFlag: 0},\r\n      {qe: 0x0001, nmps: 45, nlps: 43, switchFlag: 0},\r\n      {qe: 0x5601, nmps: 46, nlps: 46, switchFlag: 0}\r\n    ];\r\n\r\n    function ArithmeticDecoder(data, start, end) {\r\n      this.data = data;\r\n      this.bp = start;\r\n      this.dataEnd = end;\r\n\r\n      this.chigh = data[start];\r\n      this.clow = 0;\r\n\r\n      this.byteIn();\r\n\r\n      this.chigh = ((this.chigh << 7) & 0xFFFF) | ((this.clow >> 9) & 0x7F);\r\n      this.clow = (this.clow << 7) & 0xFFFF;\r\n      this.ct -= 7;\r\n      this.a = 0x8000;\r\n    }\r\n\r\n    ArithmeticDecoder.prototype = {\r\n      byteIn: function ArithmeticDecoder_byteIn() {\r\n        var data = this.data;\r\n        var bp = this.bp;\r\n        if (data[bp] == 0xFF) {\r\n          var b1 = data[bp + 1];\r\n          if (b1 > 0x8F) {\r\n            this.clow += 0xFF00;\r\n            this.ct = 8;\r\n          } else {\r\n            bp++;\r\n            this.clow += (data[bp] << 9);\r\n            this.ct = 7;\r\n            this.bp = bp;\r\n          }\r\n        } else {\r\n          bp++;\r\n          this.clow += bp < this.dataEnd ? (data[bp] << 8) : 0xFF00;\r\n          this.ct = 8;\r\n          this.bp = bp;\r\n        }\r\n        if (this.clow > 0xFFFF) {\r\n          this.chigh += (this.clow >> 16);\r\n          this.clow &= 0xFFFF;\r\n        }\r\n      },\r\n      readBit: function ArithmeticDecoder_readBit(cx) {\r\n        var qeIcx = QeTable[cx.index].qe;\r\n        this.a -= qeIcx;\r\n\r\n        if (this.chigh < qeIcx) {\r\n          var d = this.exchangeLps(cx);\r\n          this.renormD();\r\n          return d;\r\n        } else {\r\n          this.chigh -= qeIcx;\r\n          if ((this.a & 0x8000) === 0) {\r\n            var d = this.exchangeMps(cx);\r\n            this.renormD();\r\n            return d;\r\n          } else {\r\n            return cx.mps;\r\n          }\r\n        }\r\n      },\r\n      renormD: function ArithmeticDecoder_renormD() {\r\n        do {\r\n          if (this.ct === 0)\r\n            this.byteIn();\r\n\r\n          this.a <<= 1;\r\n          this.chigh = ((this.chigh << 1) & 0xFFFF) | ((this.clow >> 15) & 1);\r\n          this.clow = (this.clow << 1) & 0xFFFF;\r\n          this.ct--;\r\n        } while ((this.a & 0x8000) === 0);\r\n      },\r\n      exchangeMps: function ArithmeticDecoder_exchangeMps(cx) {\r\n        var d;\r\n        var qeTableIcx = QeTable[cx.index];\r\n        if (this.a < qeTableIcx.qe) {\r\n          d = 1 - cx.mps;\r\n\r\n          if (qeTableIcx.switchFlag == 1) {\r\n            cx.mps = 1 - cx.mps;\r\n          }\r\n          cx.index = qeTableIcx.nlps;\r\n        } else {\r\n          d = cx.mps;\r\n          cx.index = qeTableIcx.nmps;\r\n        }\r\n        return d;\r\n      },\r\n      exchangeLps: function ArithmeticDecoder_exchangeLps(cx) {\r\n        var d;\r\n        var qeTableIcx = QeTable[cx.index];\r\n        if (this.a < qeTableIcx.qe) {\r\n          this.a = qeTableIcx.qe;\r\n          d = cx.mps;\r\n          cx.index = qeTableIcx.nmps;\r\n        } else {\r\n          this.a = qeTableIcx.qe;\r\n          d = 1 - cx.mps;\r\n\r\n          if (qeTableIcx.switchFlag == 1) {\r\n            cx.mps = 1 - cx.mps;\r\n          }\r\n          cx.index = qeTableIcx.nlps;\r\n        }\r\n        return d;\r\n      }\r\n    };\r\n\r\n    return ArithmeticDecoder;\r\n  })();\r\n\r\n  // Section D. Coefficient bit modeling\r\n  var BitModel = (function BitModelClosure() {\r\n    // Table D-1\r\n    // The index is binary presentation: 0dddvvhh, ddd - sum of Di (0..4),\r\n    // vv - sum of Vi (0..2), and hh - sum of Hi (0..2)\r\n    var LLAndLHContextsLabel = new Uint8Array([\r\n      0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4,\r\n      7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6,\r\n      8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8\r\n    ]);\r\n    var HLContextLabel = new Uint8Array([\r\n      0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8,\r\n      8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3,\r\n      4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8\r\n    ]);\r\n    var HHContextLabel = new Uint8Array([\r\n      0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5,\r\n      5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8,\r\n      8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8\r\n    ]);\r\n\r\n    // Table D-2\r\n    function calcSignContribution(significance0, sign0, significance1, sign1) {\r\n      if (significance1) {\r\n        if (!sign1)\r\n          return significance0 ? (!sign0 ? 1 : 0) : 1;\r\n        else\r\n          return significance0 ? (!sign0 ? 0 : -1) : -1;\r\n      } else\r\n        return significance0 ? (!sign0 ? 1 : -1) : 0;\r\n    }\r\n    // Table D-3\r\n    var SignContextLabels = [\r\n      {contextLabel: 13, xorBit: 0},\r\n      {contextLabel: 12, xorBit: 0},\r\n      {contextLabel: 11, xorBit: 0},\r\n      {contextLabel: 10, xorBit: 0},\r\n      {contextLabel: 9, xorBit: 0},\r\n      {contextLabel: 10, xorBit: 1},\r\n      {contextLabel: 11, xorBit: 1},\r\n      {contextLabel: 12, xorBit: 1},\r\n      {contextLabel: 13, xorBit: 1}\r\n    ];\r\n\r\n    function BitModel(width, height, subband, zeroBitPlanes) {\r\n      this.width = width;\r\n      this.height = height;\r\n\r\n      this.contextLabelTable = subband == 'HH' ? HHContextLabel :\r\n        subband == 'HL' ? HLContextLabel : LLAndLHContextsLabel;\r\n\r\n      var coefficientCount = width * height;\r\n\r\n      // coefficients outside the encoding region treated as insignificant\r\n      // add border state cells for significanceState\r\n      this.neighborsSignificance = new Uint8Array(coefficientCount);\r\n      this.coefficentsSign = new Uint8Array(coefficientCount);\r\n      this.coefficentsMagnitude = new Uint32Array(coefficientCount);\r\n      this.processingFlags = new Uint8Array(coefficientCount);\r\n\r\n      var bitsDecoded = new Uint8Array(this.width * this.height);\r\n      for (var i = 0, ii = bitsDecoded.length; i < ii; i++)\r\n        bitsDecoded[i] = zeroBitPlanes;\r\n      this.bitsDecoded = bitsDecoded;\r\n\r\n      this.reset();\r\n    }\r\n\r\n    BitModel.prototype = {\r\n      setDecoder: function BitModel_setDecoder(decoder) {\r\n        this.decoder = decoder;\r\n      },\r\n      reset: function BitModel_reset() {\r\n        this.uniformContext = {index: 46, mps: 0};\r\n        this.runLengthContext = {index: 3, mps: 0};\r\n        this.contexts = [];\r\n        this.contexts.push({index: 4, mps: 0});\r\n        for (var i = 1; i <= 16; i++)\r\n          this.contexts.push({index: 0, mps: 0});\r\n      },\r\n      setNeighborsSignificance:\r\n        function BitModel_setNeighborsSignificance(row, column) {\r\n        var neighborsSignificance = this.neighborsSignificance;\r\n        var width = this.width, height = this.height;\r\n        var index = row * width + column;\r\n        if (row > 0) {\r\n          if (column > 0)\r\n            neighborsSignificance[index - width - 1] += 0x10;\r\n          if (column + 1 < width)\r\n            neighborsSignificance[index - width + 1] += 0x10;\r\n          neighborsSignificance[index - width] += 0x04;\r\n        }\r\n        if (row + 1 < height) {\r\n          if (column > 0)\r\n            neighborsSignificance[index + width - 1] += 0x10;\r\n          if (column + 1 < width)\r\n            neighborsSignificance[index + width + 1] += 0x10;\r\n          neighborsSignificance[index + width] += 0x04;\r\n        }\r\n        if (column > 0)\r\n          neighborsSignificance[index - 1] += 0x01;\r\n        if (column + 1 < width)\r\n          neighborsSignificance[index + 1] += 0x01;\r\n        neighborsSignificance[index] |= 0x80;\r\n      },\r\n      runSignificancePropogationPass:\r\n        function BitModel_runSignificancePropogationPass() {\r\n        var decoder = this.decoder;\r\n        var width = this.width, height = this.height;\r\n        var coefficentsMagnitude = this.coefficentsMagnitude;\r\n        var coefficentsSign = this.coefficentsSign;\r\n        var contextLabels = this.contextLabels;\r\n        var neighborsSignificance = this.neighborsSignificance;\r\n        var processingFlags = this.processingFlags;\r\n        var contexts = this.contexts;\r\n        var labels = this.contextLabelTable;\r\n        var bitsDecoded = this.bitsDecoded;\r\n        // clear processed flag\r\n        var processedInverseMask = ~1;\r\n        var processedMask = 1;\r\n        var firstMagnitudeBitMask = 2;\r\n        for (var q = 0, qq = width * height; q < qq; q++)\r\n          processingFlags[q] &= processedInverseMask;\r\n\r\n        for (var i0 = 0; i0 < height; i0 += 4) {\r\n          for (var j = 0; j < width; j++) {\r\n            var index = i0 * width + j;\r\n            for (var i1 = 0; i1 < 4; i1++, index += width) {\r\n              var i = i0 + i1;\r\n              if (i >= height)\r\n                break;\r\n\r\n              if (coefficentsMagnitude[index] || !neighborsSignificance[index])\r\n                continue;\r\n\r\n              var contextLabel = labels[neighborsSignificance[index]];\r\n              var cx = contexts[contextLabel];\r\n              var decision = decoder.readBit(cx);\r\n              if (decision) {\r\n                var sign = this.decodeSignBit(i, j);\r\n                coefficentsSign[index] = sign;\r\n                coefficentsMagnitude[index] = 1;\r\n                this.setNeighborsSignificance(i, j);\r\n                processingFlags[index] |= firstMagnitudeBitMask;\r\n              }\r\n              bitsDecoded[index]++;\r\n              processingFlags[index] |= processedMask;\r\n            }\r\n          }\r\n        }\r\n      },\r\n      decodeSignBit: function BitModel_decodeSignBit(row, column) {\r\n        var width = this.width, height = this.height;\r\n        var index = row * width + column;\r\n        var coefficentsMagnitude = this.coefficentsMagnitude;\r\n        var coefficentsSign = this.coefficentsSign;\r\n        var horizontalContribution = calcSignContribution(\r\n          column > 0 && coefficentsMagnitude[index - 1],\r\n          coefficentsSign[index - 1],\r\n          column + 1 < width && coefficentsMagnitude[index + 1],\r\n          coefficentsSign[index + 1]);\r\n        var verticalContribution = calcSignContribution(\r\n          row > 0 && coefficentsMagnitude[index - width],\r\n          coefficentsSign[index - width],\r\n          row + 1 < height && coefficentsMagnitude[index + width],\r\n          coefficentsSign[index + width]);\r\n\r\n        var contextLabelAndXor = SignContextLabels[\r\n          3 * (1 - horizontalContribution) + (1 - verticalContribution)];\r\n        var contextLabel = contextLabelAndXor.contextLabel;\r\n        var cx = this.contexts[contextLabel];\r\n        var decoded = this.decoder.readBit(cx);\r\n        return decoded ^ contextLabelAndXor.xorBit;\r\n      },\r\n      runMagnitudeRefinementPass:\r\n        function BitModel_runMagnitudeRefinementPass() {\r\n        var decoder = this.decoder;\r\n        var width = this.width, height = this.height;\r\n        var coefficentsMagnitude = this.coefficentsMagnitude;\r\n        var neighborsSignificance = this.neighborsSignificance;\r\n        var contexts = this.contexts;\r\n        var bitsDecoded = this.bitsDecoded;\r\n        var processingFlags = this.processingFlags;\r\n        var processedMask = 1;\r\n        var firstMagnitudeBitMask = 2;\r\n        for (var i0 = 0; i0 < height; i0 += 4) {\r\n          for (var j = 0; j < width; j++) {\r\n            for (var i1 = 0; i1 < 4; i1++) {\r\n              var i = i0 + i1;\r\n              if (i >= height)\r\n                break;\r\n              var index = i * width + j;\r\n\r\n              // significant but not those that have just become\r\n              if (!coefficentsMagnitude[index] ||\r\n                (processingFlags[index] & processedMask) !== 0)\r\n                continue;\r\n\r\n              var contextLabel = 16;\r\n              if ((processingFlags[index] &\r\n                firstMagnitudeBitMask) !== 0) {\r\n                processingFlags[i * width + j] ^= firstMagnitudeBitMask;\r\n                // first refinement\r\n                var significance = neighborsSignificance[index];\r\n                var sumOfSignificance = (significance & 3) +\r\n                  ((significance >> 2) & 3) + ((significance >> 4) & 7);\r\n                contextLabel = sumOfSignificance >= 1 ? 15 : 14;\r\n              }\r\n\r\n              var cx = contexts[contextLabel];\r\n              var bit = decoder.readBit(cx);\r\n              coefficentsMagnitude[index] =\r\n                (coefficentsMagnitude[index] << 1) | bit;\r\n              bitsDecoded[index]++;\r\n              processingFlags[index] |= processedMask;\r\n            }\r\n          }\r\n        }\r\n      },\r\n      runCleanupPass: function BitModel_runCleanupPass() {\r\n        var decoder = this.decoder;\r\n        var width = this.width, height = this.height;\r\n        var neighborsSignificance = this.neighborsSignificance;\r\n        var significanceState = this.significanceState;\r\n        var coefficentsMagnitude = this.coefficentsMagnitude;\r\n        var coefficentsSign = this.coefficentsSign;\r\n        var contexts = this.contexts;\r\n        var labels = this.contextLabelTable;\r\n        var bitsDecoded = this.bitsDecoded;\r\n        var processingFlags = this.processingFlags;\r\n        var processedMask = 1;\r\n        var firstMagnitudeBitMask = 2;\r\n        var oneRowDown = width;\r\n        var twoRowsDown = width * 2;\r\n        var threeRowsDown = width * 3;\r\n        for (var i0 = 0; i0 < height; i0 += 4) {\r\n          for (var j = 0; j < width; j++) {\r\n            var index0 = i0 * width + j;\r\n            // using the property: labels[neighborsSignificance[index]] == 0\r\n            // when neighborsSignificance[index] == 0\r\n            var allEmpty = i0 + 3 < height &&\r\n              processingFlags[index0] === 0 &&\r\n              processingFlags[index0 + oneRowDown] === 0 &&\r\n              processingFlags[index0 + twoRowsDown] === 0 &&\r\n              processingFlags[index0 + threeRowsDown] === 0 &&\r\n              neighborsSignificance[index0] === 0 &&\r\n              neighborsSignificance[index0 + oneRowDown] === 0 &&\r\n              neighborsSignificance[index0 + twoRowsDown] === 0 &&\r\n              neighborsSignificance[index0 + threeRowsDown] === 0;\r\n            var i1 = 0, index = index0;\r\n            var cx, i;\r\n            if (allEmpty) {\r\n              cx = this.runLengthContext;\r\n              var hasSignificantCoefficent = decoder.readBit(cx);\r\n              if (!hasSignificantCoefficent) {\r\n                bitsDecoded[index0]++;\r\n                bitsDecoded[index0 + oneRowDown]++;\r\n                bitsDecoded[index0 + twoRowsDown]++;\r\n                bitsDecoded[index0 + threeRowsDown]++;\r\n                continue; // next column\r\n              }\r\n              cx = this.uniformContext;\r\n              i1 = (decoder.readBit(cx) << 1) | decoder.readBit(cx);\r\n              i = i0 + i1;\r\n              index += i1 * width;\r\n\r\n              var sign = this.decodeSignBit(i, j);\r\n              coefficentsSign[index] = sign;\r\n              coefficentsMagnitude[index] = 1;\r\n              this.setNeighborsSignificance(i, j);\r\n              processingFlags[index] |= firstMagnitudeBitMask;\r\n\r\n              index = index0;\r\n              for (var i2 = i0; i2 <= i; i2++, index += width)\r\n                bitsDecoded[index]++;\r\n\r\n              i1++;\r\n            }\r\n            for (; i1 < 4; i1++, index += width) {\r\n              i = i0 + i1;\r\n              if (i >= height)\r\n                break;\r\n\r\n              if (coefficentsMagnitude[index] ||\r\n                (processingFlags[index] & processedMask) !== 0)\r\n                continue;\r\n\r\n              var contextLabel = labels[neighborsSignificance[index]];\r\n              cx = contexts[contextLabel];\r\n              var decision = decoder.readBit(cx);\r\n              if (decision == 1) {\r\n                var sign = this.decodeSignBit(i, j);\r\n                coefficentsSign[index] = sign;\r\n                coefficentsMagnitude[index] = 1;\r\n                this.setNeighborsSignificance(i, j);\r\n                processingFlags[index] |= firstMagnitudeBitMask;\r\n              }\r\n              bitsDecoded[index]++;\r\n            }\r\n          }\r\n        }\r\n      },\r\n      checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {\r\n        var decoder = this.decoder;\r\n        var cx = this.uniformContext;\r\n        var symbol = (decoder.readBit(cx) << 3) | (decoder.readBit(cx) << 2) |\r\n                     (decoder.readBit(cx) << 1) | decoder.readBit(cx);\r\n        if (symbol != 0xA)\r\n          throw 'Invalid segmentation symbol';\r\n      }\r\n    };\r\n\r\n    return BitModel;\r\n  })();\r\n\r\n  // Section F, Discrete wavelet transofrmation\r\n  var Transform = (function TransformClosure() {\r\n    function Transform() {\r\n    }\r\n    Transform.prototype.calculate =\r\n      function transformCalculate(subbands, u0, v0) {\r\n      var ll = subbands[0];\r\n      for (var i = 1, ii = subbands.length, j = 1; i < ii; i += 3, j++) {\r\n        ll = this.iterate(ll, subbands[i], subbands[i + 1],\r\n                          subbands[i + 2], u0, v0);\r\n      }\r\n      return ll;\r\n    };\r\n    Transform.prototype.expand = function expand(buffer, bufferPadding, step) {\r\n        // Section F.3.7 extending... using max extension of 4\r\n        var i1 = bufferPadding - 1, j1 = bufferPadding + 1;\r\n        var i2 = bufferPadding + step - 2, j2 = bufferPadding + step;\r\n        buffer[i1--] = buffer[j1++];\r\n        buffer[j2++] = buffer[i2--];\r\n        buffer[i1--] = buffer[j1++];\r\n        buffer[j2++] = buffer[i2--];\r\n        buffer[i1--] = buffer[j1++];\r\n        buffer[j2++] = buffer[i2--];\r\n        buffer[i1--] = buffer[j1++];\r\n        buffer[j2++] = buffer[i2--];\r\n    };\r\n    Transform.prototype.iterate = function Transform_iterate(ll, hl, lh, hh,\r\n                                                            u0, v0) {\r\n      var llWidth = ll.width, llHeight = ll.height, llItems = ll.items;\r\n      var hlWidth = hl.width, hlHeight = hl.height, hlItems = hl.items;\r\n      var lhWidth = lh.width, lhHeight = lh.height, lhItems = lh.items;\r\n      var hhWidth = hh.width, hhHeight = hh.height, hhItems = hh.items;\r\n\r\n      // Section F.3.3 interleave\r\n      var width = llWidth + hlWidth;\r\n      var height = llHeight + lhHeight;\r\n      var items = new Float32Array(width * height);\r\n      for (var i = 0, ii = llHeight; i < ii; i++) {\r\n        var k = i * llWidth, l = i * 2 * width;\r\n        for (var j = 0, jj = llWidth; j < jj; j++, k++, l += 2)\r\n          items[l] = llItems[k];\r\n      }\r\n      for (var i = 0, ii = hlHeight; i < ii; i++) {\r\n        var k = i * hlWidth, l = i * 2 * width + 1;\r\n        for (var j = 0, jj = hlWidth; j < jj; j++, k++, l += 2)\r\n          items[l] = hlItems[k];\r\n      }\r\n      for (var i = 0, ii = lhHeight; i < ii; i++) {\r\n        var k = i * lhWidth, l = (i * 2 + 1) * width;\r\n        for (var j = 0, jj = lhWidth; j < jj; j++, k++, l += 2)\r\n          items[l] = lhItems[k];\r\n      }\r\n      for (var i = 0, ii = hhHeight; i < ii; i++) {\r\n        var k = i * hhWidth, l = (i * 2 + 1) * width + 1;\r\n        for (var j = 0, jj = hhWidth; j < jj; j++, k++, l += 2)\r\n          items[l] = hhItems[k];\r\n      }\r\n\r\n      var bufferPadding = 4;\r\n      var bufferLength = new Float32Array(Math.max(width, height) +\r\n        2 * bufferPadding);\r\n      var buffer = new Float32Array(bufferLength);\r\n      var bufferOut = new Float32Array(bufferLength);\r\n\r\n      // Section F.3.4 HOR_SR\r\n      for (var v = 0; v < height; v++) {\r\n        if (width == 1) {\r\n          // if width = 1, when u0 even keep items as is, when odd divide by 2\r\n          if ((u0 % 1) !== 0) {\r\n            items[v * width] /= 2;\r\n          }\r\n          continue;\r\n        }\r\n\r\n        var k = v * width;\r\n        var l = bufferPadding;\r\n        for (var u = 0; u < width; u++, k++, l++)\r\n          buffer[l] = items[k];\r\n\r\n        this.expand(buffer, bufferPadding, width);\r\n        this.filter(buffer, bufferPadding, width, u0, bufferOut);\r\n\r\n        k = v * width;\r\n        l = bufferPadding;\r\n        for (var u = 0; u < width; u++, k++, l++)\r\n          items[k] = bufferOut[l];\r\n      }\r\n\r\n      // Section F.3.5 VER_SR\r\n      for (var u = 0; u < width; u++) {\r\n        if (height == 1) {\r\n          // if height = 1, when v0 even keep items as is, when odd divide by 2\r\n          if ((v0 % 1) !== 0) {\r\n            items[u] /= 2;\r\n          }\r\n          continue;\r\n        }\r\n\r\n        var k = u;\r\n        var l = bufferPadding;\r\n        for (var v = 0; v < height; v++, k += width, l++)\r\n          buffer[l] = items[k];\r\n\r\n        this.expand(buffer, bufferPadding, height);\r\n        this.filter(buffer, bufferPadding, height, v0, bufferOut);\r\n\r\n        k = u;\r\n        l = bufferPadding;\r\n        for (var v = 0; v < height; v++, k += width, l++)\r\n          items[k] = bufferOut[l];\r\n      }\r\n      return {\r\n        width: width,\r\n        height: height,\r\n        items: items\r\n      };\r\n    };\r\n    return Transform;\r\n  })();\r\n\r\n  // Section 3.8.2 Irreversible 9-7 filter\r\n  var IrreversibleTransform = (function IrreversibleTransformClosure() {\r\n    function IrreversibleTransform() {\r\n      Transform.call(this);\r\n    }\r\n\r\n    IrreversibleTransform.prototype = Object.create(Transform.prototype);\r\n    IrreversibleTransform.prototype.filter =\r\n      function irreversibleTransformFilter(y, offset, length, i0, x) {\r\n      var i0_ = Math.floor(i0 / 2);\r\n      var i1_ = Math.floor((i0 + length) / 2);\r\n      var offset_ = offset - (i0 % 1);\r\n\r\n      var alpha = -1.586134342059924;\r\n      var beta = -0.052980118572961;\r\n      var gamma = 0.882911075530934;\r\n      var delta = 0.443506852043971;\r\n      var K = 1.230174104914001;\r\n      var K_ = 1 / K;\r\n\r\n      // step 1\r\n      var j = offset_ - 2;\r\n      for (var n = i0_ - 1, nn = i1_ + 2; n < nn; n++, j += 2)\r\n        x[j] = K * y[j];\r\n\r\n      // step 2\r\n      var j = offset_ - 3;\r\n      for (var n = i0_ - 2, nn = i1_ + 2; n < nn; n++, j += 2)\r\n        x[j] = K_ * y[j];\r\n\r\n      // step 3\r\n      var j = offset_ - 2;\r\n      for (var n = i0_ - 1, nn = i1_ + 2; n < nn; n++, j += 2)\r\n        x[j] -= delta * (x[j - 1] + x[j + 1]);\r\n\r\n      // step 4\r\n      var j = offset_ - 1;\r\n      for (var n = i0_ - 1, nn = i1_ + 1; n < nn; n++, j += 2)\r\n        x[j] -= gamma * (x[j - 1] + x[j + 1]);\r\n\r\n      // step 5\r\n      var j = offset_;\r\n      for (var n = i0_, nn = i1_ + 1; n < nn; n++, j += 2)\r\n        x[j] -= beta * (x[j - 1] + x[j + 1]);\r\n\r\n      // step 6\r\n      var j = offset_ + 1;\r\n      for (var n = i0_, nn = i1_; n < nn; n++, j += 2)\r\n        x[j] -= alpha * (x[j - 1] + x[j + 1]);\r\n    };\r\n\r\n    return IrreversibleTransform;\r\n  })();\r\n\r\n  // Section 3.8.1 Reversible 5-3 filter\r\n  var ReversibleTransform = (function ReversibleTransformClosure() {\r\n    function ReversibleTransform() {\r\n      Transform.call(this);\r\n    }\r\n\r\n    ReversibleTransform.prototype = Object.create(Transform.prototype);\r\n    ReversibleTransform.prototype.filter =\r\n      function reversibleTransformFilter(y, offset, length, i0, x) {\r\n      var i0_ = Math.floor(i0 / 2);\r\n      var i1_ = Math.floor((i0 + length) / 2);\r\n      var offset_ = offset - (i0 % 1);\r\n\r\n      for (var n = i0_, nn = i1_ + 1, j = offset_; n < nn; n++, j += 2)\r\n        x[j] = y[j] - Math.floor((y[j - 1] + y[j + 1] + 2) / 4);\r\n\r\n      for (var n = i0_, nn = i1_, j = offset_ + 1; n < nn; n++, j += 2)\r\n        x[j] = y[j] + Math.floor((x[j - 1] + x[j + 1]) / 2);\r\n    };\r\n\r\n    return ReversibleTransform;\r\n  })();\r\n\r\n\r\n  })();\r\n\r\n  /**\r\n   * For JPEG 2000's we use a library to decode these images and\r\n   * the stream behaves like all the other DecodeStreams.\r\n   */\r\n\r\n    var JpxStream = DecodeStream.inherit({\r\n        klassName : \"JpxStream\",\r\n\r\n        init : function(bytes, dict) {\r\n          this.dict = dict;\r\n          this.bytes = bytes;\r\n\r\n            this.overrided();          \r\n        },\r\n      ensureBuffer : function(req) {\r\n          if (this.bufferLength)\r\n              return;\r\n\r\n          var jpxImage = new JpxImage();\r\n          jpxImage.parse(this.bytes);\r\n\r\n          var width = jpxImage.width;\r\n          var height = jpxImage.height;\r\n          var componentsCount = jpxImage.componentsCount;\r\n          if (componentsCount != 1 && componentsCount != 3 && componentsCount != 4)\r\n              error('JPX with ' + componentsCount + ' components is not supported');\r\n\r\n          var data = new Uint8Array(width * height * componentsCount);\r\n\r\n          for (var k = 0, kk = jpxImage.tiles.length; k < kk; k++) {\r\n              var tileCompoments = jpxImage.tiles[k];\r\n              var tileWidth = tileCompoments[0].width;\r\n              var tileHeight = tileCompoments[0].height;\r\n              var tileLeft = tileCompoments[0].left;\r\n              var tileTop = tileCompoments[0].top;\r\n\r\n              var dataPosition, sourcePosition, data0, data1, data2, data3, rowFeed;\r\n              switch (componentsCount) {\r\n                  case 1:\r\n                      data0 = tileCompoments[0].items;\r\n\r\n                      dataPosition = width * tileTop + tileLeft;\r\n                      rowFeed = width - tileWidth;\r\n                      sourcePosition = 0;\r\n                      for (var j = 0; j < tileHeight; j++) {\r\n                          for (var i = 0; i < tileWidth; i++)\r\n                              data[dataPosition++] = data0[sourcePosition++];\r\n                          dataPosition += rowFeed;\r\n                      }\r\n                      break;\r\n                  case 3:\r\n                      data0 = tileCompoments[0].items;\r\n                      data1 = tileCompoments[1].items;\r\n                      data2 = tileCompoments[2].items;\r\n\r\n                      dataPosition = (width * tileTop + tileLeft) * 3;\r\n                      rowFeed = (width - tileWidth) * 3;\r\n                      sourcePosition = 0;\r\n                      for (var j = 0; j < tileHeight; j++) {\r\n                          for (var i = 0; i < tileWidth; i++) {\r\n                              data[dataPosition++] = data0[sourcePosition];\r\n                              data[dataPosition++] = data1[sourcePosition];\r\n                              data[dataPosition++] = data2[sourcePosition];\r\n                              sourcePosition++;\r\n                          }\r\n                          dataPosition += rowFeed;\r\n                      }\r\n                      break;\r\n                  case 4:\r\n                      data0 = tileCompoments[0].items;\r\n                      data1 = tileCompoments[1].items;\r\n                      data2 = tileCompoments[2].items;\r\n                      data3 = tileCompoments[3].items;\r\n\r\n                      dataPosition = (width * tileTop + tileLeft) * 4;\r\n                      rowFeed = (width - tileWidth) * 4;\r\n                      sourcePosition = 0;\r\n                      for (var j = 0; j < tileHeight; j++) {\r\n                          for (var i = 0; i < tileWidth; i++) {\r\n                              data[dataPosition++] = data0[sourcePosition];\r\n                              data[dataPosition++] = data1[sourcePosition];\r\n                              data[dataPosition++] = data2[sourcePosition];\r\n                              data[dataPosition++] = data3[sourcePosition];\r\n                              sourcePosition++;\r\n                          }\r\n                          dataPosition += rowFeed;\r\n                      }\r\n                      break;\r\n              }\r\n          }\r\n\r\n          this.buffer = data;\r\n          this.bufferLength = data.length;\r\n      },\r\n\r\n      getChar : function JpxStream_getChar() {\r\n          error('internal error: getChar is not valid on JpxStream');\r\n      }\r\n    });\r\n\r\n  return codec.jpx = {\r\n    \"JpxImage\" :JpxImage,\r\n    \"JpxStream\" : JpxStream\r\n  };\r\n  \r\n});\r\n"]}