{"version":3,"sources":["jpx.js"],"names":["define","langx","DecodeStream","codec","JpxImage","log2","x","n","i","TagTree","width","height","levelsLength","Math","max","this","levels","level","items","push","ceil","prototype","reset","j","currentLevel","value","length","index","incrementValue","nextLevel","InclusionTree","defaultValue","Uint8Array","jj","stopValue","propagateValues","levelIndex","currentValue","QeTable","qe","nmps","nlps","switchFlag","ArithmeticDecoder","data","start","end","bp","dataEnd","chigh","clow","byteIn","ct","a","readBit","cx","qeIcx","d","exchangeLps","renormD","exchangeMps","mps","qeTableIcx","LLAndLHContextsLabel","HLContextLabel","HHContextLabel","calcSignContribution","significance0","sign0","significance1","sign1","SignContextLabels","contextLabel","xorBit","BitModel","subband","zeroBitPlanes","contextLabelTable","coefficientCount","neighborsSignificance","coefficentsSign","coefficentsMagnitude","Uint32Array","processingFlags","bitsDecoded","ii","setDecoder","decoder","uniformContext","runLengthContext","contexts","setNeighborsSignificance","row","column","runSignificancePropogationPass","contextLabels","labels","q","qq","i0","i1","sign","decodeSignBit","horizontalContribution","verticalContribution","contextLabelAndXor","runMagnitudeRefinementPass","significance","bit","runCleanupPass","significanceState","oneRowDown","twoRowsDown","threeRowsDown","index0","i2","checkSegmentationSymbol","Transform","calculate","subbands","u0","v0","ll","iterate","expand","buffer","bufferPadding","step","j1","j2","hl","lh","hh","llWidth","llHeight","llItems","hlWidth","hlHeight","hlItems","lhWidth","lhHeight","lhItems","hhWidth","hhHeight","hhItems","Float32Array","k","l","bufferLength","bufferOut","v","u","filter","IrreversibleTransform","call","Object","create","y","offset","i0_","floor","i1_","offset_","K","nn","ReversibleTransform","JpxStream","inherit","klassName","init","bytes","dict","overrided","ensureBuffer","req","jpxImage","parse","componentsCount","error","kk","tiles","dataPosition","sourcePosition","data0","data1","data2","data3","rowFeed","tileCompoments","tileWidth","tileHeight","tileLeft","left","tileTop","top","getChar","jpx"],"mappings":"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","file":"../jpx.js","sourcesContent":["define([\n  \"skylark-langx/langx\",\n  \"skylark-utils-stream/DecodeStream\",\n  \"./codec\"\n],function(langx,DecodeStream,codec){\n  'use strict';\n\nvar JpxImage = (function JpxImageClosure() {\n  // Table E.1\n  var SubbandsGainLog2 = {\n    'LL': 0,\n    'LH': 1,\n    'HL': 1,\n    'HH': 2\n  };\n  function JpxImage() {\n    this.failOnCorruptedImage = false;\n  }\n  JpxImage.prototype = {\n    load: function JpxImage_load(url) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onload = (function() {\n        // TODO catch parse error\n        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n        this.parse(data);\n        if (this.onload)\n          this.onload();\n      }).bind(this);\n      xhr.send(null);\n    },\n    parse: function JpxImage_parse(data) {\n      function readUint(data, offset, bytes) {\n        var n = 0;\n        for (var i = 0; i < bytes; i++)\n          n = n * 256 + (data[offset + i] & 0xFF);\n        return n;\n      }\n      var position = 0, length = data.length;\n      while (position < length) {\n        var headerSize = 8;\n        var lbox = readUint(data, position, 4);\n        var tbox = readUint(data, position + 4, 4);\n        position += headerSize;\n        if (lbox == 1) {\n          lbox = readUint(data, position, 8);\n          position += 8;\n          headerSize += 8;\n        }\n        if (lbox === 0)\n          lbox = length - position + headerSize;\n        if (lbox < headerSize)\n          error('JPX error: Invalid box field size');\n        var dataLength = lbox - headerSize;\n        var jumpDataLength = true;\n        switch (tbox) {\n          case 0x6A501A1A: // 'jP\\032\\032'\n            // TODO\n            break;\n          case 0x6A703268: // 'jp2h'\n            jumpDataLength = false; // parsing child boxes\n            break;\n          case 0x636F6C72: // 'colr'\n            // TODO\n            break;\n          case 0x6A703263: // 'jp2c'\n            this.parseCodestream(data, position, position + dataLength);\n            break;\n        }\n        if (jumpDataLength)\n          position += dataLength;\n      }\n    },\n    parseCodestream: function JpxImage_parseCodestream(data, start, end) {\n      var context = {};\n      try {\n        var position = start;\n        while (position < end) {\n          var code = readUint16(data, position);\n          position += 2;\n\n          var length = 0, j;\n          switch (code) {\n            case 0xFF4F: // Start of codestream (SOC)\n              context.mainHeader = true;\n              break;\n            case 0xFFD9: // End of codestream (EOC)\n              break;\n            case 0xFF51: // Image and tile size (SIZ)\n              length = readUint16(data, position);\n              var siz = {};\n              siz.Xsiz = readUint32(data, position + 4);\n              siz.Ysiz = readUint32(data, position + 8);\n              siz.XOsiz = readUint32(data, position + 12);\n              siz.YOsiz = readUint32(data, position + 16);\n              siz.XTsiz = readUint32(data, position + 20);\n              siz.YTsiz = readUint32(data, position + 24);\n              siz.XTOsiz = readUint32(data, position + 28);\n              siz.YTOsiz = readUint32(data, position + 32);\n              var componentsCount = readUint16(data, position + 36);\n              siz.Csiz = componentsCount;\n              var components = [];\n              j = position + 38;\n              for (var i = 0; i < componentsCount; i++) {\n                var component = {\n                  precision: (data[j] & 0x7F) + 1,\n                  isSigned: !!(data[j] & 0x80),\n                  XRsiz: data[j + 1],\n                  YRsiz: data[j + 1]\n                };\n                calculateComponentDimensions(component, siz);\n                components.push(component);\n              }\n              context.SIZ = siz;\n              context.components = components;\n              calculateTileGrids(context, components);\n              context.QCC = [];\n              context.COC = [];\n              break;\n            case 0xFF5C: // Quantization default (QCD)\n              length = readUint16(data, position);\n              var qcd = {};\n              j = position + 2;\n              var sqcd = data[j++];\n              var spqcdSize, scalarExpounded;\n              switch (sqcd & 0x1F) {\n                case 0:\n                  spqcdSize = 8;\n                  scalarExpounded = true;\n                  break;\n                case 1:\n                  spqcdSize = 16;\n                  scalarExpounded = false;\n                  break;\n                case 2:\n                  spqcdSize = 16;\n                  scalarExpounded = true;\n                  break;\n                default:\n                  throw 'Invalid SQcd value ' + sqcd;\n              }\n              qcd.noQuantization = spqcdSize == 8;\n              qcd.scalarExpounded = scalarExpounded;\n              qcd.guardBits = sqcd >> 5;\n              var spqcds = [];\n              while (j < length + position) {\n                var spqcd = {};\n                if (spqcdSize == 8) {\n                  spqcd.epsilon = data[j++] >> 3;\n                  spqcd.mu = 0;\n                } else {\n                  spqcd.epsilon = data[j] >> 3;\n                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];\n                  j += 2;\n                }\n                spqcds.push(spqcd);\n              }\n              qcd.SPqcds = spqcds;\n              if (context.mainHeader)\n                context.QCD = qcd;\n              else {\n                context.currentTile.QCD = qcd;\n                context.currentTile.QCC = [];\n              }\n              break;\n            case 0xFF5D: // Quantization component (QCC)\n              length = readUint16(data, position);\n              var qcc = {};\n              j = position + 2;\n              var cqcc;\n              if (context.SIZ.Csiz < 257)\n                cqcc = data[j++];\n              else {\n                cqcc = readUint16(data, j);\n                j += 2;\n              }\n              var sqcd = data[j++];\n              var spqcdSize, scalarExpounded;\n              switch (sqcd & 0x1F) {\n                case 0:\n                  spqcdSize = 8;\n                  scalarExpounded = true;\n                  break;\n                case 1:\n                  spqcdSize = 16;\n                  scalarExpounded = false;\n                  break;\n                case 2:\n                  spqcdSize = 16;\n                  scalarExpounded = true;\n                  break;\n                default:\n                  throw 'Invalid SQcd value ' + sqcd;\n              }\n              qcc.noQuantization = spqcdSize == 8;\n              qcc.scalarExpounded = scalarExpounded;\n              qcc.guardBits = sqcd >> 5;\n              var spqcds = [];\n              while (j < length + position) {\n                var spqcd = {};\n                if (spqcdSize == 8) {\n                  spqcd.epsilon = data[j++] >> 3;\n                  spqcd.mu = 0;\n                } else {\n                  spqcd.epsilon = data[j] >> 3;\n                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];\n                  j += 2;\n                }\n                spqcds.push(spqcd);\n              }\n              qcc.SPqcds = spqcds;\n              if (context.mainHeader)\n                context.QCC[cqcc] = qcc;\n              else\n                context.currentTile.QCC[cqcc] = qcc;\n              break;\n            case 0xFF52: // Coding style default (COD)\n              length = readUint16(data, position);\n              var cod = {};\n              j = position + 2;\n              var scod = data[j++];\n              cod.entropyCoderWithCustomPrecincts = !!(scod & 1);\n              cod.sopMarkerUsed = !!(scod & 2);\n              cod.ephMarkerUsed = !!(scod & 4);\n              var codingStyle = {};\n              cod.progressionOrder = data[j++];\n              cod.layersCount = readUint16(data, j);\n              j += 2;\n              cod.multipleComponentTransform = data[j++];\n\n              cod.decompositionLevelsCount = data[j++];\n              cod.xcb = (data[j++] & 0xF) + 2;\n              cod.ycb = (data[j++] & 0xF) + 2;\n              var blockStyle = data[j++];\n              cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);\n              cod.resetContextProbabilities = !!(blockStyle & 2);\n              cod.terminationOnEachCodingPass = !!(blockStyle & 4);\n              cod.verticalyStripe = !!(blockStyle & 8);\n              cod.predictableTermination = !!(blockStyle & 16);\n              cod.segmentationSymbolUsed = !!(blockStyle & 32);\n              cod.transformation = data[j++];\n              if (cod.entropyCoderWithCustomPrecincts) {\n                var precinctsSizes = {};\n                while (j < length + position) {\n                  var precinctsSize = data[j];\n                  precinctsSizes.push({\n                    PPx: precinctsSize & 0xF,\n                    PPy: precinctsSize >> 4\n                  });\n                }\n                cod.precinctsSizes = precinctsSizes;\n              }\n\n              if (cod.sopMarkerUsed || cod.ephMarkerUsed ||\n                  cod.selectiveArithmeticCodingBypass ||\n                  cod.resetContextProbabilities ||\n                  cod.terminationOnEachCodingPass ||\n                  cod.verticalyStripe || cod.predictableTermination)\n                throw 'Unsupported COD options: ' +\n                  globalScope.JSON.stringify(cod);\n\n              if (context.mainHeader)\n                context.COD = cod;\n              else {\n                context.currentTile.COD = cod;\n                context.currentTile.COC = [];\n              }\n              break;\n            case 0xFF90: // Start of tile-part (SOT)\n              length = readUint16(data, position);\n              var tile = {};\n              tile.index = readUint16(data, position + 2);\n              tile.length = readUint32(data, position + 4);\n              tile.dataEnd = tile.length + position - 2;\n              tile.partIndex = data[position + 8];\n              tile.partsCount = data[position + 9];\n\n              context.mainHeader = false;\n              if (tile.partIndex === 0) {\n                // reset component specific settings\n                tile.COD = context.COD;\n                tile.COC = context.COC.slice(0); // clone of the global COC\n                tile.QCD = context.QCD;\n                tile.QCC = context.QCC.slice(0); // clone of the global COC\n              }\n              context.currentTile = tile;\n              break;\n            case 0xFF93: // Start of data (SOD)\n              var tile = context.currentTile;\n              if (tile.partIndex === 0) {\n                initializeTile(context, tile.index);\n                buildPackets(context);\n              }\n\n              // moving to the end of the data\n              length = tile.dataEnd - position;\n\n              parseTilePackets(context, data, position, length);\n              break;\n            case 0xFF64: // Comment (COM)\n              length = readUint16(data, position);\n              // skipping content\n              break;\n            default:\n              throw 'Unknown codestream code: ' + code.toString(16);\n          }\n          position += length;\n        }\n      } catch (e) {\n        if (this.failOnCorruptedImage)\n          error('JPX error: ' + e);\n        else\n          warn('JPX error: ' + e + '. Trying to recover');\n      }\n      this.tiles = transformComponents(context);\n      this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;\n      this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;\n      this.componentsCount = context.SIZ.Csiz;\n    }\n  };\n  function readUint32(data, offset) {\n    return (data[offset] << 24) | (data[offset + 1] << 16) |\n      (data[offset + 2] << 8) | data[offset + 3];\n  }\n  function readUint16(data, offset) {\n    return (data[offset] << 8) | data[offset + 1];\n  }\n  function log2(x) {\n    var n = 1, i = 0;\n    while (x > n) {\n      n <<= 1;\n      i++;\n    }\n    return i;\n  }\n  function calculateComponentDimensions(component, siz) {\n    // Section B.2 Component mapping\n    component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);\n    component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);\n    component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);\n    component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);\n    component.width = component.x1 - component.x0;\n    component.height = component.y1 - component.y0;\n  }\n  function calculateTileGrids(context, components) {\n    var siz = context.SIZ;\n    // Section B.3 Division into tile and tile-components\n    var tiles = [];\n    var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);\n    var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);\n    for (var q = 0; q < numYtiles; q++) {\n      for (var p = 0; p < numXtiles; p++) {\n        var tile = {};\n        tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);\n        tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);\n        tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);\n        tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);\n        tile.width = tile.tx1 - tile.tx0;\n        tile.height = tile.ty1 - tile.ty0;\n        tile.components = [];\n        tiles.push(tile);\n      }\n    }\n    context.tiles = tiles;\n\n    var componentsCount = siz.Csiz;\n    for (var i = 0, ii = componentsCount; i < ii; i++) {\n      var component = components[i];\n      var tileComponents = [];\n      for (var j = 0, jj = tiles.length; j < jj; j++) {\n        var tileComponent = {}, tile = tiles[j];\n        tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);\n        tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);\n        tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);\n        tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);\n        tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;\n        tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;\n        tile.components[i] = tileComponent;\n      }\n    }\n  }\n  function getBlocksDimensions(context, component, r) {\n    var codOrCoc = component.codingStyleParameters;\n    var result = {};\n    if (!codOrCoc.entropyCoderWithCustomPrecincts) {\n      result.PPx = 15;\n      result.PPy = 15;\n    } else {\n      result.PPx = codOrCoc.precinctsSizes[r].PPx;\n      result.PPy = codOrCoc.precinctsSizes[r].PPy;\n    }\n    // calculate codeblock size as described in section B.7\n    result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) :\n      Math.min(codOrCoc.xcb, result.PPx);\n    result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) :\n      Math.min(codOrCoc.ycb, result.PPy);\n    return result;\n  }\n  function buildPrecincts(context, resolution, dimensions) {\n    // Section B.6 Division resolution to precincts\n    var precinctWidth = 1 << dimensions.PPx;\n    var precinctHeight = 1 << dimensions.PPy;\n    var numprecinctswide = resolution.trx1 > resolution.trx0 ?\n      Math.ceil(resolution.trx1 / precinctWidth) -\n      Math.floor(resolution.trx0 / precinctWidth) : 0;\n    var numprecinctshigh = resolution.try1 > resolution.try0 ?\n      Math.ceil(resolution.try1 / precinctHeight) -\n      Math.floor(resolution.try0 / precinctHeight) : 0;\n    var numprecincts = numprecinctswide * numprecinctshigh;\n    var precinctXOffset = Math.floor(resolution.trx0 / precinctWidth) *\n      precinctWidth;\n    var precinctYOffset = Math.floor(resolution.try0 / precinctHeight) *\n      precinctHeight;\n    resolution.precinctParameters = {\n      precinctXOffset: precinctXOffset,\n      precinctYOffset: precinctYOffset,\n      precinctWidth: precinctWidth,\n      precinctHeight: precinctHeight,\n      numprecinctswide: numprecinctswide,\n      numprecinctshigh: numprecinctshigh,\n      numprecincts: numprecincts\n    };\n  }\n  function buildCodeblocks(context, subband, dimensions) {\n    // Section B.7 Division sub-band into code-blocks\n    var xcb_ = dimensions.xcb_;\n    var ycb_ = dimensions.ycb_;\n    var codeblockWidth = 1 << xcb_;\n    var codeblockHeight = 1 << ycb_;\n    var cbx0 = Math.floor(subband.tbx0 / codeblockWidth);\n    var cby0 = Math.floor(subband.tby0 / codeblockHeight);\n    var cbx1 = Math.ceil(subband.tbx1 / codeblockWidth);\n    var cby1 = Math.ceil(subband.tby1 / codeblockHeight);\n    var precinctParameters = subband.resolution.precinctParameters;\n    var codeblocks = [];\n    var precincts = [];\n    for (var j = cby0; j < cby1; j++) {\n      for (var i = cbx0; i < cbx1; i++) {\n        var codeblock = {\n          cbx: i,\n          cby: j,\n          tbx0: codeblockWidth * i,\n          tby0: codeblockHeight * j,\n          tbx1: codeblockWidth * (i + 1),\n          tby1: codeblockHeight * (j + 1)\n        };\n        // calculate precinct number\n        var pi = Math.floor((codeblock.tbx0 -\n          precinctParameters.precinctXOffset) /\n          precinctParameters.precinctWidth);\n        var pj = Math.floor((codeblock.tby0 -\n          precinctParameters.precinctYOffset) /\n          precinctParameters.precinctHeight);\n        var precinctNumber = pj +\n          pi * precinctParameters.numprecinctswide;\n        codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);\n        codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);\n        codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);\n        codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);\n        codeblock.precinctNumber = precinctNumber;\n        codeblock.subbandType = subband.type;\n        var coefficientsLength = (codeblock.tbx1_ - codeblock.tbx0_) *\n          (codeblock.tby1_ - codeblock.tby0_);\n        codeblock.Lblock = 3;\n        codeblocks.push(codeblock);\n        // building precinct for the sub-band\n        var precinct;\n        if (precinctNumber in precincts) {\n          precinct = precincts[precinctNumber];\n          precinct.cbxMin = Math.min(precinct.cbxMin, i);\n          precinct.cbyMin = Math.min(precinct.cbyMin, j);\n          precinct.cbxMax = Math.max(precinct.cbxMax, i);\n          precinct.cbyMax = Math.max(precinct.cbyMax, j);\n        } else {\n          precincts[precinctNumber] = precinct = {\n            cbxMin: i,\n            cbyMin: j,\n            cbxMax: i,\n            cbyMax: j\n          };\n        }\n        codeblock.precinct = precinct;\n      }\n    }\n    subband.codeblockParameters = {\n      codeblockWidth: xcb_,\n      codeblockHeight: ycb_,\n      numcodeblockwide: cbx1 - cbx0 + 1,\n      numcodeblockhigh: cby1 - cby1 + 1\n    };\n    subband.codeblocks = codeblocks;\n    for (var i = 0, ii = codeblocks.length; i < ii; i++) {\n      var codeblock = codeblocks[i];\n      var precinctNumber = codeblock.precinctNumber;\n    }\n    subband.precincts = precincts;\n  }\n  function createPacket(resolution, precinctNumber, layerNumber) {\n    var precinctCodeblocks = [];\n    // Section B.10.8 Order of info in packet\n    var subbands = resolution.subbands;\n    // sub-bands already ordered in 'LL', 'HL', 'LH', and 'HH' sequence\n    for (var i = 0, ii = subbands.length; i < ii; i++) {\n      var subband = subbands[i];\n      var codeblocks = subband.codeblocks;\n      for (var j = 0, jj = codeblocks.length; j < jj; j++) {\n        var codeblock = codeblocks[j];\n        if (codeblock.precinctNumber != precinctNumber)\n          continue;\n        precinctCodeblocks.push(codeblock);\n      }\n    }\n    return {\n      layerNumber: layerNumber,\n      codeblocks: precinctCodeblocks\n    };\n  }\n  function LayerResolutionComponentPositionIterator(context) {\n    var siz = context.SIZ;\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var layersCount = tile.codingStyleDefaultParameters.layersCount;\n    var componentsCount = siz.Csiz;\n    var maxDecompositionLevelsCount = 0;\n    for (var q = 0; q < componentsCount; q++) {\n      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,\n        tile.components[q].codingStyleParameters.decompositionLevelsCount);\n    }\n\n    var l = 0, r = 0, i = 0, k = 0;\n\n    this.nextPacket = function JpxImage_nextPacket() {\n      // Section B.12.1.1 Layer-resolution-component-position\n      for (; l < layersCount; l++) {\n        for (; r <= maxDecompositionLevelsCount; r++) {\n          for (; i < componentsCount; i++) {\n            var component = tile.components[i];\n            if (r > component.codingStyleParameters.decompositionLevelsCount)\n              continue;\n\n            var resolution = component.resolutions[r];\n            var numprecincts = resolution.precinctParameters.numprecincts;\n            for (; k < numprecincts;) {\n              var packet = createPacket(resolution, k, l);\n              k++;\n              return packet;\n            }\n            k = 0;\n          }\n          i = 0;\n        }\n        r = 0;\n      }\n      throw 'Out of packets';\n    };\n  }\n  function ResolutionLayerComponentPositionIterator(context) {\n    var siz = context.SIZ;\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var layersCount = tile.codingStyleDefaultParameters.layersCount;\n    var componentsCount = siz.Csiz;\n    var maxDecompositionLevelsCount = 0;\n    for (var q = 0; q < componentsCount; q++) {\n      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,\n        tile.components[q].codingStyleParameters.decompositionLevelsCount);\n    }\n\n    var r = 0, l = 0, i = 0, k = 0;\n\n    this.nextPacket = function JpxImage_nextPacket() {\n      // Section B.12.1.2 Resolution-layer-component-position\n      for (; r <= maxDecompositionLevelsCount; r++) {\n        for (; l < layersCount; l++) {\n          for (; i < componentsCount; i++) {\n            var component = tile.components[i];\n            if (r > component.codingStyleParameters.decompositionLevelsCount)\n              continue;\n\n            var resolution = component.resolutions[r];\n            var numprecincts = resolution.precinctParameters.numprecincts;\n            for (; k < numprecincts;) {\n              var packet = createPacket(resolution, k, l);\n              k++;\n              return packet;\n            }\n            k = 0;\n          }\n          i = 0;\n        }\n        l = 0;\n      }\n      throw 'Out of packets';\n    };\n  }\n  function buildPackets(context) {\n    var siz = context.SIZ;\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var componentsCount = siz.Csiz;\n    // Creating resolutions and sub-bands for each component\n    for (var c = 0; c < componentsCount; c++) {\n      var component = tile.components[c];\n      var decompositionLevelsCount =\n        component.codingStyleParameters.decompositionLevelsCount;\n      // Section B.5 Resolution levels and sub-bands\n      var resolutions = [];\n      var subbands = [];\n      for (var r = 0; r <= decompositionLevelsCount; r++) {\n        var blocksDimensions = getBlocksDimensions(context, component, r);\n        var resolution = {};\n        var scale = 1 << (decompositionLevelsCount - r);\n        resolution.trx0 = Math.ceil(component.tcx0 / scale);\n        resolution.try0 = Math.ceil(component.tcy0 / scale);\n        resolution.trx1 = Math.ceil(component.tcx1 / scale);\n        resolution.try1 = Math.ceil(component.tcy1 / scale);\n        buildPrecincts(context, resolution, blocksDimensions);\n        resolutions.push(resolution);\n\n        var subband;\n        if (r === 0) {\n          // one sub-band (LL) with last decomposition\n          subband = {};\n          subband.type = 'LL';\n          subband.tbx0 = Math.ceil(component.tcx0 / scale);\n          subband.tby0 = Math.ceil(component.tcy0 / scale);\n          subband.tbx1 = Math.ceil(component.tcx1 / scale);\n          subband.tby1 = Math.ceil(component.tcy1 / scale);\n          subband.resolution = resolution;\n          buildCodeblocks(context, subband, blocksDimensions);\n          subbands.push(subband);\n          resolution.subbands = [subband];\n        } else {\n          var bscale = 1 << (decompositionLevelsCount - r + 1);\n          var resolutionSubbands = [];\n          // three sub-bands (HL, LH and HH) with rest of decompositions\n          subband = {};\n          subband.type = 'HL';\n          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);\n          subband.tby0 = Math.ceil(component.tcy0 / bscale);\n          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);\n          subband.tby1 = Math.ceil(component.tcy1 / bscale);\n          subband.resolution = resolution;\n          buildCodeblocks(context, subband, blocksDimensions);\n          subbands.push(subband);\n          resolutionSubbands.push(subband);\n\n          subband = {};\n          subband.type = 'LH';\n          subband.tbx0 = Math.ceil(component.tcx0 / bscale);\n          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);\n          subband.tbx1 = Math.ceil(component.tcx1 / bscale);\n          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);\n          subband.resolution = resolution;\n          buildCodeblocks(context, subband, blocksDimensions);\n          subbands.push(subband);\n          resolutionSubbands.push(subband);\n\n          subband = {};\n          subband.type = 'HH';\n          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);\n          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);\n          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);\n          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);\n          subband.resolution = resolution;\n          buildCodeblocks(context, subband, blocksDimensions);\n          subbands.push(subband);\n          resolutionSubbands.push(subband);\n\n          resolution.subbands = resolutionSubbands;\n        }\n      }\n      component.resolutions = resolutions;\n      component.subbands = subbands;\n    }\n    // Generate the packets sequence\n    var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;\n    var packetsIterator;\n    switch (progressionOrder) {\n      case 0:\n        tile.packetsIterator =\n          new LayerResolutionComponentPositionIterator(context);\n        break;\n      case 1:\n        tile.packetsIterator =\n          new ResolutionLayerComponentPositionIterator(context);\n        break;\n      default:\n        throw 'Unsupported progression order ' + progressionOrder;\n    }\n  }\n  function parseTilePackets(context, data, offset, dataLength) {\n    var position = 0;\n    var buffer, bufferSize = 0, skipNextBit = false;\n    function readBits(count) {\n      while (bufferSize < count) {\n        var b = data[offset + position];\n        position++;\n        if (skipNextBit) {\n          buffer = (buffer << 7) | b;\n          bufferSize += 7;\n          skipNextBit = false;\n        } else {\n          buffer = (buffer << 8) | b;\n          bufferSize += 8;\n        }\n        if (b == 0xFF) {\n          skipNextBit = true;\n        }\n      }\n      bufferSize -= count;\n      return (buffer >>> bufferSize) & ((1 << count) - 1);\n    }\n    function alignToByte() {\n      bufferSize = 0;\n      if (skipNextBit) {\n        position++;\n        skipNextBit = false;\n      }\n    }\n    function readCodingpasses() {\n      var value = readBits(1);\n      if (value === 0)\n        return 1;\n      value = (value << 1) | readBits(1);\n      if (value == 0x02)\n        return 2;\n      value = (value << 2) | readBits(2);\n      if (value <= 0x0E)\n        return (value & 0x03) + 3;\n      value = (value << 5) | readBits(5);\n      if (value <= 0x1FE)\n        return (value & 0x1F) + 6;\n      value = (value << 7) | readBits(7);\n      return (value & 0x7F) + 37;\n    }\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var packetsIterator = tile.packetsIterator;\n    while (position < dataLength) {\n      var packet = packetsIterator.nextPacket();\n      if (!readBits(1)) {\n        alignToByte();\n        continue;\n      }\n      var layerNumber = packet.layerNumber;\n      var queue = [];\n      for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {\n        var codeblock = packet.codeblocks[i];\n        var precinct = codeblock.precinct;\n        var codeblockColumn = codeblock.cbx - precinct.cbxMin;\n        var codeblockRow = codeblock.cby - precinct.cbyMin;\n        var codeblockIncluded = false;\n        var firstTimeInclusion = false;\n        if ('included' in codeblock) {\n          codeblockIncluded = !!readBits(1);\n        } else {\n          // reading inclusion tree\n          var precinct = codeblock.precinct;\n          var inclusionTree, zeroBitPlanesTree;\n          if ('inclusionTree' in precinct) {\n            inclusionTree = precinct.inclusionTree;\n          } else {\n            // building inclusion and zero bit-planes trees\n            var width = precinct.cbxMax - precinct.cbxMin + 1;\n            var height = precinct.cbyMax - precinct.cbyMin + 1;\n            inclusionTree = new InclusionTree(width, height, layerNumber);\n            zeroBitPlanesTree = new TagTree(width, height);\n            precinct.inclusionTree = inclusionTree;\n            precinct.zeroBitPlanesTree = zeroBitPlanesTree;\n          }\n\n          if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {\n            while (true) {\n              if (readBits(1)) {\n                var valueReady = !inclusionTree.nextLevel();\n                if (valueReady) {\n                  codeblock.included = true;\n                  codeblockIncluded = firstTimeInclusion = true;\n                  break;\n                }\n              } else {\n                inclusionTree.incrementValue(layerNumber);\n                break;\n              }\n            }\n          }\n        }\n        if (!codeblockIncluded)\n          continue;\n        if (firstTimeInclusion) {\n          zeroBitPlanesTree = precinct.zeroBitPlanesTree;\n          zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);\n          while (true) {\n            if (readBits(1)) {\n              var valueReady = !zeroBitPlanesTree.nextLevel();\n              if (valueReady)\n                break;\n            } else\n              zeroBitPlanesTree.incrementValue();\n          }\n          codeblock.zeroBitPlanes = zeroBitPlanesTree.value;\n        }\n        var codingpasses = readCodingpasses();\n        while (readBits(1))\n          codeblock.Lblock++;\n        var codingpassesLog2 = log2(codingpasses);\n        // rounding down log2\n        var bits = ((codingpasses < (1 << codingpassesLog2)) ?\n          codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;\n        var codedDataLength = readBits(bits);\n        queue.push({\n          codeblock: codeblock,\n          codingpasses: codingpasses,\n          dataLength: codedDataLength\n        });\n      }\n      alignToByte();\n      while (queue.length > 0) {\n        var packetItem = queue.shift();\n        var codeblock = packetItem.codeblock;\n        if (!('data' in codeblock))\n          codeblock.data = [];\n        codeblock.data.push({\n          data: data,\n          start: offset + position,\n          end: offset + position + packetItem.dataLength,\n          codingpasses: packetItem.codingpasses\n        });\n        position += packetItem.dataLength;\n      }\n    }\n    return position;\n  }\n  function copyCoefficients(coefficients, x0, y0, width, height,\n                            delta, mb, codeblocks, transformation,\n                            segmentationSymbolUsed) {\n    var r = 0.5; // formula (E-6)\n    for (var i = 0, ii = codeblocks.length; i < ii; ++i) {\n      var codeblock = codeblocks[i];\n      var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;\n      var blockHeight = codeblock.tby1_ - codeblock.tby0_;\n      if (blockWidth === 0 || blockHeight === 0)\n        continue;\n      if (!('data' in codeblock))\n        continue;\n\n      var bitModel, currentCodingpassType;\n      bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType,\n        codeblock.zeroBitPlanes);\n      currentCodingpassType = 2; // first bit plane starts from cleanup\n\n      // collect data\n      var data = codeblock.data, totalLength = 0, codingpasses = 0;\n      for (var q = 0, qq = data.length; q < qq; q++) {\n        var dataItem = data[q];\n        totalLength += dataItem.end - dataItem.start;\n        codingpasses += dataItem.codingpasses;\n      }\n      var encodedData = new Uint8Array(totalLength), k = 0;\n      for (var q = 0, qq = data.length; q < qq; q++) {\n        var dataItem = data[q];\n        var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);\n        encodedData.set(chunk, k);\n        k += chunk.length;\n      }\n      // decoding the item\n      var decoder = new ArithmeticDecoder(encodedData, 0, totalLength);\n      bitModel.setDecoder(decoder);\n\n      for (var q = 0; q < codingpasses; q++) {\n        switch (currentCodingpassType) {\n          case 0:\n            bitModel.runSignificancePropogationPass();\n            break;\n          case 1:\n            bitModel.runMagnitudeRefinementPass();\n            break;\n          case 2:\n            bitModel.runCleanupPass();\n            if (segmentationSymbolUsed)\n              bitModel.checkSegmentationSymbol();\n            break;\n        }\n        currentCodingpassType = (currentCodingpassType + 1) % 3;\n      }\n\n      var offset = (codeblock.tbx0_ - x0) + (codeblock.tby0_ - y0) * width;\n      var position = 0;\n      for (var j = 0; j < blockHeight; j++) {\n        for (var k = 0; k < blockWidth; k++) {\n          var n = (bitModel.coefficentsSign[position] ? -1 : 1) *\n            bitModel.coefficentsMagnitude[position];\n          var nb = bitModel.bitsDecoded[position], correction;\n          if (transformation === 0 || mb > nb) {\n            // use r only if transformation is irreversible or\n            // not all bitplanes were decoded for reversible transformation\n            n += n < 0 ? n - r : n > 0 ? n + r : 0;\n            correction = 1 << (mb - nb);\n          } else\n            correction = 1;\n          coefficients[offset++] = n * correction * delta;\n          position++;\n        }\n        offset += width - blockWidth;\n      }\n    }\n  }\n  function transformTile(context, tile, c) {\n    var component = tile.components[c];\n    var codingStyleParameters = component.codingStyleParameters;\n    var quantizationParameters = component.quantizationParameters;\n    var decompositionLevelsCount =\n      codingStyleParameters.decompositionLevelsCount;\n    var spqcds = quantizationParameters.SPqcds;\n    var scalarExpounded = quantizationParameters.scalarExpounded;\n    var guardBits = quantizationParameters.guardBits;\n    var transformation = codingStyleParameters.transformation;\n    var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;\n    var precision = context.components[c].precision;\n\n    var subbandCoefficients = [];\n    var k = 0, b = 0;\n    for (var i = 0; i <= decompositionLevelsCount; i++) {\n      var resolution = component.resolutions[i];\n\n      for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {\n        var mu, epsilon;\n        if (!scalarExpounded) {\n          // formula E-5\n          mu = spqcds[0].mu;\n          epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);\n        } else {\n          mu = spqcds[b].mu;\n          epsilon = spqcds[b].epsilon;\n        }\n\n        var subband = resolution.subbands[j];\n        var width = subband.tbx1 - subband.tbx0;\n        var height = subband.tby1 - subband.tby0;\n        var gainLog2 = SubbandsGainLog2[subband.type];\n\n        // calulate quantization coefficient (Section E.1.1.1)\n        var delta = Math.pow(2, (precision + gainLog2) - epsilon) *\n          (1 + mu / 2048);\n        var mb = (guardBits + epsilon - 1);\n\n        var coefficients = new Float32Array(width * height);\n        copyCoefficients(coefficients, subband.tbx0, subband.tby0,\n          width, height, delta, mb, subband.codeblocks, transformation,\n          segmentationSymbolUsed);\n\n        subbandCoefficients.push({\n          width: width,\n          height: height,\n          items: coefficients\n        });\n\n        b++;\n      }\n    }\n\n    var transformation = codingStyleParameters.transformation;\n    var transform = transformation === 0 ? new IrreversibleTransform() :\n      new ReversibleTransform();\n    var result = transform.calculate(subbandCoefficients,\n      component.tcx0, component.tcy0);\n    return {\n      left: component.tcx0,\n      top: component.tcy0,\n      width: result.width,\n      height: result.height,\n      items: result.items\n    };\n  }\n  function transformComponents(context) {\n    var siz = context.SIZ;\n    var components = context.components;\n    var componentsCount = siz.Csiz;\n    var resultImages = [];\n    for (var i = 0, ii = context.tiles.length; i < ii; i++) {\n      var tile = context.tiles[i];\n      var result = [];\n      for (var c = 0; c < componentsCount; c++) {\n        var image = transformTile(context, tile, c);\n        result.push(image);\n      }\n\n      // Section G.2.2 Inverse multi component transform\n      if (tile.codingStyleDefaultParameters.multipleComponentTransform) {\n        var y0items = result[0].items;\n        var y1items = result[1].items;\n        var y2items = result[2].items;\n        for (var j = 0, jj = y0items.length; j < jj; j++) {\n          var y0 = y0items[j], y1 = y1items[j], y2 = y2items[j];\n          var i1 = y0 - ((y2 + y1) >> 2);\n          y1items[j] = i1;\n          y0items[j] = y2 + i1;\n          y2items[j] = y1 + i1;\n        }\n      }\n\n      // Section G.1 DC level shifting to unsigned component values\n      for (var c = 0; c < componentsCount; c++) {\n        var component = components[c];\n        if (component.isSigned)\n          continue;\n\n        var offset = 1 << (component.precision - 1);\n        var tileImage = result[c];\n        var items = tileImage.items;\n        for (var j = 0, jj = items.length; j < jj; j++)\n          items[j] += offset;\n      }\n\n      // To simplify things: shift and clamp output to 8 bit unsigned\n      for (var c = 0; c < componentsCount; c++) {\n        var component = components[c];\n        var offset = component.isSigned ? 128 : 0;\n        var shift = component.precision - 8;\n        var tileImage = result[c];\n        var items = tileImage.items;\n        var data = new Uint8Array(items.length);\n        for (var j = 0, jj = items.length; j < jj; j++) {\n          var value = (items[j] >> shift) + offset;\n          data[j] = value < 0 ? 0 : value > 255 ? 255 : value;\n        }\n        result[c].items = data;\n      }\n\n      resultImages.push(result);\n    }\n    return resultImages;\n  }\n  function initializeTile(context, tileIndex) {\n    var siz = context.SIZ;\n    var componentsCount = siz.Csiz;\n    var tile = context.tiles[tileIndex];\n    var resultTiles = [];\n    for (var c = 0; c < componentsCount; c++) {\n      var component = tile.components[c];\n      var qcdOrQcc = c in context.currentTile.QCC ?\n        context.currentTile.QCC[c] : context.currentTile.QCD;\n      component.quantizationParameters = qcdOrQcc;\n      var codOrCoc = c in context.currentTile.COC ?\n        context.currentTile.COC[c] : context.currentTile.COD;\n      component.codingStyleParameters = codOrCoc;\n    }\n    tile.codingStyleDefaultParameters = context.currentTile.COD;\n  }\n\n  // Section B.10.2 Tag trees\n  var TagTree = (function TagTreeClosure() {\n    function TagTree(width, height) {\n      var levelsLength = log2(Math.max(width, height)) + 1;\n      this.levels = [];\n      for (var i = 0; i < levelsLength; i++) {\n        var level = {\n          width: width,\n          height: height,\n          items: []\n        };\n        this.levels.push(level);\n        width = Math.ceil(width / 2);\n        height = Math.ceil(height / 2);\n      }\n    }\n    TagTree.prototype = {\n      reset: function TagTree_reset(i, j) {\n        var currentLevel = 0, value = 0;\n        while (currentLevel < this.levels.length) {\n          var level = this.levels[currentLevel];\n          var index = i + j * level.width;\n          if (index in level.items) {\n            value = level.items[index];\n            break;\n          }\n          level.index = index;\n          i >>= 1;\n          j >>= 1;\n          currentLevel++;\n        }\n        currentLevel--;\n        var level = this.levels[currentLevel];\n        level.items[level.index] = value;\n        this.currentLevel = currentLevel;\n        delete this.value;\n      },\n      incrementValue: function TagTree_incrementValue() {\n        var level = this.levels[this.currentLevel];\n        level.items[level.index]++;\n      },\n      nextLevel: function TagTree_nextLevel() {\n        var currentLevel = this.currentLevel;\n        var level = this.levels[currentLevel];\n        var value = level.items[level.index];\n        currentLevel--;\n        if (currentLevel < 0) {\n          this.value = value;\n          return false;\n        }\n\n        this.currentLevel = currentLevel;\n        var level = this.levels[currentLevel];\n        level.items[level.index] = value;\n        return true;\n      }\n    };\n    return TagTree;\n  })();\n\n  var InclusionTree = (function InclusionTreeClosure() {\n    function InclusionTree(width, height,  defaultValue) {\n      var levelsLength = log2(Math.max(width, height)) + 1;\n      this.levels = [];\n      for (var i = 0; i < levelsLength; i++) {\n        var items = new Uint8Array(width * height);\n        for (var j = 0, jj = items.length; j < jj; j++)\n          items[j] = defaultValue;\n\n        var level = {\n          width: width,\n          height: height,\n          items: items\n        };\n        this.levels.push(level);\n\n        width = Math.ceil(width / 2);\n        height = Math.ceil(height / 2);\n      }\n    }\n    InclusionTree.prototype = {\n      reset: function InclusionTree_reset(i, j, stopValue) {\n        var currentLevel = 0;\n        while (currentLevel < this.levels.length) {\n          var level = this.levels[currentLevel];\n          var index = i + j * level.width;\n          level.index = index;\n          var value = level.items[index];\n\n          if (value == 0xFF)\n            break;\n\n          if (value > stopValue) {\n            this.currentLevel = currentLevel;\n            // already know about this one, propagating the value to top levels\n            this.propagateValues();\n            return false;\n          }\n\n          i >>= 1;\n          j >>= 1;\n          currentLevel++;\n        }\n        this.currentLevel = currentLevel - 1;\n        return true;\n      },\n      incrementValue: function InclusionTree_incrementValue(stopValue) {\n        var level = this.levels[this.currentLevel];\n        level.items[level.index] = stopValue + 1;\n        this.propagateValues();\n      },\n      propagateValues: function InclusionTree_propagateValues() {\n        var levelIndex = this.currentLevel;\n        var level = this.levels[levelIndex];\n        var currentValue = level.items[level.index];\n        while (--levelIndex >= 0) {\n          var level = this.levels[levelIndex];\n          level.items[level.index] = currentValue;\n        }\n      },\n      nextLevel: function InclusionTree_nextLevel() {\n        var currentLevel = this.currentLevel;\n        var level = this.levels[currentLevel];\n        var value = level.items[level.index];\n        level.items[level.index] = 0xFF;\n        currentLevel--;\n        if (currentLevel < 0)\n          return false;\n\n        this.currentLevel = currentLevel;\n        var level = this.levels[currentLevel];\n        level.items[level.index] = value;\n        return true;\n      }\n    };\n    return InclusionTree;\n  })();\n\n  // Implements C.3. Arithmetic decoding procedures\n  var ArithmeticDecoder = (function ArithmeticDecoderClosure() {\n    var QeTable = [\n      {qe: 0x5601, nmps: 1, nlps: 1, switchFlag: 1},\n      {qe: 0x3401, nmps: 2, nlps: 6, switchFlag: 0},\n      {qe: 0x1801, nmps: 3, nlps: 9, switchFlag: 0},\n      {qe: 0x0AC1, nmps: 4, nlps: 12, switchFlag: 0},\n      {qe: 0x0521, nmps: 5, nlps: 29, switchFlag: 0},\n      {qe: 0x0221, nmps: 38, nlps: 33, switchFlag: 0},\n      {qe: 0x5601, nmps: 7, nlps: 6, switchFlag: 1},\n      {qe: 0x5401, nmps: 8, nlps: 14, switchFlag: 0},\n      {qe: 0x4801, nmps: 9, nlps: 14, switchFlag: 0},\n      {qe: 0x3801, nmps: 10, nlps: 14, switchFlag: 0},\n      {qe: 0x3001, nmps: 11, nlps: 17, switchFlag: 0},\n      {qe: 0x2401, nmps: 12, nlps: 18, switchFlag: 0},\n      {qe: 0x1C01, nmps: 13, nlps: 20, switchFlag: 0},\n      {qe: 0x1601, nmps: 29, nlps: 21, switchFlag: 0},\n      {qe: 0x5601, nmps: 15, nlps: 14, switchFlag: 1},\n      {qe: 0x5401, nmps: 16, nlps: 14, switchFlag: 0},\n      {qe: 0x5101, nmps: 17, nlps: 15, switchFlag: 0},\n      {qe: 0x4801, nmps: 18, nlps: 16, switchFlag: 0},\n      {qe: 0x3801, nmps: 19, nlps: 17, switchFlag: 0},\n      {qe: 0x3401, nmps: 20, nlps: 18, switchFlag: 0},\n      {qe: 0x3001, nmps: 21, nlps: 19, switchFlag: 0},\n      {qe: 0x2801, nmps: 22, nlps: 19, switchFlag: 0},\n      {qe: 0x2401, nmps: 23, nlps: 20, switchFlag: 0},\n      {qe: 0x2201, nmps: 24, nlps: 21, switchFlag: 0},\n      {qe: 0x1C01, nmps: 25, nlps: 22, switchFlag: 0},\n      {qe: 0x1801, nmps: 26, nlps: 23, switchFlag: 0},\n      {qe: 0x1601, nmps: 27, nlps: 24, switchFlag: 0},\n      {qe: 0x1401, nmps: 28, nlps: 25, switchFlag: 0},\n      {qe: 0x1201, nmps: 29, nlps: 26, switchFlag: 0},\n      {qe: 0x1101, nmps: 30, nlps: 27, switchFlag: 0},\n      {qe: 0x0AC1, nmps: 31, nlps: 28, switchFlag: 0},\n      {qe: 0x09C1, nmps: 32, nlps: 29, switchFlag: 0},\n      {qe: 0x08A1, nmps: 33, nlps: 30, switchFlag: 0},\n      {qe: 0x0521, nmps: 34, nlps: 31, switchFlag: 0},\n      {qe: 0x0441, nmps: 35, nlps: 32, switchFlag: 0},\n      {qe: 0x02A1, nmps: 36, nlps: 33, switchFlag: 0},\n      {qe: 0x0221, nmps: 37, nlps: 34, switchFlag: 0},\n      {qe: 0x0141, nmps: 38, nlps: 35, switchFlag: 0},\n      {qe: 0x0111, nmps: 39, nlps: 36, switchFlag: 0},\n      {qe: 0x0085, nmps: 40, nlps: 37, switchFlag: 0},\n      {qe: 0x0049, nmps: 41, nlps: 38, switchFlag: 0},\n      {qe: 0x0025, nmps: 42, nlps: 39, switchFlag: 0},\n      {qe: 0x0015, nmps: 43, nlps: 40, switchFlag: 0},\n      {qe: 0x0009, nmps: 44, nlps: 41, switchFlag: 0},\n      {qe: 0x0005, nmps: 45, nlps: 42, switchFlag: 0},\n      {qe: 0x0001, nmps: 45, nlps: 43, switchFlag: 0},\n      {qe: 0x5601, nmps: 46, nlps: 46, switchFlag: 0}\n    ];\n\n    function ArithmeticDecoder(data, start, end) {\n      this.data = data;\n      this.bp = start;\n      this.dataEnd = end;\n\n      this.chigh = data[start];\n      this.clow = 0;\n\n      this.byteIn();\n\n      this.chigh = ((this.chigh << 7) & 0xFFFF) | ((this.clow >> 9) & 0x7F);\n      this.clow = (this.clow << 7) & 0xFFFF;\n      this.ct -= 7;\n      this.a = 0x8000;\n    }\n\n    ArithmeticDecoder.prototype = {\n      byteIn: function ArithmeticDecoder_byteIn() {\n        var data = this.data;\n        var bp = this.bp;\n        if (data[bp] == 0xFF) {\n          var b1 = data[bp + 1];\n          if (b1 > 0x8F) {\n            this.clow += 0xFF00;\n            this.ct = 8;\n          } else {\n            bp++;\n            this.clow += (data[bp] << 9);\n            this.ct = 7;\n            this.bp = bp;\n          }\n        } else {\n          bp++;\n          this.clow += bp < this.dataEnd ? (data[bp] << 8) : 0xFF00;\n          this.ct = 8;\n          this.bp = bp;\n        }\n        if (this.clow > 0xFFFF) {\n          this.chigh += (this.clow >> 16);\n          this.clow &= 0xFFFF;\n        }\n      },\n      readBit: function ArithmeticDecoder_readBit(cx) {\n        var qeIcx = QeTable[cx.index].qe;\n        this.a -= qeIcx;\n\n        if (this.chigh < qeIcx) {\n          var d = this.exchangeLps(cx);\n          this.renormD();\n          return d;\n        } else {\n          this.chigh -= qeIcx;\n          if ((this.a & 0x8000) === 0) {\n            var d = this.exchangeMps(cx);\n            this.renormD();\n            return d;\n          } else {\n            return cx.mps;\n          }\n        }\n      },\n      renormD: function ArithmeticDecoder_renormD() {\n        do {\n          if (this.ct === 0)\n            this.byteIn();\n\n          this.a <<= 1;\n          this.chigh = ((this.chigh << 1) & 0xFFFF) | ((this.clow >> 15) & 1);\n          this.clow = (this.clow << 1) & 0xFFFF;\n          this.ct--;\n        } while ((this.a & 0x8000) === 0);\n      },\n      exchangeMps: function ArithmeticDecoder_exchangeMps(cx) {\n        var d;\n        var qeTableIcx = QeTable[cx.index];\n        if (this.a < qeTableIcx.qe) {\n          d = 1 - cx.mps;\n\n          if (qeTableIcx.switchFlag == 1) {\n            cx.mps = 1 - cx.mps;\n          }\n          cx.index = qeTableIcx.nlps;\n        } else {\n          d = cx.mps;\n          cx.index = qeTableIcx.nmps;\n        }\n        return d;\n      },\n      exchangeLps: function ArithmeticDecoder_exchangeLps(cx) {\n        var d;\n        var qeTableIcx = QeTable[cx.index];\n        if (this.a < qeTableIcx.qe) {\n          this.a = qeTableIcx.qe;\n          d = cx.mps;\n          cx.index = qeTableIcx.nmps;\n        } else {\n          this.a = qeTableIcx.qe;\n          d = 1 - cx.mps;\n\n          if (qeTableIcx.switchFlag == 1) {\n            cx.mps = 1 - cx.mps;\n          }\n          cx.index = qeTableIcx.nlps;\n        }\n        return d;\n      }\n    };\n\n    return ArithmeticDecoder;\n  })();\n\n  // Section D. Coefficient bit modeling\n  var BitModel = (function BitModelClosure() {\n    // Table D-1\n    // The index is binary presentation: 0dddvvhh, ddd - sum of Di (0..4),\n    // vv - sum of Vi (0..2), and hh - sum of Hi (0..2)\n    var LLAndLHContextsLabel = new Uint8Array([\n      0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4,\n      7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6,\n      8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8\n    ]);\n    var HLContextLabel = new Uint8Array([\n      0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8,\n      8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3,\n      4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8\n    ]);\n    var HHContextLabel = new Uint8Array([\n      0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5,\n      5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8,\n      8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8\n    ]);\n\n    // Table D-2\n    function calcSignContribution(significance0, sign0, significance1, sign1) {\n      if (significance1) {\n        if (!sign1)\n          return significance0 ? (!sign0 ? 1 : 0) : 1;\n        else\n          return significance0 ? (!sign0 ? 0 : -1) : -1;\n      } else\n        return significance0 ? (!sign0 ? 1 : -1) : 0;\n    }\n    // Table D-3\n    var SignContextLabels = [\n      {contextLabel: 13, xorBit: 0},\n      {contextLabel: 12, xorBit: 0},\n      {contextLabel: 11, xorBit: 0},\n      {contextLabel: 10, xorBit: 0},\n      {contextLabel: 9, xorBit: 0},\n      {contextLabel: 10, xorBit: 1},\n      {contextLabel: 11, xorBit: 1},\n      {contextLabel: 12, xorBit: 1},\n      {contextLabel: 13, xorBit: 1}\n    ];\n\n    function BitModel(width, height, subband, zeroBitPlanes) {\n      this.width = width;\n      this.height = height;\n\n      this.contextLabelTable = subband == 'HH' ? HHContextLabel :\n        subband == 'HL' ? HLContextLabel : LLAndLHContextsLabel;\n\n      var coefficientCount = width * height;\n\n      // coefficients outside the encoding region treated as insignificant\n      // add border state cells for significanceState\n      this.neighborsSignificance = new Uint8Array(coefficientCount);\n      this.coefficentsSign = new Uint8Array(coefficientCount);\n      this.coefficentsMagnitude = new Uint32Array(coefficientCount);\n      this.processingFlags = new Uint8Array(coefficientCount);\n\n      var bitsDecoded = new Uint8Array(this.width * this.height);\n      for (var i = 0, ii = bitsDecoded.length; i < ii; i++)\n        bitsDecoded[i] = zeroBitPlanes;\n      this.bitsDecoded = bitsDecoded;\n\n      this.reset();\n    }\n\n    BitModel.prototype = {\n      setDecoder: function BitModel_setDecoder(decoder) {\n        this.decoder = decoder;\n      },\n      reset: function BitModel_reset() {\n        this.uniformContext = {index: 46, mps: 0};\n        this.runLengthContext = {index: 3, mps: 0};\n        this.contexts = [];\n        this.contexts.push({index: 4, mps: 0});\n        for (var i = 1; i <= 16; i++)\n          this.contexts.push({index: 0, mps: 0});\n      },\n      setNeighborsSignificance:\n        function BitModel_setNeighborsSignificance(row, column) {\n        var neighborsSignificance = this.neighborsSignificance;\n        var width = this.width, height = this.height;\n        var index = row * width + column;\n        if (row > 0) {\n          if (column > 0)\n            neighborsSignificance[index - width - 1] += 0x10;\n          if (column + 1 < width)\n            neighborsSignificance[index - width + 1] += 0x10;\n          neighborsSignificance[index - width] += 0x04;\n        }\n        if (row + 1 < height) {\n          if (column > 0)\n            neighborsSignificance[index + width - 1] += 0x10;\n          if (column + 1 < width)\n            neighborsSignificance[index + width + 1] += 0x10;\n          neighborsSignificance[index + width] += 0x04;\n        }\n        if (column > 0)\n          neighborsSignificance[index - 1] += 0x01;\n        if (column + 1 < width)\n          neighborsSignificance[index + 1] += 0x01;\n        neighborsSignificance[index] |= 0x80;\n      },\n      runSignificancePropogationPass:\n        function BitModel_runSignificancePropogationPass() {\n        var decoder = this.decoder;\n        var width = this.width, height = this.height;\n        var coefficentsMagnitude = this.coefficentsMagnitude;\n        var coefficentsSign = this.coefficentsSign;\n        var contextLabels = this.contextLabels;\n        var neighborsSignificance = this.neighborsSignificance;\n        var processingFlags = this.processingFlags;\n        var contexts = this.contexts;\n        var labels = this.contextLabelTable;\n        var bitsDecoded = this.bitsDecoded;\n        // clear processed flag\n        var processedInverseMask = ~1;\n        var processedMask = 1;\n        var firstMagnitudeBitMask = 2;\n        for (var q = 0, qq = width * height; q < qq; q++)\n          processingFlags[q] &= processedInverseMask;\n\n        for (var i0 = 0; i0 < height; i0 += 4) {\n          for (var j = 0; j < width; j++) {\n            var index = i0 * width + j;\n            for (var i1 = 0; i1 < 4; i1++, index += width) {\n              var i = i0 + i1;\n              if (i >= height)\n                break;\n\n              if (coefficentsMagnitude[index] || !neighborsSignificance[index])\n                continue;\n\n              var contextLabel = labels[neighborsSignificance[index]];\n              var cx = contexts[contextLabel];\n              var decision = decoder.readBit(cx);\n              if (decision) {\n                var sign = this.decodeSignBit(i, j);\n                coefficentsSign[index] = sign;\n                coefficentsMagnitude[index] = 1;\n                this.setNeighborsSignificance(i, j);\n                processingFlags[index] |= firstMagnitudeBitMask;\n              }\n              bitsDecoded[index]++;\n              processingFlags[index] |= processedMask;\n            }\n          }\n        }\n      },\n      decodeSignBit: function BitModel_decodeSignBit(row, column) {\n        var width = this.width, height = this.height;\n        var index = row * width + column;\n        var coefficentsMagnitude = this.coefficentsMagnitude;\n        var coefficentsSign = this.coefficentsSign;\n        var horizontalContribution = calcSignContribution(\n          column > 0 && coefficentsMagnitude[index - 1],\n          coefficentsSign[index - 1],\n          column + 1 < width && coefficentsMagnitude[index + 1],\n          coefficentsSign[index + 1]);\n        var verticalContribution = calcSignContribution(\n          row > 0 && coefficentsMagnitude[index - width],\n          coefficentsSign[index - width],\n          row + 1 < height && coefficentsMagnitude[index + width],\n          coefficentsSign[index + width]);\n\n        var contextLabelAndXor = SignContextLabels[\n          3 * (1 - horizontalContribution) + (1 - verticalContribution)];\n        var contextLabel = contextLabelAndXor.contextLabel;\n        var cx = this.contexts[contextLabel];\n        var decoded = this.decoder.readBit(cx);\n        return decoded ^ contextLabelAndXor.xorBit;\n      },\n      runMagnitudeRefinementPass:\n        function BitModel_runMagnitudeRefinementPass() {\n        var decoder = this.decoder;\n        var width = this.width, height = this.height;\n        var coefficentsMagnitude = this.coefficentsMagnitude;\n        var neighborsSignificance = this.neighborsSignificance;\n        var contexts = this.contexts;\n        var bitsDecoded = this.bitsDecoded;\n        var processingFlags = this.processingFlags;\n        var processedMask = 1;\n        var firstMagnitudeBitMask = 2;\n        for (var i0 = 0; i0 < height; i0 += 4) {\n          for (var j = 0; j < width; j++) {\n            for (var i1 = 0; i1 < 4; i1++) {\n              var i = i0 + i1;\n              if (i >= height)\n                break;\n              var index = i * width + j;\n\n              // significant but not those that have just become\n              if (!coefficentsMagnitude[index] ||\n                (processingFlags[index] & processedMask) !== 0)\n                continue;\n\n              var contextLabel = 16;\n              if ((processingFlags[index] &\n                firstMagnitudeBitMask) !== 0) {\n                processingFlags[i * width + j] ^= firstMagnitudeBitMask;\n                // first refinement\n                var significance = neighborsSignificance[index];\n                var sumOfSignificance = (significance & 3) +\n                  ((significance >> 2) & 3) + ((significance >> 4) & 7);\n                contextLabel = sumOfSignificance >= 1 ? 15 : 14;\n              }\n\n              var cx = contexts[contextLabel];\n              var bit = decoder.readBit(cx);\n              coefficentsMagnitude[index] =\n                (coefficentsMagnitude[index] << 1) | bit;\n              bitsDecoded[index]++;\n              processingFlags[index] |= processedMask;\n            }\n          }\n        }\n      },\n      runCleanupPass: function BitModel_runCleanupPass() {\n        var decoder = this.decoder;\n        var width = this.width, height = this.height;\n        var neighborsSignificance = this.neighborsSignificance;\n        var significanceState = this.significanceState;\n        var coefficentsMagnitude = this.coefficentsMagnitude;\n        var coefficentsSign = this.coefficentsSign;\n        var contexts = this.contexts;\n        var labels = this.contextLabelTable;\n        var bitsDecoded = this.bitsDecoded;\n        var processingFlags = this.processingFlags;\n        var processedMask = 1;\n        var firstMagnitudeBitMask = 2;\n        var oneRowDown = width;\n        var twoRowsDown = width * 2;\n        var threeRowsDown = width * 3;\n        for (var i0 = 0; i0 < height; i0 += 4) {\n          for (var j = 0; j < width; j++) {\n            var index0 = i0 * width + j;\n            // using the property: labels[neighborsSignificance[index]] == 0\n            // when neighborsSignificance[index] == 0\n            var allEmpty = i0 + 3 < height &&\n              processingFlags[index0] === 0 &&\n              processingFlags[index0 + oneRowDown] === 0 &&\n              processingFlags[index0 + twoRowsDown] === 0 &&\n              processingFlags[index0 + threeRowsDown] === 0 &&\n              neighborsSignificance[index0] === 0 &&\n              neighborsSignificance[index0 + oneRowDown] === 0 &&\n              neighborsSignificance[index0 + twoRowsDown] === 0 &&\n              neighborsSignificance[index0 + threeRowsDown] === 0;\n            var i1 = 0, index = index0;\n            var cx, i;\n            if (allEmpty) {\n              cx = this.runLengthContext;\n              var hasSignificantCoefficent = decoder.readBit(cx);\n              if (!hasSignificantCoefficent) {\n                bitsDecoded[index0]++;\n                bitsDecoded[index0 + oneRowDown]++;\n                bitsDecoded[index0 + twoRowsDown]++;\n                bitsDecoded[index0 + threeRowsDown]++;\n                continue; // next column\n              }\n              cx = this.uniformContext;\n              i1 = (decoder.readBit(cx) << 1) | decoder.readBit(cx);\n              i = i0 + i1;\n              index += i1 * width;\n\n              var sign = this.decodeSignBit(i, j);\n              coefficentsSign[index] = sign;\n              coefficentsMagnitude[index] = 1;\n              this.setNeighborsSignificance(i, j);\n              processingFlags[index] |= firstMagnitudeBitMask;\n\n              index = index0;\n              for (var i2 = i0; i2 <= i; i2++, index += width)\n                bitsDecoded[index]++;\n\n              i1++;\n            }\n            for (; i1 < 4; i1++, index += width) {\n              i = i0 + i1;\n              if (i >= height)\n                break;\n\n              if (coefficentsMagnitude[index] ||\n                (processingFlags[index] & processedMask) !== 0)\n                continue;\n\n              var contextLabel = labels[neighborsSignificance[index]];\n              cx = contexts[contextLabel];\n              var decision = decoder.readBit(cx);\n              if (decision == 1) {\n                var sign = this.decodeSignBit(i, j);\n                coefficentsSign[index] = sign;\n                coefficentsMagnitude[index] = 1;\n                this.setNeighborsSignificance(i, j);\n                processingFlags[index] |= firstMagnitudeBitMask;\n              }\n              bitsDecoded[index]++;\n            }\n          }\n        }\n      },\n      checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {\n        var decoder = this.decoder;\n        var cx = this.uniformContext;\n        var symbol = (decoder.readBit(cx) << 3) | (decoder.readBit(cx) << 2) |\n                     (decoder.readBit(cx) << 1) | decoder.readBit(cx);\n        if (symbol != 0xA)\n          throw 'Invalid segmentation symbol';\n      }\n    };\n\n    return BitModel;\n  })();\n\n  // Section F, Discrete wavelet transofrmation\n  var Transform = (function TransformClosure() {\n    function Transform() {\n    }\n    Transform.prototype.calculate =\n      function transformCalculate(subbands, u0, v0) {\n      var ll = subbands[0];\n      for (var i = 1, ii = subbands.length, j = 1; i < ii; i += 3, j++) {\n        ll = this.iterate(ll, subbands[i], subbands[i + 1],\n                          subbands[i + 2], u0, v0);\n      }\n      return ll;\n    };\n    Transform.prototype.expand = function expand(buffer, bufferPadding, step) {\n        // Section F.3.7 extending... using max extension of 4\n        var i1 = bufferPadding - 1, j1 = bufferPadding + 1;\n        var i2 = bufferPadding + step - 2, j2 = bufferPadding + step;\n        buffer[i1--] = buffer[j1++];\n        buffer[j2++] = buffer[i2--];\n        buffer[i1--] = buffer[j1++];\n        buffer[j2++] = buffer[i2--];\n        buffer[i1--] = buffer[j1++];\n        buffer[j2++] = buffer[i2--];\n        buffer[i1--] = buffer[j1++];\n        buffer[j2++] = buffer[i2--];\n    };\n    Transform.prototype.iterate = function Transform_iterate(ll, hl, lh, hh,\n                                                            u0, v0) {\n      var llWidth = ll.width, llHeight = ll.height, llItems = ll.items;\n      var hlWidth = hl.width, hlHeight = hl.height, hlItems = hl.items;\n      var lhWidth = lh.width, lhHeight = lh.height, lhItems = lh.items;\n      var hhWidth = hh.width, hhHeight = hh.height, hhItems = hh.items;\n\n      // Section F.3.3 interleave\n      var width = llWidth + hlWidth;\n      var height = llHeight + lhHeight;\n      var items = new Float32Array(width * height);\n      for (var i = 0, ii = llHeight; i < ii; i++) {\n        var k = i * llWidth, l = i * 2 * width;\n        for (var j = 0, jj = llWidth; j < jj; j++, k++, l += 2)\n          items[l] = llItems[k];\n      }\n      for (var i = 0, ii = hlHeight; i < ii; i++) {\n        var k = i * hlWidth, l = i * 2 * width + 1;\n        for (var j = 0, jj = hlWidth; j < jj; j++, k++, l += 2)\n          items[l] = hlItems[k];\n      }\n      for (var i = 0, ii = lhHeight; i < ii; i++) {\n        var k = i * lhWidth, l = (i * 2 + 1) * width;\n        for (var j = 0, jj = lhWidth; j < jj; j++, k++, l += 2)\n          items[l] = lhItems[k];\n      }\n      for (var i = 0, ii = hhHeight; i < ii; i++) {\n        var k = i * hhWidth, l = (i * 2 + 1) * width + 1;\n        for (var j = 0, jj = hhWidth; j < jj; j++, k++, l += 2)\n          items[l] = hhItems[k];\n      }\n\n      var bufferPadding = 4;\n      var bufferLength = new Float32Array(Math.max(width, height) +\n        2 * bufferPadding);\n      var buffer = new Float32Array(bufferLength);\n      var bufferOut = new Float32Array(bufferLength);\n\n      // Section F.3.4 HOR_SR\n      for (var v = 0; v < height; v++) {\n        if (width == 1) {\n          // if width = 1, when u0 even keep items as is, when odd divide by 2\n          if ((u0 % 1) !== 0) {\n            items[v * width] /= 2;\n          }\n          continue;\n        }\n\n        var k = v * width;\n        var l = bufferPadding;\n        for (var u = 0; u < width; u++, k++, l++)\n          buffer[l] = items[k];\n\n        this.expand(buffer, bufferPadding, width);\n        this.filter(buffer, bufferPadding, width, u0, bufferOut);\n\n        k = v * width;\n        l = bufferPadding;\n        for (var u = 0; u < width; u++, k++, l++)\n          items[k] = bufferOut[l];\n      }\n\n      // Section F.3.5 VER_SR\n      for (var u = 0; u < width; u++) {\n        if (height == 1) {\n          // if height = 1, when v0 even keep items as is, when odd divide by 2\n          if ((v0 % 1) !== 0) {\n            items[u] /= 2;\n          }\n          continue;\n        }\n\n        var k = u;\n        var l = bufferPadding;\n        for (var v = 0; v < height; v++, k += width, l++)\n          buffer[l] = items[k];\n\n        this.expand(buffer, bufferPadding, height);\n        this.filter(buffer, bufferPadding, height, v0, bufferOut);\n\n        k = u;\n        l = bufferPadding;\n        for (var v = 0; v < height; v++, k += width, l++)\n          items[k] = bufferOut[l];\n      }\n      return {\n        width: width,\n        height: height,\n        items: items\n      };\n    };\n    return Transform;\n  })();\n\n  // Section 3.8.2 Irreversible 9-7 filter\n  var IrreversibleTransform = (function IrreversibleTransformClosure() {\n    function IrreversibleTransform() {\n      Transform.call(this);\n    }\n\n    IrreversibleTransform.prototype = Object.create(Transform.prototype);\n    IrreversibleTransform.prototype.filter =\n      function irreversibleTransformFilter(y, offset, length, i0, x) {\n      var i0_ = Math.floor(i0 / 2);\n      var i1_ = Math.floor((i0 + length) / 2);\n      var offset_ = offset - (i0 % 1);\n\n      var alpha = -1.586134342059924;\n      var beta = -0.052980118572961;\n      var gamma = 0.882911075530934;\n      var delta = 0.443506852043971;\n      var K = 1.230174104914001;\n      var K_ = 1 / K;\n\n      // step 1\n      var j = offset_ - 2;\n      for (var n = i0_ - 1, nn = i1_ + 2; n < nn; n++, j += 2)\n        x[j] = K * y[j];\n\n      // step 2\n      var j = offset_ - 3;\n      for (var n = i0_ - 2, nn = i1_ + 2; n < nn; n++, j += 2)\n        x[j] = K_ * y[j];\n\n      // step 3\n      var j = offset_ - 2;\n      for (var n = i0_ - 1, nn = i1_ + 2; n < nn; n++, j += 2)\n        x[j] -= delta * (x[j - 1] + x[j + 1]);\n\n      // step 4\n      var j = offset_ - 1;\n      for (var n = i0_ - 1, nn = i1_ + 1; n < nn; n++, j += 2)\n        x[j] -= gamma * (x[j - 1] + x[j + 1]);\n\n      // step 5\n      var j = offset_;\n      for (var n = i0_, nn = i1_ + 1; n < nn; n++, j += 2)\n        x[j] -= beta * (x[j - 1] + x[j + 1]);\n\n      // step 6\n      var j = offset_ + 1;\n      for (var n = i0_, nn = i1_; n < nn; n++, j += 2)\n        x[j] -= alpha * (x[j - 1] + x[j + 1]);\n    };\n\n    return IrreversibleTransform;\n  })();\n\n  // Section 3.8.1 Reversible 5-3 filter\n  var ReversibleTransform = (function ReversibleTransformClosure() {\n    function ReversibleTransform() {\n      Transform.call(this);\n    }\n\n    ReversibleTransform.prototype = Object.create(Transform.prototype);\n    ReversibleTransform.prototype.filter =\n      function reversibleTransformFilter(y, offset, length, i0, x) {\n      var i0_ = Math.floor(i0 / 2);\n      var i1_ = Math.floor((i0 + length) / 2);\n      var offset_ = offset - (i0 % 1);\n\n      for (var n = i0_, nn = i1_ + 1, j = offset_; n < nn; n++, j += 2)\n        x[j] = y[j] - Math.floor((y[j - 1] + y[j + 1] + 2) / 4);\n\n      for (var n = i0_, nn = i1_, j = offset_ + 1; n < nn; n++, j += 2)\n        x[j] = y[j] + Math.floor((x[j - 1] + x[j + 1]) / 2);\n    };\n\n    return ReversibleTransform;\n  })();\n\n\n  })();\n\n  /**\n   * For JPEG 2000's we use a library to decode these images and\n   * the stream behaves like all the other DecodeStreams.\n   */\n\n    var JpxStream = DecodeStream.inherit({\n        klassName : \"JpxStream\",\n\n        init : function(bytes, dict) {\n          this.dict = dict;\n          this.bytes = bytes;\n\n            this.overrided();          \n        },\n      ensureBuffer : function(req) {\n          if (this.bufferLength)\n              return;\n\n          var jpxImage = new JpxImage();\n          jpxImage.parse(this.bytes);\n\n          var width = jpxImage.width;\n          var height = jpxImage.height;\n          var componentsCount = jpxImage.componentsCount;\n          if (componentsCount != 1 && componentsCount != 3 && componentsCount != 4)\n              error('JPX with ' + componentsCount + ' components is not supported');\n\n          var data = new Uint8Array(width * height * componentsCount);\n\n          for (var k = 0, kk = jpxImage.tiles.length; k < kk; k++) {\n              var tileCompoments = jpxImage.tiles[k];\n              var tileWidth = tileCompoments[0].width;\n              var tileHeight = tileCompoments[0].height;\n              var tileLeft = tileCompoments[0].left;\n              var tileTop = tileCompoments[0].top;\n\n              var dataPosition, sourcePosition, data0, data1, data2, data3, rowFeed;\n              switch (componentsCount) {\n                  case 1:\n                      data0 = tileCompoments[0].items;\n\n                      dataPosition = width * tileTop + tileLeft;\n                      rowFeed = width - tileWidth;\n                      sourcePosition = 0;\n                      for (var j = 0; j < tileHeight; j++) {\n                          for (var i = 0; i < tileWidth; i++)\n                              data[dataPosition++] = data0[sourcePosition++];\n                          dataPosition += rowFeed;\n                      }\n                      break;\n                  case 3:\n                      data0 = tileCompoments[0].items;\n                      data1 = tileCompoments[1].items;\n                      data2 = tileCompoments[2].items;\n\n                      dataPosition = (width * tileTop + tileLeft) * 3;\n                      rowFeed = (width - tileWidth) * 3;\n                      sourcePosition = 0;\n                      for (var j = 0; j < tileHeight; j++) {\n                          for (var i = 0; i < tileWidth; i++) {\n                              data[dataPosition++] = data0[sourcePosition];\n                              data[dataPosition++] = data1[sourcePosition];\n                              data[dataPosition++] = data2[sourcePosition];\n                              sourcePosition++;\n                          }\n                          dataPosition += rowFeed;\n                      }\n                      break;\n                  case 4:\n                      data0 = tileCompoments[0].items;\n                      data1 = tileCompoments[1].items;\n                      data2 = tileCompoments[2].items;\n                      data3 = tileCompoments[3].items;\n\n                      dataPosition = (width * tileTop + tileLeft) * 4;\n                      rowFeed = (width - tileWidth) * 4;\n                      sourcePosition = 0;\n                      for (var j = 0; j < tileHeight; j++) {\n                          for (var i = 0; i < tileWidth; i++) {\n                              data[dataPosition++] = data0[sourcePosition];\n                              data[dataPosition++] = data1[sourcePosition];\n                              data[dataPosition++] = data2[sourcePosition];\n                              data[dataPosition++] = data3[sourcePosition];\n                              sourcePosition++;\n                          }\n                          dataPosition += rowFeed;\n                      }\n                      break;\n              }\n          }\n\n          this.buffer = data;\n          this.bufferLength = data.length;\n      },\n\n      getChar : function JpxStream_getChar() {\n          error('internal error: getChar is not valid on JpxStream');\n      }\n    });\n\n  return codec.jpx = {\n    \"JpxImage\" :JpxImage,\n    \"JpxStream\" : JpxStream\n  };\n  \n});\n"]}