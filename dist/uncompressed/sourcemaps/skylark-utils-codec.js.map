{"version":3,"sources":["skylark-utils-codec.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-utils-codec.js","sourcesContent":["define('skylark-utils-codec/codec',[\r\n    \"skylark-langx/skylark\",\r\n    \"skylark-langx/langx\"\r\n], function(skylark, langx) {\r\n\tvar codec = skylark.codec = {\r\n\r\n\t};\r\n\r\n\treturn codec;\r\n});\ndefine('skylark-utils-codec/base64',[\r\n    \"skylark-langx/langx\",\r\n    \"./codec\"\r\n], function(langx,codec) {\r\n\r\n    var base64 = function() {\r\n        return base64;\r\n    }\r\n\r\n\tvar p=\"=\";\r\n\tvar tab=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n\r\n\tbase64.encode=function(/* byte[] */ba){\r\n\t\t// summary:\r\n\t\t//\t\tEncode an array of bytes as a base64-encoded string\r\n\t\tvar s=[], l=ba.length;\r\n\t\tvar rm=l%3;\r\n\t\tvar x=l-rm;\r\n\t\tfor (var i=0; i<x;){\r\n\t\t\tvar t=ba[i++]<<16|ba[i++]<<8|ba[i++];\r\n\t\t\ts.push(tab.charAt((t>>>18)&0x3f));\r\n\t\t\ts.push(tab.charAt((t>>>12)&0x3f));\r\n\t\t\ts.push(tab.charAt((t>>>6)&0x3f));\r\n\t\t\ts.push(tab.charAt(t&0x3f));\r\n\t\t}\r\n\t\t//\tdeal with trailers, based on patch from Peter Wood.\r\n\t\tswitch(rm){\r\n\t\t\tcase 2:{\r\n\t\t\t\tvar t=ba[i++]<<16|ba[i++]<<8;\r\n\t\t\t\ts.push(tab.charAt((t>>>18)&0x3f));\r\n\t\t\t\ts.push(tab.charAt((t>>>12)&0x3f));\r\n\t\t\t\ts.push(tab.charAt((t>>>6)&0x3f));\r\n\t\t\t\ts.push(p);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tcase 1:{\r\n\t\t\t\tvar t=ba[i++]<<16;\r\n\t\t\t\ts.push(tab.charAt((t>>>18)&0x3f));\r\n\t\t\t\ts.push(tab.charAt((t>>>12)&0x3f));\r\n\t\t\t\ts.push(p);\r\n\t\t\t\ts.push(p);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn s.join(\"\");\t//\tstring\r\n\t};\r\n\r\n\tbase64.decode=function(/* string */str){\r\n\t\t// summary:\r\n\t\t//\t\tConvert a base64-encoded string to an array of bytes\r\n\t\tvar s=str.split(\"\"), out=[];\r\n\t\tvar l=s.length;\r\n\t\twhile(s[--l]==p){ }\t//\tstrip off trailing padding\r\n\t\tfor (var i=0; i<l;){\r\n\t\t\tvar t=tab.indexOf(s[i++])<<18;\r\n\t\t\tif(i<=l){ t|=tab.indexOf(s[i++])<<12 };\r\n\t\t\tif(i<=l){ t|=tab.indexOf(s[i++])<<6 };\r\n\t\t\tif(i<=l){ t|=tab.indexOf(s[i++]) };\r\n\t\t\tout.push((t>>>16)&0xff);\r\n\t\t\tout.push((t>>>8)&0xff);\r\n\t\t\tout.push(t&0xff);\r\n\t\t}\r\n\t\t//\tstrip off any null bytes\r\n\t\twhile(out[out.length-1]==0){ out.pop(); }\r\n\t\treturn out;\t//\tbyte[]\r\n\t};\r\n\r\n    return codec.base64 = base64;\r\n});\r\n\ndefine('skylark-utils-codec/jbig2',[\n  \"skylark-langx/langx\",\n  \"skylark-utils-stream/DecodeStream\",\n  \"./codec\"\n],function(langx,DecodeStream,codec){\n  'use strict';\n\n   //The module code is based from mozilla/pdf.js/\n   // original : https://github.com/mozilla/pdf.js/blob/master/src/core/jbig2.js\n   // license  : Apache 2\n\n  // Annex E. Arithmetic Coding\n\n    var QeTable = [\n      {qe: 0x5601, nmps: 1, nlps: 1, switchFlag: 1},\n      {qe: 0x3401, nmps: 2, nlps: 6, switchFlag: 0},\n      {qe: 0x1801, nmps: 3, nlps: 9, switchFlag: 0},\n      {qe: 0x0AC1, nmps: 4, nlps: 12, switchFlag: 0},\n      {qe: 0x0521, nmps: 5, nlps: 29, switchFlag: 0},\n      {qe: 0x0221, nmps: 38, nlps: 33, switchFlag: 0},\n      {qe: 0x5601, nmps: 7, nlps: 6, switchFlag: 1},\n      {qe: 0x5401, nmps: 8, nlps: 14, switchFlag: 0},\n      {qe: 0x4801, nmps: 9, nlps: 14, switchFlag: 0},\n      {qe: 0x3801, nmps: 10, nlps: 14, switchFlag: 0},\n      {qe: 0x3001, nmps: 11, nlps: 17, switchFlag: 0},\n      {qe: 0x2401, nmps: 12, nlps: 18, switchFlag: 0},\n      {qe: 0x1C01, nmps: 13, nlps: 20, switchFlag: 0},\n      {qe: 0x1601, nmps: 29, nlps: 21, switchFlag: 0},\n      {qe: 0x5601, nmps: 15, nlps: 14, switchFlag: 1},\n      {qe: 0x5401, nmps: 16, nlps: 14, switchFlag: 0},\n      {qe: 0x5101, nmps: 17, nlps: 15, switchFlag: 0},\n      {qe: 0x4801, nmps: 18, nlps: 16, switchFlag: 0},\n      {qe: 0x3801, nmps: 19, nlps: 17, switchFlag: 0},\n      {qe: 0x3401, nmps: 20, nlps: 18, switchFlag: 0},\n      {qe: 0x3001, nmps: 21, nlps: 19, switchFlag: 0},\n      {qe: 0x2801, nmps: 22, nlps: 19, switchFlag: 0},\n      {qe: 0x2401, nmps: 23, nlps: 20, switchFlag: 0},\n      {qe: 0x2201, nmps: 24, nlps: 21, switchFlag: 0},\n      {qe: 0x1C01, nmps: 25, nlps: 22, switchFlag: 0},\n      {qe: 0x1801, nmps: 26, nlps: 23, switchFlag: 0},\n      {qe: 0x1601, nmps: 27, nlps: 24, switchFlag: 0},\n      {qe: 0x1401, nmps: 28, nlps: 25, switchFlag: 0},\n      {qe: 0x1201, nmps: 29, nlps: 26, switchFlag: 0},\n      {qe: 0x1101, nmps: 30, nlps: 27, switchFlag: 0},\n      {qe: 0x0AC1, nmps: 31, nlps: 28, switchFlag: 0},\n      {qe: 0x09C1, nmps: 32, nlps: 29, switchFlag: 0},\n      {qe: 0x08A1, nmps: 33, nlps: 30, switchFlag: 0},\n      {qe: 0x0521, nmps: 34, nlps: 31, switchFlag: 0},\n      {qe: 0x0441, nmps: 35, nlps: 32, switchFlag: 0},\n      {qe: 0x02A1, nmps: 36, nlps: 33, switchFlag: 0},\n      {qe: 0x0221, nmps: 37, nlps: 34, switchFlag: 0},\n      {qe: 0x0141, nmps: 38, nlps: 35, switchFlag: 0},\n      {qe: 0x0111, nmps: 39, nlps: 36, switchFlag: 0},\n      {qe: 0x0085, nmps: 40, nlps: 37, switchFlag: 0},\n      {qe: 0x0049, nmps: 41, nlps: 38, switchFlag: 0},\n      {qe: 0x0025, nmps: 42, nlps: 39, switchFlag: 0},\n      {qe: 0x0015, nmps: 43, nlps: 40, switchFlag: 0},\n      {qe: 0x0009, nmps: 44, nlps: 41, switchFlag: 0},\n      {qe: 0x0005, nmps: 45, nlps: 42, switchFlag: 0},\n      {qe: 0x0001, nmps: 45, nlps: 43, switchFlag: 0},\n      {qe: 0x5601, nmps: 46, nlps: 46, switchFlag: 0}\n    ];\n\n  var ArithmeticDecoder = langx.klass({\n      \"klassName\" : \"ArithmeticDecoder\",\n\n      byteIn: function ArithmeticDecoder_byteIn() {\n        var data = this.data;\n        var bp = this.bp;\n        if (data[bp] == 0xFF) {\n          var b1 = data[bp + 1];\n          if (b1 > 0x8F) {\n            this.clow += 0xFF00;\n            this.ct = 8;\n          } else {\n            bp++;\n            this.clow += (data[bp] << 9);\n            this.ct = 7;\n            this.bp = bp;\n          }\n        } else {\n          bp++;\n          this.clow += bp < this.dataEnd ? (data[bp] << 8) : 0xFF00;\n          this.ct = 8;\n          this.bp = bp;\n        }\n        if (this.clow > 0xFFFF) {\n          this.chigh += (this.clow >> 16);\n          this.clow &= 0xFFFF;\n        }\n      },\n      readBit: function ArithmeticDecoder_readBit(contexts, pos) {\n        // contexts are packed into 1 byte: \n        // highest 7 bits carry cx.index, lowest bit carries cx.mps\n        var cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;\n        var qeTableIcx = QeTable[cx_index];\n        var qeIcx = qeTableIcx.qe;\n        var nmpsIcx = qeTableIcx.nmps;\n        var nlpsIcx = qeTableIcx.nlps;\n        var switchIcx = qeTableIcx.switchFlag;\n        var d;\n        this.a -= qeIcx;\n\n        if (this.chigh < qeIcx) {\n          // exchangeLps\n          if (this.a < qeIcx) {\n            this.a = qeIcx;\n            d = cx_mps;\n            cx_index = nmpsIcx;\n          } else {\n            this.a = qeIcx;\n            d = 1 - cx_mps;\n            if (switchIcx) {\n              cx_mps = d;\n            }\n            cx_index = nlpsIcx;\n          }\n        } else {\n          this.chigh -= qeIcx;\n          if ((this.a & 0x8000) !== 0) {\n            return cx_mps;\n          }\n          // exchangeMps\n          if (this.a < qeIcx) {\n            d = 1 - cx_mps;\n            if (switchIcx) {\n              cx_mps = d;\n            }\n            cx_index = nlpsIcx;\n          } else {\n            d = cx_mps;\n            cx_index = nmpsIcx;\n          }\n        }\n        // renormD;\n        do {\n          if (this.ct === 0)\n            this.byteIn();\n\n          this.a <<= 1;\n          this.chigh = ((this.chigh << 1) & 0xFFFF) | ((this.clow >> 15) & 1);\n          this.clow = (this.clow << 1) & 0xFFFF;\n          this.ct--;\n        } while ((this.a & 0x8000) === 0);\n\n        contexts[pos] = cx_index << 1 | cx_mps;\n        return d;\n      },\n  \n      \"init\" : function (data, start, end) {\n        this.data = data;\n        this.bp = start;\n        this.dataEnd = end;\n\n        this.chigh = data[start];\n        this.clow = 0;\n\n        this.byteIn();\n\n        this.chigh = ((this.chigh << 7) & 0xFFFF) | ((this.clow >> 9) & 0x7F);\n        this.clow = (this.clow << 7) & 0xFFFF;\n        this.ct -= 7;\n        this.a = 0x8000;\n    }\n\n  });\n\n\n   // Utility data structures\n  var ContextCache = langx.klass({\n    getContexts: function(id) {\n      if (id in this)\n        return this[id];\n      return (this[id] = new Int8Array(1<<16));\n    }\n  });\n\n  var DecodingContext = langx.klass({\n    \"decoder\" : {\n      get : function() {\n        var decoder = new ArithmeticDecoder(this.data, this.start, this.end);\n        return shadow(this, 'decoder', decoder);\n      }\n    },\n    \"contextCache\" : {\n      get : function() {\n        var cache = new ContextCache();\n        return shadow(this, 'contextCache', cache);\n      }\n    },\n    \"init\" : function (data, start, end) {\n      this.data = data;\n      this.start = start;\n      this.end = end;\n    }\n\n\n  });\n\n  // Annex A. Arithmetic Integer Decoding Procedure\n  // A.2 Procedure for decoding values\n  function decodeInteger(contextCache, procedure, decoder) {\n    var contexts = contextCache.getContexts(procedure);\n\n    var prev = 1;\n    var state = 1, v = 0, s;\n    var toRead = 32, offset = 4436; // defaults for state 7\n    while (state) {\n      var bit = decoder.readBit(contexts, prev);\n      prev = prev < 256 ? (prev << 1) | bit :\n        (((prev << 1) | bit) & 511) | 256;\n      switch (state) {\n        case 1:\n          s = !!bit;\n          break;\n        case 2:\n          if (bit) break;\n          state = 7;\n          toRead = 2;\n          offset = 0;\n          break;\n        case 3:\n          if (bit) break;\n          state = 7;\n          toRead = 4;\n          offset = 4;\n          break;\n        case 4:\n          if (bit) break;\n          state = 7;\n          toRead = 6;\n          offset = 20;\n          break;\n        case 5:\n          if (bit) break;\n          state = 7;\n          toRead = 8;\n          offset = 84;\n          break;\n        case 6:\n          if (bit) break;\n          state = 7;\n          toRead = 12;\n          offset = 340;\n          break;\n        default:\n          v = v * 2 + bit;\n          if (--toRead === 0)\n            state = 0;\n          continue;\n      }\n      state++;\n    }\n    v += offset;\n    return !s ? v : v > 0 ? -v : null;\n  }\n\n  // A.3 The IAID decoding procedure\n  function decodeIAID(contextCache, decoder, codeLength) {\n    var contexts = contextCache.getContexts('IAID');\n\n    var prev = 1;\n    for (var i = 0; i < codeLength; i++) {\n      var bit = decoder.readBit(contexts, prev);\n      prev = (prev * 2) + bit;\n    }\n    if (codeLength < 31)\n      return prev & ((1 << codeLength) - 1);\n    else\n      return prev - Math.pow(2, codeLength);\n  }\n\n  // 7.3 Segment types\n  var SegmentTypes = [\n    'SymbolDictionary', null, null, null, 'IntermediateTextRegion', null,\n    'ImmediateTextRegion', 'ImmediateLosslessTextRegion', null, null, null,\n    null, null, null, null, null, 'patternDictionary', null, null, null,\n    'IntermediateHalftoneRegion', null, 'ImmediateHalftoneRegion',\n    'ImmediateLosslessHalftoneRegion', null, null, null, null, null, null, null,\n    null, null, null, null, null, 'IntermediateGenericRegion', null,\n    'ImmediateGenericRegion', 'ImmediateLosslessGenericRegion',\n    'IntermediateGenericRefinementRegion', null,\n    'ImmediateGenericRefinementRegion',\n    'ImmediateLosslessGenericRefinementRegion', null, null, null, null,\n    'PageInformation', 'EndOfPage', 'EndOfStripe', 'EndOfFile', 'Profiles',\n    'Tables', null, null, null, null, null, null, null, null,\n    'Extension'\n  ];\n\n  var CodingTemplates = [\n    [{x: -1, y: -2}, {x: 0, y: -2}, {x: 1, y: -2}, {x: -2, y: -1},\n     {x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}, {x: 2, y: -1},\n     {x: -4, y: 0}, {x: -3, y: 0}, {x: -2, y: 0}, {x: -1, y: 0}],\n    [{x: -1, y: -2}, {x: 0, y: -2}, {x: 1, y: -2}, {x: 2, y: -2},\n     {x: -2, y: -1}, {x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1},\n     {x: 2, y: -1}, {x: -3, y: 0}, {x: -2, y: 0}, {x: -1, y: 0}],\n    [{x: -1, y: -2}, {x: 0, y: -2}, {x: 1, y: -2}, {x: -2, y: -1},\n     {x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}, {x: -2, y: 0},\n     {x: -1, y: 0}],\n    [{x: -3, y: -1}, {x: -2, y: -1}, {x: -1, y: -1}, {x: 0, y: -1},\n     {x: 1, y: -1}, {x: -4, y: 0}, {x: -3, y: 0}, {x: -2, y: 0}, {x: -1, y: 0}]\n  ];\n\n  var RefinementTemplates = [\n    {\n      coding: [{x: 0, y: -1}, {x: 1, y: -1}, {x: -1, y: 0}],\n      reference: [{x: 0, y: -1}, {x: 1, y: -1}, {x: -1, y: 0}, {x: 0, y: 0},\n                  {x: 1, y: 0}, {x: -1, y: 1}, {x: 0, y: 1}, {x: 1, y: 1}]\n    },\n    {\n      coding: [{x: -1, y: -1}, {x: 0, y: -1}, {x: 1, y: -1}, {x: -1, y: 0}],\n      reference: [{x: 0, y: -1}, {x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0},\n                  {x: 0, y: 1}, {x: 1, y: 1}]\n    }\n  ];\n\n  var ReusedContexts = [\n    0x1CD3, // '00111001101' (template) + '0011' (at),\n    0x079A, // '001111001101' + '0',\n    0x00E3, // '001110001' + '1',\n    0x018B  // '011000101' + '1'\n  ];\n\n  var RefinementReusedContexts = [\n    0x0020, // '000' + '0' (coding) + '00010000' + '0' (reference)\n    0x0008  // '0000' + '001000'\n  ];\n\n  function log2(x) {\n    var n = 1, i = 0;\n    while (x > n) {\n      n <<= 1;\n      i++;\n    }\n    return i;\n  }\n\n  function readInt32(data, start) {\n    return (data[start] << 24) | (data[start + 1] << 16) |\n           (data[start + 2] << 8) | data[start + 3];\n  }\n\n  function readUint32(data, start) {\n    var value = readInt32(data, start);\n    return value & 0x80000000 ? (value + 4294967296) : value;\n  }\n\n  function readUint16(data, start) {\n    return (data[start] << 8) | data[start + 1];\n  }\n\n  function readInt8(data, start) {\n    return (data[start] << 24) >> 24;\n  }\n\n  // 6.2 Generic Region Decoding Procedure\n  function decodeBitmap(mmr, width, height, templateIndex, prediction, skip, at,\n                        decodingContext) {\n    if (mmr)\n      error('JBIG2 error: MMR encoding is not supported');\n\n    var useskip = !!skip;\n    var template = CodingTemplates[templateIndex].concat(at);\n    var templateLength = template.length;\n    var templateX = new Int32Array(templateLength);\n    var templateY = new Int32Array(templateLength);\n    for (var k = 0; k < templateLength; k++) {\n      templateX[k] = template[k].x;\n      templateY[k] = template[k].y;\n    }\n\n    var pseudoPixelContext = ReusedContexts[templateIndex];\n    var bitmap = [];\n\n    var decoder = decodingContext.decoder;\n    var contexts = decodingContext.contextCache.getContexts('GB');\n\n    var ltp = 0;\n    for (var i = 0; i < height; i++) {\n      if (prediction) {\n        var sltp = decoder.readBit(contexts, pseudoPixelContext);\n        ltp ^= sltp;\n      }\n      if (ltp) {\n        bitmap.push(bitmap[bitmap.length - 1]); // duplicate previous row\n        continue;\n      }\n      var row = new Uint8Array(width);\n      bitmap.push(row);\n      for (var j = 0; j < width; j++) {\n        if (useskip && skip[i][j]) {\n          row[j] = 0;\n          continue;\n        }\n        var contextLabel = 0;\n        for (var k = 0; k < templateLength; k++) {\n          var i0 = i + templateY[k], j0 = j + templateX[k];\n          if (i0 < 0 || j0 < 0 || j0 >= width)\n            contextLabel <<= 1; // out of bound pixel\n          else\n            contextLabel = (contextLabel << 1) | bitmap[i0][j0];\n        }\n        var pixel = decoder.readBit(contexts, contextLabel);\n        row[j] = pixel;\n      }\n    }\n    return bitmap;\n  }\n\n  // 6.3.2 Generic Refinement Region Decoding Procedure\n  function decodeRefinement(width, height, templateIndex, referenceBitmap,\n                            offsetX, offsetY, prediction, at,\n                            decodingContext) {\n    var codingTemplate = RefinementTemplates[templateIndex].coding;\n    if (templateIndex === 0)\n      codingTemplate = codingTemplate.concat([at[0]]);\n    var codingTemplateLength = codingTemplate.length;\n    var codingTemplateX = new Int32Array(codingTemplateLength);\n    var codingTemplateY = new Int32Array(codingTemplateLength);\n    for (var k = 0; k < codingTemplateLength; k++) {\n      codingTemplateX[k] = codingTemplate[k].x;\n      codingTemplateY[k] = codingTemplate[k].y;\n    }\n    var referenceTemplate = RefinementTemplates[templateIndex].reference;\n    if (templateIndex === 0)\n      referenceTemplate = referenceTemplate.concat([at[1]]);\n    var referenceTemplateLength = referenceTemplate.length;\n    var referenceTemplateX = new Int32Array(referenceTemplateLength);\n    var referenceTemplateY = new Int32Array(referenceTemplateLength);\n    for (var k = 0; k < referenceTemplateLength; k++) {\n      referenceTemplateX[k] = referenceTemplate[k].x;\n      referenceTemplateY[k] = referenceTemplate[k].y;\n    }\n    var referenceWidth = referenceBitmap[0].length;\n    var referenceHeight = referenceBitmap.length;\n\n    var pseudoPixelContext = RefinementReusedContexts[templateIndex];\n    var bitmap = [];\n\n    var decoder = decodingContext.decoder;\n    var contexts = decodingContext.contextCache.getContexts('GR');\n\n    var ltp = 0;\n    for (var i = 0; i < height; i++) {\n      if (prediction) {\n        var sltp = decoder.readBit(contexts, pseudoPixelContext);\n        ltp ^= sltp;\n      }\n      var row = new Uint8Array(width);\n      bitmap.push(row);\n      for (var j = 0; j < width; j++) {\n        if (ltp)\n          error('JBIG2 error: prediction is not supported');\n\n        var contextLabel = 0;\n        for (var k = 0; k < codingTemplateLength; k++) {\n          var i0 = i + codingTemplateY[k], j0 = j + codingTemplateX[k];\n          if (i0 < 0 || j0 < 0 || j0 >= width)\n            contextLabel <<= 1; // out of bound pixel\n          else\n            contextLabel = (contextLabel << 1) | bitmap[i0][j0];\n        }\n        for (var k = 0; k < referenceTemplateLength; k++) {\n          var i0 = i + referenceTemplateY[k] + offsetY;\n          var j0 = j + referenceTemplateX[k] + offsetX;\n          if (i0 < 0 || i0 >= referenceHeight || j0 < 0 || j0 >= referenceWidth)\n            contextLabel <<= 1; // out of bound pixel\n          else\n            contextLabel = (contextLabel << 1) | referenceBitmap[i0][j0];\n        }\n        var pixel = decoder.readBit(contexts, contextLabel);\n        row[j] = pixel;\n      }\n    }\n\n    return bitmap;\n  }\n\n  // 6.5.5 Decoding the symbol dictionary\n  function decodeSymbolDictionary(huffman, refinement, symbols,\n                                  numberOfNewSymbols, numberOfExportedSymbols,\n                                  huffmanTables, templateIndex, at,\n                                  refinementTemplateIndex, refinementAt,\n                                  decodingContext) {\n    if (huffman)\n      error('JBIG2 error: huffman is not supported');\n\n    var newSymbols = [];\n    var currentHeight = 0;\n    var symbolCodeLength = log2(symbols.length + numberOfNewSymbols);\n\n    var decoder = decodingContext.decoder;\n    var contextCache = decodingContext.contextCache;\n\n    while (newSymbols.length < numberOfNewSymbols) {\n      var deltaHeight = decodeInteger(contextCache, 'IADH', decoder); // 6.5.6\n      currentHeight += deltaHeight;\n      var currentWidth = 0;\n      var totalWidth = 0;\n      while (true) {\n        var deltaWidth = decodeInteger(contextCache, 'IADW', decoder); // 6.5.7\n        if (deltaWidth === null)\n          break; // OOB\n        currentWidth += deltaWidth;\n        totalWidth += currentWidth;\n        var bitmap;\n        if (refinement) {\n          // 6.5.8.2 Refinement/aggregate-coded symbol bitmap\n          var numberOfInstances = decodeInteger(contextCache, 'IAAI', decoder);\n          if (numberOfInstances > 1)\n            error('JBIG2 error: number of instances > 1 is not supported');\n          var symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);\n          var rdx = decodeInteger(contextCache, 'IARDX', decoder); // 6.4.11.3\n          var rdy = decodeInteger(contextCache, 'IARDY', decoder); // 6.4.11.4\n          var symbol = symbolId < symbols.length ? symbols[symbolId] :\n            newSymbols[symbolId - symbols.length];\n          bitmap = decodeRefinement(currentWidth, currentHeight,\n            refinementTemplateIndex, symbol, rdx, rdy, false, refinementAt,\n            decodingContext);\n        } else {\n          // 6.5.8.1 Direct-coded symbol bitmap\n          bitmap = decodeBitmap(false, currentWidth, currentHeight,\n            templateIndex, false, null, at, decodingContext);\n        }\n        newSymbols.push(bitmap);\n      }\n    }\n    // 6.5.10 Exported symbols\n    var exportedSymbols = [];\n    var flags = [], currentFlag = false;\n    var totalSymbolsLength = symbols.length + numberOfNewSymbols;\n    while (flags.length < totalSymbolsLength) {\n      var runLength = decodeInteger(contextCache, 'IAEX', decoder);\n      while (runLength--)\n        flags.push(currentFlag);\n      currentFlag = !currentFlag;\n    }\n    for (var i = 0, ii = symbols.length; i < ii; i++)\n      if (flags[i]) exportedSymbols.push(symbols[i]);\n    for (var j = 0; j < numberOfNewSymbols; i++, j++)\n      if (flags[i]) exportedSymbols.push(newSymbols[j]);\n    return exportedSymbols;\n  }\n\n  function decodeTextRegion(huffman, refinement, width, height,\n                            defaultPixelValue, numberOfSymbolInstances,\n                            stripSize, inputSymbols, symbolCodeLength,\n                            transposed, dsOffset, referenceCorner,\n                            combinationOperator, huffmanTables,\n                            refinementTemplateIndex, refinementAt,\n                            decodingContext) {\n    if (huffman)\n      error('JBIG2 error: huffman is not supported');\n\n    // Prepare bitmap\n    var bitmap = [];\n    for (var i = 0; i < height; i++) {\n      var row = new Uint8Array(width);\n      if (defaultPixelValue) {\n        for (var j = 0; j < width; j++)\n          row[j] = defaultPixelValue;\n      }\n      bitmap.push(row);\n    }\n\n    var decoder = decodingContext.decoder;\n    var contextCache = decodingContext.contextCache;\n    var stripT = -decodeInteger(contextCache, 'IADT', decoder); // 6.4.6\n    var firstS = 0;\n    var i = 0;\n    while (i < numberOfSymbolInstances) {\n      var deltaT = decodeInteger(contextCache, 'IADT', decoder); // 6.4.6\n      stripT += deltaT;\n\n      var deltaFirstS = decodeInteger(contextCache, 'IAFS', decoder); // 6.4.7\n      firstS += deltaFirstS;\n      var currentS = firstS;\n      do {\n        var currentT = stripSize == 1 ? 0 :\n          decodeInteger(contextCache, 'IAIT', decoder); // 6.4.9\n        var t = stripSize * stripT + currentT;\n        var symbolId = decodeIAID(contextCache, decoder, symbolCodeLength);\n        var applyRefinement = refinement &&\n          decodeInteger(contextCache, 'IARI', decoder);\n        var symbolBitmap = inputSymbols[symbolId];\n        var symbolWidth = symbolBitmap[0].length;\n        var symbolHeight = symbolBitmap.length;\n        if (applyRefinement) {\n          var rdw = decodeInteger(contextCache, 'IARDW', decoder); // 6.4.11.1\n          var rdh = decodeInteger(contextCache, 'IARDH', decoder); // 6.4.11.2\n          var rdx = decodeInteger(contextCache, 'IARDX', decoder); // 6.4.11.3\n          var rdy = decodeInteger(contextCache, 'IARDY', decoder); // 6.4.11.4\n          symbolWidth += rdw;\n          symbolHeight += rdh;\n          symbolBitmap = decodeRefinement(symbolWidth, symbolHeight,\n            refinementTemplateIndex, symbolBitmap, (rdw >> 1) + rdx,\n            (rdh >> 1) + rdy, false, refinementAt,\n            decodingContext);\n        }\n        var offsetT = t - ((referenceCorner & 1) ? 0 : symbolHeight);\n        var offsetS = currentS - ((referenceCorner & 2) ? symbolWidth : 0);\n        if (transposed) {\n          // Place Symbol Bitmap from T1,S1  \n          for (var s2 = 0; s2 < symbolHeight; s2++) {\n            var row = bitmap[offsetS + s2];\n            if (!row) {\n              continue;\n            }\n            var symbolRow = symbolBitmap[s2];\n            // To ignore Parts of Symbol bitmap which goes\n            // outside bitmap region\n            var maxWidth = Math.min(width - offsetT, symbolWidth);\n            switch (combinationOperator) {\n              case 0: // OR\n                for (var t2 = 0; t2 < maxWidth; t2++) {\n                  row[offsetT + t2] |= symbolRow[t2];\n                }\n                break;\n              case 2: // XOR\n                for (var t2 = 0; t2 < maxWidth; t2++) {\n                  row[offsetT + t2] ^= symbolRow[t2];\n                }\n                break;\n              default:\n                error('JBIG2 error: operator ' + combinationOperator +\n                      ' is not supported');\n            }\n          }\n          currentS += symbolHeight - 1;\n        } else {\n          for (var t2 = 0; t2 < symbolHeight; t2++) {\n            var row = bitmap[offsetT + t2];\n            if (!row) {\n              continue;\n            }\n            var symbolRow = symbolBitmap[t2];\n            switch (combinationOperator) {\n              case 0: // OR\n                for (var s2 = 0; s2 < symbolWidth; s2++) {\n                  row[offsetS + s2] |= symbolRow[s2];\n                }\n                break;\n              case 2: // XOR\n                for (var s2 = 0; s2 < symbolWidth; s2++) {\n                  row[offsetS + s2] ^= symbolRow[s2];\n                }\n                break;\n              default:\n                error('JBIG2 error: operator ' + combinationOperator +\n                      ' is not supported');\n            }\n          }\n          currentS += symbolWidth - 1;\n        }\n        i++;\n        var deltaS = decodeInteger(contextCache, 'IADS', decoder); // 6.4.8\n        if (deltaS === null)\n          break; // OOB\n        currentS += deltaS + dsOffset;\n      } while (true);\n    }\n    return bitmap;\n  }\n\n  function readSegmentHeader(data, start) {\n    var segmentHeader = {};\n    segmentHeader.number = readUint32(data, start);\n    var flags = data[start + 4];\n    var segmentType = flags & 0x3F;\n    if (!SegmentTypes[segmentType])\n      error('JBIG2 error: invalid segment type: ' + segmentType);\n    segmentHeader.type = segmentType;\n    segmentHeader.typeName = SegmentTypes[segmentType];\n    segmentHeader.deferredNonRetain = !!(flags & 0x80);\n    var pageAssociationFieldSize = !!(flags & 0x40);\n    var referredFlags = data[start + 5];\n    var referredToCount = (referredFlags >> 5) & 7;\n    var retainBits = [referredFlags & 31];\n    var position = start + 6;\n    if (referredFlags == 7) {\n      referredToCount = readInt32(data, position - 1) & 0x1FFFFFFF;\n      position += 3;\n      var bytes = (referredToCount + 7) >> 3;\n      retainBits[0] = data[position++];\n      while (--bytes > 0) {\n        retainBits.push(data[position++]);\n      }\n    } else if (referredFlags == 5 || referredFlags == 6)\n      error('JBIG2 error: invalid referred-to flags');\n    segmentHeader.retainBits = retainBits;\n    var referredToSegmentNumberSize = segmentHeader.number <= 256 ? 1 :\n      segmentHeader.number <= 65536 ? 2 : 4;\n    var referredTo = [];\n    for (var i = 0; i < referredToCount; i++) {\n      var number = referredToSegmentNumberSize == 1 ? data[position] :\n        referredToSegmentNumberSize == 2 ? readUint16(data, position) :\n        readUint32(data, position);\n      referredTo.push(number);\n      position += referredToSegmentNumberSize;\n    }\n    segmentHeader.referredTo = referredTo;\n    if (!pageAssociationFieldSize)\n      segmentHeader.pageAssociation = data[position++];\n    else {\n      segmentHeader.pageAssociation = readUint32(data, position);\n      position += 4;\n    }\n    segmentHeader.length = readUint32(data, position);\n    position += 4;\n    if (segmentHeader.length == 0xFFFFFFFF) {\n      // 7.2.7 Segment data length, unknown segment length\n      if (segmentType === 38) { // ImmediateGenericRegion\n        var genericRegionInfo = readRegionSegmentInformation(data, position);\n        var genericRegionSegmentFlags = data[position +\n          RegionSegmentInformationFieldLength];\n        var genericRegionMmr = !!(genericRegionSegmentFlags & 1);\n        // searching for the segment end\n        var searchPatternLength = 6;\n        var searchPattern = new Uint8Array(searchPatternLength);\n        if (!genericRegionMmr) {\n          searchPattern[0] = 0xFF;\n          searchPattern[1] = 0xAC;\n        }\n        searchPattern[2] = (genericRegionInfo.height >>> 24) & 0xFF;\n        searchPattern[3] = (genericRegionInfo.height >> 16) & 0xFF;\n        searchPattern[4] = (genericRegionInfo.height >> 8) & 0xFF;\n        searchPattern[5] = genericRegionInfo.height & 0xFF;\n        for (var i = position, ii = data.length; i < ii; i++) {\n          var j = 0;\n          while (j < searchPatternLength && searchPattern[j] === data[i + j]) {\n            j++;\n          }\n          if (j == searchPatternLength) {\n            segmentHeader.length = i + searchPatternLength;\n            break;\n          }\n        }\n        if (segmentHeader.length == 0xFFFFFFFF) {\n          error('JBIG2 error: segment end was not found');\n        }\n      } else {\n        error('JBIG2 error: invalid unknown segment length');\n      }\n    }\n    segmentHeader.headerEnd = position;\n    return segmentHeader;\n  }\n\n  function readSegments(header, data, start, end) {\n    var segments = [];\n    var position = start;\n    while (position < end) {\n      var segmentHeader = readSegmentHeader(data, position);\n      position = segmentHeader.headerEnd;\n      var segment = {\n        header: segmentHeader,\n        data: data\n      };\n      if (!header.randomAccess) {\n        segment.start = position;\n        position += segmentHeader.length;\n        segment.end = position;\n      }\n      segments.push(segment);\n      if (segmentHeader.type == 51)\n        break; // end of file is found\n    }\n    if (header.randomAccess) {\n      for (var i = 0, ii = segments.length; i < ii; i++) {\n        segments[i].start = position;\n        position += segments[i].header.length;\n        segments[i].end = position;\n      }\n    }\n    return segments;\n  }\n\n  // 7.4.1 Region segment information field\n  function readRegionSegmentInformation(data, start) {\n    return {\n      width: readUint32(data, start),\n      height: readUint32(data, start + 4),\n      x: readUint32(data, start + 8),\n      y: readUint32(data, start + 12),\n      combinationOperator: data[start + 16] & 7\n    };\n  }\n  var RegionSegmentInformationFieldLength = 17;\n\n  function processSegment(segment, visitor) {\n    var header = segment.header;\n\n    var data = segment.data, position = segment.start, end = segment.end;\n    var args;\n    switch (header.type) {\n      case 0: // SymbolDictionary\n        // 7.4.2 Symbol dictionary segment syntax\n        var dictionary = {};\n        var dictionaryFlags = readUint16(data, position); // 7.4.2.1.1\n        dictionary.huffman = !!(dictionaryFlags & 1);\n        dictionary.refinement = !!(dictionaryFlags & 2);\n        dictionary.huffmanDHSelector = (dictionaryFlags >> 2) & 3;\n        dictionary.huffmanDWSelector = (dictionaryFlags >> 4) & 3;\n        dictionary.bitmapSizeSelector = (dictionaryFlags >> 6) & 1;\n        dictionary.aggregationInstancesSelector = (dictionaryFlags >> 7) & 1;\n        dictionary.bitmapCodingContextUsed = !!(dictionaryFlags & 256);\n        dictionary.bitmapCodingContextRetained = !!(dictionaryFlags & 512);\n        dictionary.template = (dictionaryFlags >> 10) & 3;\n        dictionary.refinementTemplate = (dictionaryFlags >> 12) & 1;\n        position += 2;\n        if (!dictionary.huffman) {\n          var atLength = dictionary.template === 0 ? 4 : 1;\n          var at = [];\n          for (var i = 0; i < atLength; i++) {\n            at.push({\n              x: readInt8(data, position),\n              y: readInt8(data, position + 1)\n            });\n            position += 2;\n          }\n          dictionary.at = at;\n        }\n        if (dictionary.refinement && !dictionary.refinementTemplate) {\n          var at = [];\n          for (var i = 0; i < 2; i++) {\n            at.push({\n              x: readInt8(data, position),\n              y: readInt8(data, position + 1)\n            });\n            position += 2;\n          }\n          dictionary.refinementAt = at;\n        }\n        dictionary.numberOfExportedSymbols = readUint32(data, position);\n        position += 4;\n        dictionary.numberOfNewSymbols = readUint32(data, position);\n        position += 4;\n        args = [dictionary, header.number, header.referredTo,\n                data, position, end];\n        break;\n      case 6: // ImmediateTextRegion\n      case 7: // ImmediateLosslessTextRegion\n        var textRegion = {};\n        textRegion.info = readRegionSegmentInformation(data, position);\n        position += RegionSegmentInformationFieldLength;\n        var textRegionSegmentFlags = readUint16(data, position);\n        position += 2;\n        textRegion.huffman = !!(textRegionSegmentFlags & 1);\n        textRegion.refinement = !!(textRegionSegmentFlags & 2);\n        textRegion.stripSize = 1 << ((textRegionSegmentFlags >> 2) & 3);\n        textRegion.referenceCorner = (textRegionSegmentFlags >> 4) & 3;\n        textRegion.transposed = !!(textRegionSegmentFlags & 64);\n        textRegion.combinationOperator = (textRegionSegmentFlags >> 7) & 3;\n        textRegion.defaultPixelValue = (textRegionSegmentFlags >> 9) & 1;\n        textRegion.dsOffset = (textRegionSegmentFlags << 17) >> 27;\n        textRegion.refinementTemplate = (textRegionSegmentFlags >> 15) & 1;\n        if (textRegion.huffman) {\n          var textRegionHuffmanFlags = readUint16(data, position);\n          position += 2;\n          textRegion.huffmanFS = (textRegionHuffmanFlags) & 3;\n          textRegion.huffmanDS = (textRegionHuffmanFlags >> 2) & 3;\n          textRegion.huffmanDT = (textRegionHuffmanFlags >> 4) & 3;\n          textRegion.huffmanRefinementDW = (textRegionHuffmanFlags >> 6) & 3;\n          textRegion.huffmanRefinementDH = (textRegionHuffmanFlags >> 8) & 3;\n          textRegion.huffmanRefinementDX = (textRegionHuffmanFlags >> 10) & 3;\n          textRegion.huffmanRefinementDY = (textRegionHuffmanFlags >> 12) & 3;\n          textRegion.huffmanRefinementSizeSelector =\n            !!(textRegionHuffmanFlags & 14);\n        }\n        if (textRegion.refinement && !textRegion.refinementTemplate) {\n          var at = [];\n          for (var i = 0; i < 2; i++) {\n            at.push({\n              x: readInt8(data, position),\n              y: readInt8(data, position + 1)\n            });\n            position += 2;\n          }\n          textRegion.refinementAt = at;\n        }\n        textRegion.numberOfSymbolInstances = readUint32(data, position);\n        position += 4;\n        // TODO 7.4.3.1.7 Symbol ID Huffman table decoding\n        if (textRegion.huffman)\n          error('JBIG2 error: huffman is not supported');\n        args = [textRegion, header.referredTo, data, position, end];\n        break;\n      case 38: // ImmediateGenericRegion\n      case 39: // ImmediateLosslessGenericRegion\n        var genericRegion = {};\n        genericRegion.info = readRegionSegmentInformation(data, position);\n        position += RegionSegmentInformationFieldLength;\n        var genericRegionSegmentFlags = data[position++];\n        genericRegion.mmr = !!(genericRegionSegmentFlags & 1);\n        genericRegion.template = (genericRegionSegmentFlags >> 1) & 3;\n        genericRegion.prediction = !!(genericRegionSegmentFlags & 8);\n        if (!genericRegion.mmr) {\n          var atLength = genericRegion.template === 0 ? 4 : 1;\n          var at = [];\n          for (var i = 0; i < atLength; i++) {\n            at.push({\n              x: readInt8(data, position),\n              y: readInt8(data, position + 1)\n            });\n            position += 2;\n          }\n          genericRegion.at = at;\n        }\n        args = [genericRegion, data, position, end];\n        break;\n      case 48: // PageInformation\n        var pageInfo = {\n          width: readUint32(data, position),\n          height: readUint32(data, position + 4),\n          resolutionX: readUint32(data, position + 8),\n          resolutionY: readUint32(data, position + 12)\n        };\n        if (pageInfo.height == 0xFFFFFFFF)\n          delete pageInfo.height;\n        var pageSegmentFlags = data[position + 16];\n        var pageStripingInformatiom = readUint16(data, position + 17);\n        pageInfo.lossless = !!(pageSegmentFlags & 1);\n        pageInfo.refinement = !!(pageSegmentFlags & 2);\n        pageInfo.defaultPixelValue = (pageSegmentFlags >> 2) & 1;\n        pageInfo.combinationOperator = (pageSegmentFlags >> 3) & 3;\n        pageInfo.requiresBuffer = !!(pageSegmentFlags & 32);\n        pageInfo.combinationOperatorOverride = !!(pageSegmentFlags & 64);\n        args = [pageInfo];\n        break;\n      case 49: // EndOfPage\n        break;\n      case 50: // EndOfStripe\n        break;\n      case 51: // EndOfFile\n        break;\n      case 62: // 7.4.15 defines 2 extension types which\n               // are comments and can be ignored.\n        break;\n      default:\n        error('JBIG2 error: segment type ' + header.typeName + '(' +\n              header.type + ') is not implemented');\n    }\n    var callbackName = 'on' + header.typeName;\n    if (callbackName in visitor)\n      visitor[callbackName].apply(visitor, args);\n  }\n\n  function processSegments(segments, visitor) {\n    for (var i = 0, ii = segments.length; i < ii; i++)\n      processSegment(segments[i], visitor);\n  }\n\n  function parseJbig2(data, start, end) {\n    var position = start;\n    if (data[position] != 0x97 || data[position + 1] != 0x4A ||\n        data[position + 2] != 0x42 || data[position + 3] != 0x32 ||\n        data[position + 4] != 0x0D || data[position + 5] != 0x0A ||\n        data[position + 6] != 0x1A || data[position + 7] != 0x0A)\n      error('JBIG2 error: invalid header');\n    var header = {};\n    position += 8;\n    var flags = data[position++];\n    header.randomAccess = !(flags & 1);\n    if (!(flags & 2)) {\n      header.numberOfPages = readUint32(data, position);\n      position += 4;\n    }\n    var segments = readSegments(header, data, position, end);\n    error('Not implemented');\n    // processSegments(segments, new SimpleSegmentVisitor());\n  }\n\n  function parseJbig2Chunks(chunks) {\n    var visitor = new SimpleSegmentVisitor();\n    for (var i = 0, ii = chunks.length; i < ii; i++) {\n      var chunk = chunks[i];\n      var segments = readSegments({}, chunk.data, chunk.start, chunk.end);\n      processSegments(segments, visitor);\n    }\n    return visitor.buffer;\n  }\n\n  var SimpleSegmentVisitor = langx.klass({\n    onPageInformation: function SimpleSegmentVisitor_onPageInformation(info) {\n      this.currentPageInfo = info;\n      var rowSize = (info.width + 7) >> 3;\n      var buffer = new Uint8Array(rowSize * info.height);\n      var fill = info.defaultPixelValue ? 0xFF : 0;\n      for (var i = 0, ii = buffer.length; i < ii; i++)\n        buffer[i] = fill;\n      this.buffer = buffer;\n    },\n    drawBitmap: function SimpleSegmentVisitor_drawBitmap(regionInfo, bitmap) {\n      var pageInfo = this.currentPageInfo;\n      var width = regionInfo.width, height = regionInfo.height;\n      var rowSize = (pageInfo.width + 7) >> 3;\n      var combinationOperator = pageInfo.combinationOperatorOverride ?\n        regionInfo.combinationOperator : pageInfo.combinationOperator;\n      var buffer = this.buffer;\n      for (var i = 0; i < height; i++) {\n        var mask = 128 >> (regionInfo.x & 7);\n        var offset = (i + regionInfo.y) * rowSize + (regionInfo.x >> 3);\n        switch (combinationOperator) {\n          case 0: // OR\n            for (var j = 0; j < width; j++) {\n              buffer[offset] |= bitmap[i][j] ? mask : 0;\n              mask >>= 1;\n              if (!mask) {\n                mask = 128;\n                offset++;\n              }\n            }\n            break;\n          case 2: // XOR\n            for (var j = 0; j < width; j++) {\n              buffer[offset] ^= bitmap[i][j] ? mask : 0;\n              mask >>= 1;\n              if (!mask) {\n                mask = 128;\n                offset++;\n              }\n            }\n            break;\n          default:\n            error('JBIG2 error: operator ' + combinationOperator +\n                  ' is not supported');\n        }\n      }\n    },\n    onImmediateGenericRegion:\n      function SimpleSegmentVisitor_onImmediateGenericRegion(region, data,\n                                                             start, end) {\n      var regionInfo = region.info;\n      var decodingContext = new DecodingContext(data, start, end);\n      var bitmap = decodeBitmap(region.mmr, regionInfo.width, regionInfo.height,\n                                region.template, region.prediction, null,\n                                region.at, decodingContext);\n      this.drawBitmap(regionInfo, bitmap);\n    },\n    onImmediateLosslessGenericRegion:\n      function SimpleSegmentVisitor_onImmediateLosslessGenericRegion() {\n      this.onImmediateGenericRegion.apply(this, arguments);\n    },\n    onSymbolDictionary:\n      function SimpleSegmentVisitor_onSymbolDictionary(dictionary,\n                                                       currentSegment,\n                                                       referredSegments,\n                                                       data, start, end) {\n      var huffmanTables;\n      if (dictionary.huffman)\n        error('JBIG2 error: huffman is not supported');\n\n      // Combines exported symbols from all referred segments\n      var symbols = this.symbols;\n      if (!symbols)\n        this.symbols = symbols = {};\n\n      var inputSymbols = [];\n      for (var i = 0, ii = referredSegments.length; i < ii; i++)\n        inputSymbols = inputSymbols.concat(symbols[referredSegments[i]]);\n\n      var decodingContext = new DecodingContext(data, start, end);\n      symbols[currentSegment] = decodeSymbolDictionary(dictionary.huffman,\n        dictionary.refinement, inputSymbols, dictionary.numberOfNewSymbols,\n        dictionary.numberOfExportedSymbols, huffmanTables,\n        dictionary.template, dictionary.at,\n        dictionary.refinementTemplate, dictionary.refinementAt,\n        decodingContext);\n    },\n    onImmediateTextRegion:\n      function SimpleSegmentVisitor_onImmediateTextRegion(region,\n                                                          referredSegments,\n                                                          data, start, end) {\n      var regionInfo = region.info;\n      var huffmanTables;\n\n      // Combines exported symbols from all referred segments\n      var symbols = this.symbols;\n      var inputSymbols = [];\n      for (var i = 0, ii = referredSegments.length; i < ii; i++)\n        inputSymbols = inputSymbols.concat(symbols[referredSegments[i]]);\n      var symbolCodeLength = log2(inputSymbols.length);\n\n      var decodingContext = new DecodingContext(data, start, end);\n      var bitmap = decodeTextRegion(region.huffman, region.refinement,\n        regionInfo.width, regionInfo.height, region.defaultPixelValue,\n        region.numberOfSymbolInstances, region.stripSize, inputSymbols,\n        symbolCodeLength, region.transposed, region.dsOffset,\n        region.referenceCorner, region.combinationOperator, huffmanTables,\n        region.refinementTemplate, region.refinementAt, decodingContext);\n      this.drawBitmap(regionInfo, bitmap);\n    },\n    onImmediateLosslessTextRegion:\n      function SimpleSegmentVisitor_onImmediateLosslessTextRegion() {\n        this.onImmediateTextRegion.apply(this, arguments);\n    }\n  });\n\n  var Jbig2Image = langx.klass({\n    parseChunks: function Jbig2Image_parseChunks(chunks) {\n      return parseJbig2Chunks(chunks);\n    }\n  });\n\n  /**\n   * For JBIG2's we use a library to decode these images and\n   * the stream behaves like all the other DecodeStreams.\n   */\n  var Jbig2Stream = DecodeStream.inherit({\n      klassName : \"Jbig2Stream\",\n\n      init : function(bytes, dict) {\n        this.dict = dict;\n        this.bytes = bytes;\n\n          this.overrided();          \n      },\n\n    ensureBuffer : function(req) {\n        if (this.bufferLength)\n            return;\n\n        var jbig2Image = new Jbig2Image();\n\n        var chunks = [],\n            decodeParams = this.dict.get('DecodeParms');\n        if (decodeParams && decodeParams.has('JBIG2Globals')) {\n            var globalsStream = decodeParams.get('JBIG2Globals');\n            var globals = globalsStream.getBytes();\n            chunks.push({\n                data: globals,\n                start: 0,\n                end: globals.length\n            });\n        }\n        chunks.push({\n            data: this.bytes,\n            start: 0,\n            end: this.bytes.length\n        });\n        var data = jbig2Image.parseChunks(chunks);\n        var dataLength = data.length;\n\n        // JBIG2 had black as 1 and white as 0, inverting the colors\n        for (var i = 0; i < dataLength; i++)\n            data[i] ^= 0xFF;\n\n        this.buffer = data;\n        this.bufferLength = dataLength;\n    },\n    getChar : function() {\n        error('internal error: getChar is not valid on Jbig2Stream');\n    }\n  });\n\n\n  return codec.jbig2 = {\n    \"Jbig2Image\" : Jbig2Image,\n    \"Jbig2Stream\" : Jbig2Stream\n  };\n});\n\ndefine('skylark-utils-codec/jpeg',[\r\n  \"skylark-langx/langx\",\r\n  \"skylark-utils-stream/DecodeStream\",\r\n  \"./codec\"\r\n],function(langx,DecodeStream,codec){\r\n  'use strict';\r\n\r\n   //The module code is based from mozilla/pdf.js/\r\n   // original : https://github.com/mozilla/pdf.js/blob/master/src/core/jpeg.js\r\n   // license  : Apache 2\r\n\r\n  var dctZigZag = new Uint8Array([\r\n     0,\r\n     1,  8,\r\n    16,  9,  2,\r\n     3, 10, 17, 24,\r\n    32, 25, 18, 11, 4,\r\n     5, 12, 19, 26, 33, 40,\r\n    48, 41, 34, 27, 20, 13,  6,\r\n     7, 14, 21, 28, 35, 42, 49, 56,\r\n    57, 50, 43, 36, 29, 22, 15,\r\n    23, 30, 37, 44, 51, 58,\r\n    59, 52, 45, 38, 31,\r\n    39, 46, 53, 60,\r\n    61, 54, 47,\r\n    55, 62,\r\n    63\r\n  ]);\r\n\r\n  var dctCos1  =  4017;   // cos(pi/16)\r\n  var dctSin1  =   799;   // sin(pi/16)\r\n  var dctCos3  =  3406;   // cos(3*pi/16)\r\n  var dctSin3  =  2276;   // sin(3*pi/16)\r\n  var dctCos6  =  1567;   // cos(6*pi/16)\r\n  var dctSin6  =  3784;   // sin(6*pi/16)\r\n  var dctSqrt2 =  5793;   // sqrt(2)\r\n  var dctSqrt1d2 = 2896;  // sqrt(2) / 2\r\n\r\n  function buildHuffmanTable(codeLengths, values) {\r\n    var k = 0, code = [], i, j, length = 16;\r\n    while (length > 0 && !codeLengths[length - 1]) {\r\n      length--;\r\n    }\r\n    code.push({children: [], index: 0});\r\n    var p = code[0], q;\r\n    for (i = 0; i < length; i++) {\r\n      for (j = 0; j < codeLengths[i]; j++) {\r\n        p = code.pop();\r\n        p.children[p.index] = values[k];\r\n        while (p.index > 0) {\r\n          p = code.pop();\r\n        }\r\n        p.index++;\r\n        code.push(p);\r\n        while (code.length <= i) {\r\n          code.push(q = {children: [], index: 0});\r\n          p.children[p.index] = q.children;\r\n          p = q;\r\n        }\r\n        k++;\r\n      }\r\n      if (i + 1 < length) {\r\n        // p here points to last code\r\n        code.push(q = {children: [], index: 0});\r\n        p.children[p.index] = q.children;\r\n        p = q;\r\n      }\r\n    }\r\n    return code[0].children;\r\n  }\r\n\r\n  function getBlockBufferOffset(component, row, col) {\r\n    return 64 * ((component.blocksPerLine + 1) * row + col);\r\n  }\r\n\r\n  function decodeScan(data, offset, frame, components, resetInterval,\r\n                      spectralStart, spectralEnd, successivePrev, successive) {\r\n    var precision = frame.precision;\r\n    var samplesPerLine = frame.samplesPerLine;\r\n    var scanLines = frame.scanLines;\r\n    var mcusPerLine = frame.mcusPerLine;\r\n    var progressive = frame.progressive;\r\n    var maxH = frame.maxH, maxV = frame.maxV;\r\n\r\n    var startOffset = offset, bitsData = 0, bitsCount = 0;\r\n\r\n    function readBit() {\r\n      if (bitsCount > 0) {\r\n        bitsCount--;\r\n        return (bitsData >> bitsCount) & 1;\r\n      }\r\n      bitsData = data[offset++];\r\n      if (bitsData === 0xFF) {\r\n        var nextByte = data[offset++];\r\n        if (nextByte) {\r\n          throw 'unexpected marker: ' +\r\n            ((bitsData << 8) | nextByte).toString(16);\r\n        }\r\n        // unstuff 0\r\n      }\r\n      bitsCount = 7;\r\n      return bitsData >>> 7;\r\n    }\r\n\r\n    function decodeHuffman(tree) {\r\n      var node = tree;\r\n      while (true) {\r\n        node = node[readBit()];\r\n        if (typeof node === 'number') {\r\n          return node;\r\n        }\r\n        if (typeof node !== 'object') {\r\n          throw 'invalid huffman sequence';\r\n        }\r\n      }\r\n    }\r\n\r\n    function receive(length) {\r\n      var n = 0;\r\n      while (length > 0) {\r\n        n = (n << 1) | readBit();\r\n        length--;\r\n      }\r\n      return n;\r\n    }\r\n\r\n    function receiveAndExtend(length) {\r\n      if (length === 1) {\r\n        return readBit() === 1 ? 1 : -1;\r\n      }\r\n      var n = receive(length);\r\n      if (n >= 1 << (length - 1)) {\r\n        return n;\r\n      }\r\n      return n + (-1 << length) + 1;\r\n    }\r\n\r\n    function decodeBaseline(component, offset) {\r\n      var t = decodeHuffman(component.huffmanTableDC);\r\n      var diff = t === 0 ? 0 : receiveAndExtend(t);\r\n      component.blockData[offset] = (component.pred += diff);\r\n      var k = 1;\r\n      while (k < 64) {\r\n        var rs = decodeHuffman(component.huffmanTableAC);\r\n        var s = rs & 15, r = rs >> 4;\r\n        if (s === 0) {\r\n          if (r < 15) {\r\n            break;\r\n          }\r\n          k += 16;\r\n          continue;\r\n        }\r\n        k += r;\r\n        var z = dctZigZag[k];\r\n        component.blockData[offset + z] = receiveAndExtend(s);\r\n        k++;\r\n      }\r\n    }\r\n\r\n    function decodeDCFirst(component, offset) {\r\n      var t = decodeHuffman(component.huffmanTableDC);\r\n      var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\r\n      component.blockData[offset] = (component.pred += diff);\r\n    }\r\n\r\n    function decodeDCSuccessive(component, offset) {\r\n      component.blockData[offset] |= readBit() << successive;\r\n    }\r\n\r\n    var eobrun = 0;\r\n    function decodeACFirst(component, offset) {\r\n      if (eobrun > 0) {\r\n        eobrun--;\r\n        return;\r\n      }\r\n      var k = spectralStart, e = spectralEnd;\r\n      while (k <= e) {\r\n        var rs = decodeHuffman(component.huffmanTableAC);\r\n        var s = rs & 15, r = rs >> 4;\r\n        if (s === 0) {\r\n          if (r < 15) {\r\n            eobrun = receive(r) + (1 << r) - 1;\r\n            break;\r\n          }\r\n          k += 16;\r\n          continue;\r\n        }\r\n        k += r;\r\n        var z = dctZigZag[k];\r\n        component.blockData[offset + z] =\r\n          receiveAndExtend(s) * (1 << successive);\r\n        k++;\r\n      }\r\n    }\r\n\r\n    var successiveACState = 0, successiveACNextValue;\r\n    function decodeACSuccessive(component, offset) {\r\n      var k = spectralStart;\r\n      var e = spectralEnd;\r\n      var r = 0;\r\n      var s;\r\n      var rs;\r\n      while (k <= e) {\r\n        var z = dctZigZag[k];\r\n        switch (successiveACState) {\r\n        case 0: // initial state\r\n          rs = decodeHuffman(component.huffmanTableAC);\r\n          s = rs & 15;\r\n          r = rs >> 4;\r\n          if (s === 0) {\r\n            if (r < 15) {\r\n              eobrun = receive(r) + (1 << r);\r\n              successiveACState = 4;\r\n            } else {\r\n              r = 16;\r\n              successiveACState = 1;\r\n            }\r\n          } else {\r\n            if (s !== 1) {\r\n              throw 'invalid ACn encoding';\r\n            }\r\n            successiveACNextValue = receiveAndExtend(s);\r\n            successiveACState = r ? 2 : 3;\r\n          }\r\n          continue;\r\n        case 1: // skipping r zero items\r\n        case 2:\r\n          if (component.blockData[offset + z]) {\r\n            component.blockData[offset + z] += (readBit() << successive);\r\n          } else {\r\n            r--;\r\n            if (r === 0) {\r\n              successiveACState = successiveACState === 2 ? 3 : 0;\r\n            }\r\n          }\r\n          break;\r\n        case 3: // set value for a zero item\r\n          if (component.blockData[offset + z]) {\r\n            component.blockData[offset + z] += (readBit() << successive);\r\n          } else {\r\n            component.blockData[offset + z] =\r\n              successiveACNextValue << successive;\r\n            successiveACState = 0;\r\n          }\r\n          break;\r\n        case 4: // eob\r\n          if (component.blockData[offset + z]) {\r\n            component.blockData[offset + z] += (readBit() << successive);\r\n          }\r\n          break;\r\n        }\r\n        k++;\r\n      }\r\n      if (successiveACState === 4) {\r\n        eobrun--;\r\n        if (eobrun === 0) {\r\n          successiveACState = 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    function decodeMcu(component, decode, mcu, row, col) {\r\n      var mcuRow = (mcu / mcusPerLine) | 0;\r\n      var mcuCol = mcu % mcusPerLine;\r\n      var blockRow = mcuRow * component.v + row;\r\n      var blockCol = mcuCol * component.h + col;\r\n      var offset = getBlockBufferOffset(component, blockRow, blockCol);\r\n      decode(component, offset);\r\n    }\r\n\r\n    function decodeBlock(component, decode, mcu) {\r\n      var blockRow = (mcu / component.blocksPerLine) | 0;\r\n      var blockCol = mcu % component.blocksPerLine;\r\n      var offset = getBlockBufferOffset(component, blockRow, blockCol);\r\n      decode(component, offset);\r\n    }\r\n\r\n    var componentsLength = components.length;\r\n    var component, i, j, k, n;\r\n    var decodeFn;\r\n    if (progressive) {\r\n      if (spectralStart === 0) {\r\n        decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\r\n      } else {\r\n        decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\r\n      }\r\n    } else {\r\n      decodeFn = decodeBaseline;\r\n    }\r\n\r\n    var mcu = 0, marker;\r\n    var mcuExpected;\r\n    if (componentsLength === 1) {\r\n      mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\r\n    } else {\r\n      mcuExpected = mcusPerLine * frame.mcusPerColumn;\r\n    }\r\n    if (!resetInterval) {\r\n      resetInterval = mcuExpected;\r\n    }\r\n\r\n    var h, v;\r\n    while (mcu < mcuExpected) {\r\n      // reset interval stuff\r\n      for (i = 0; i < componentsLength; i++) {\r\n        components[i].pred = 0;\r\n      }\r\n      eobrun = 0;\r\n\r\n      if (componentsLength === 1) {\r\n        component = components[0];\r\n        for (n = 0; n < resetInterval; n++) {\r\n          decodeBlock(component, decodeFn, mcu);\r\n          mcu++;\r\n        }\r\n      } else {\r\n        for (n = 0; n < resetInterval; n++) {\r\n          for (i = 0; i < componentsLength; i++) {\r\n            component = components[i];\r\n            h = component.h;\r\n            v = component.v;\r\n            for (j = 0; j < v; j++) {\r\n              for (k = 0; k < h; k++) {\r\n                decodeMcu(component, decodeFn, mcu, j, k);\r\n              }\r\n            }\r\n          }\r\n          mcu++;\r\n        }\r\n      }\r\n\r\n      // find marker\r\n      bitsCount = 0;\r\n      marker = (data[offset] << 8) | data[offset + 1];\r\n      if (marker <= 0xFF00) {\r\n        throw 'marker was not found';\r\n      }\r\n\r\n      if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\r\n        offset += 2;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return offset - startOffset;\r\n  }\r\n\r\n  // A port of poppler's IDCT method which in turn is taken from:\r\n  //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\r\n  //   'Practical Fast 1-D DCT Algorithms with 11 Multiplications',\r\n  //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\r\n  //   988-991.\r\n  function quantizeAndInverse(component, blockBufferOffset, p) {\r\n    var qt = component.quantizationTable, blockData = component.blockData;\r\n    var v0, v1, v2, v3, v4, v5, v6, v7;\r\n    var p0, p1, p2, p3, p4, p5, p6, p7;\r\n    var t;\r\n\r\n    // inverse DCT on rows\r\n    for (var row = 0; row < 64; row += 8) {\r\n      // gather block data\r\n      p0 = blockData[blockBufferOffset + row];\r\n      p1 = blockData[blockBufferOffset + row + 1];\r\n      p2 = blockData[blockBufferOffset + row + 2];\r\n      p3 = blockData[blockBufferOffset + row + 3];\r\n      p4 = blockData[blockBufferOffset + row + 4];\r\n      p5 = blockData[blockBufferOffset + row + 5];\r\n      p6 = blockData[blockBufferOffset + row + 6];\r\n      p7 = blockData[blockBufferOffset + row + 7];\r\n\r\n      // dequant p0\r\n      p0 *= qt[row];\r\n\r\n      // check for all-zero AC coefficients\r\n      if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {\r\n        t = (dctSqrt2 * p0 + 512) >> 10;\r\n        p[row] = t;\r\n        p[row + 1] = t;\r\n        p[row + 2] = t;\r\n        p[row + 3] = t;\r\n        p[row + 4] = t;\r\n        p[row + 5] = t;\r\n        p[row + 6] = t;\r\n        p[row + 7] = t;\r\n        continue;\r\n      }\r\n      // dequant p1 ... p7\r\n      p1 *= qt[row + 1];\r\n      p2 *= qt[row + 2];\r\n      p3 *= qt[row + 3];\r\n      p4 *= qt[row + 4];\r\n      p5 *= qt[row + 5];\r\n      p6 *= qt[row + 6];\r\n      p7 *= qt[row + 7];\r\n\r\n      // stage 4\r\n      v0 = (dctSqrt2 * p0 + 128) >> 8;\r\n      v1 = (dctSqrt2 * p4 + 128) >> 8;\r\n      v2 = p2;\r\n      v3 = p6;\r\n      v4 = (dctSqrt1d2 * (p1 - p7) + 128) >> 8;\r\n      v7 = (dctSqrt1d2 * (p1 + p7) + 128) >> 8;\r\n      v5 = p3 << 4;\r\n      v6 = p5 << 4;\r\n\r\n      // stage 3\r\n      v0 = (v0 + v1 + 1) >> 1;\r\n      v1 = v0 - v1;\r\n      t  = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;\r\n      v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;\r\n      v3 = t;\r\n      v4 = (v4 + v6 + 1) >> 1;\r\n      v6 = v4 - v6;\r\n      v7 = (v7 + v5 + 1) >> 1;\r\n      v5 = v7 - v5;\r\n\r\n      // stage 2\r\n      v0 = (v0 + v3 + 1) >> 1;\r\n      v3 = v0 - v3;\r\n      v1 = (v1 + v2 + 1) >> 1;\r\n      v2 = v1 - v2;\r\n      t  = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\r\n      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\r\n      v7 = t;\r\n      t  = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\r\n      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\r\n      v6 = t;\r\n\r\n      // stage 1\r\n      p[row] = v0 + v7;\r\n      p[row + 7] = v0 - v7;\r\n      p[row + 1] = v1 + v6;\r\n      p[row + 6] = v1 - v6;\r\n      p[row + 2] = v2 + v5;\r\n      p[row + 5] = v2 - v5;\r\n      p[row + 3] = v3 + v4;\r\n      p[row + 4] = v3 - v4;\r\n    }\r\n\r\n    // inverse DCT on columns\r\n    for (var col = 0; col < 8; ++col) {\r\n      p0 = p[col];\r\n      p1 = p[col +  8];\r\n      p2 = p[col + 16];\r\n      p3 = p[col + 24];\r\n      p4 = p[col + 32];\r\n      p5 = p[col + 40];\r\n      p6 = p[col + 48];\r\n      p7 = p[col + 56];\r\n\r\n      // check for all-zero AC coefficients\r\n      if ((p1 | p2 | p3 | p4 | p5 | p6 | p7) === 0) {\r\n        t = (dctSqrt2 * p0 + 8192) >> 14;\r\n        // convert to 8 bit\r\n        t = (t < -2040) ? 0 : (t >= 2024) ? 255 : (t + 2056) >> 4;\r\n        blockData[blockBufferOffset + col] = t;\r\n        blockData[blockBufferOffset + col +  8] = t;\r\n        blockData[blockBufferOffset + col + 16] = t;\r\n        blockData[blockBufferOffset + col + 24] = t;\r\n        blockData[blockBufferOffset + col + 32] = t;\r\n        blockData[blockBufferOffset + col + 40] = t;\r\n        blockData[blockBufferOffset + col + 48] = t;\r\n        blockData[blockBufferOffset + col + 56] = t;\r\n        continue;\r\n      }\r\n\r\n      // stage 4\r\n      v0 = (dctSqrt2 * p0 + 2048) >> 12;\r\n      v1 = (dctSqrt2 * p4 + 2048) >> 12;\r\n      v2 = p2;\r\n      v3 = p6;\r\n      v4 = (dctSqrt1d2 * (p1 - p7) + 2048) >> 12;\r\n      v7 = (dctSqrt1d2 * (p1 + p7) + 2048) >> 12;\r\n      v5 = p3;\r\n      v6 = p5;\r\n\r\n      // stage 3\r\n      // Shift v0 by 128.5 << 5 here, so we don't need to shift p0...p7 when\r\n      // converting to UInt8 range later.\r\n      v0 = ((v0 + v1 + 1) >> 1) + 4112;\r\n      v1 = v0 - v1;\r\n      t  = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;\r\n      v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;\r\n      v3 = t;\r\n      v4 = (v4 + v6 + 1) >> 1;\r\n      v6 = v4 - v6;\r\n      v7 = (v7 + v5 + 1) >> 1;\r\n      v5 = v7 - v5;\r\n\r\n      // stage 2\r\n      v0 = (v0 + v3 + 1) >> 1;\r\n      v3 = v0 - v3;\r\n      v1 = (v1 + v2 + 1) >> 1;\r\n      v2 = v1 - v2;\r\n      t  = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\r\n      v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\r\n      v7 = t;\r\n      t  = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\r\n      v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\r\n      v6 = t;\r\n\r\n      // stage 1\r\n      p0 = v0 + v7;\r\n      p7 = v0 - v7;\r\n      p1 = v1 + v6;\r\n      p6 = v1 - v6;\r\n      p2 = v2 + v5;\r\n      p5 = v2 - v5;\r\n      p3 = v3 + v4;\r\n      p4 = v3 - v4;\r\n\r\n      // convert to 8-bit integers\r\n      p0 = (p0 < 16) ? 0 : (p0 >= 4080) ? 255 : p0 >> 4;\r\n      p1 = (p1 < 16) ? 0 : (p1 >= 4080) ? 255 : p1 >> 4;\r\n      p2 = (p2 < 16) ? 0 : (p2 >= 4080) ? 255 : p2 >> 4;\r\n      p3 = (p3 < 16) ? 0 : (p3 >= 4080) ? 255 : p3 >> 4;\r\n      p4 = (p4 < 16) ? 0 : (p4 >= 4080) ? 255 : p4 >> 4;\r\n      p5 = (p5 < 16) ? 0 : (p5 >= 4080) ? 255 : p5 >> 4;\r\n      p6 = (p6 < 16) ? 0 : (p6 >= 4080) ? 255 : p6 >> 4;\r\n      p7 = (p7 < 16) ? 0 : (p7 >= 4080) ? 255 : p7 >> 4;\r\n\r\n      // store block data\r\n      blockData[blockBufferOffset + col] = p0;\r\n      blockData[blockBufferOffset + col +  8] = p1;\r\n      blockData[blockBufferOffset + col + 16] = p2;\r\n      blockData[blockBufferOffset + col + 24] = p3;\r\n      blockData[blockBufferOffset + col + 32] = p4;\r\n      blockData[blockBufferOffset + col + 40] = p5;\r\n      blockData[blockBufferOffset + col + 48] = p6;\r\n      blockData[blockBufferOffset + col + 56] = p7;\r\n    }\r\n  }\r\n\r\n  function buildComponentData(frame, component) {\r\n    var blocksPerLine = component.blocksPerLine;\r\n    var blocksPerColumn = component.blocksPerColumn;\r\n    var computationBuffer = new Int16Array(64);\r\n\r\n    for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\r\n      for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\r\n        var offset = getBlockBufferOffset(component, blockRow, blockCol);\r\n        quantizeAndInverse(component, offset, computationBuffer);\r\n      }\r\n    }\r\n    return component.blockData;\r\n  }\r\n\r\n  function clamp0to255(a) {\r\n    return a <= 0 ? 0 : a >= 255 ? 255 : a;\r\n  }\r\n\r\n\r\n  var JpegImage = langx.klass({\r\n    parse: function parse(data) {\r\n\r\n      function readUint16() {\r\n        var value = (data[offset] << 8) | data[offset + 1];\r\n        offset += 2;\r\n        return value;\r\n      }\r\n\r\n      function readDataBlock() {\r\n        var length = readUint16();\r\n        var array = data.subarray(offset, offset + length - 2);\r\n        offset += array.length;\r\n        return array;\r\n      }\r\n\r\n      function prepareComponents(frame) {\r\n        var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);\r\n        var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);\r\n        for (var i = 0; i < frame.components.length; i++) {\r\n          component = frame.components[i];\r\n          var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) *\r\n                                        component.h / frame.maxH);\r\n          var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines  / 8) *\r\n                                          component.v / frame.maxV);\r\n          var blocksPerLineForMcu = mcusPerLine * component.h;\r\n          var blocksPerColumnForMcu = mcusPerColumn * component.v;\r\n\r\n          var blocksBufferSize = 64 * blocksPerColumnForMcu *\r\n                                      (blocksPerLineForMcu + 1);\r\n          component.blockData = new Int16Array(blocksBufferSize);\r\n          component.blocksPerLine = blocksPerLine;\r\n          component.blocksPerColumn = blocksPerColumn;\r\n        }\r\n        frame.mcusPerLine = mcusPerLine;\r\n        frame.mcusPerColumn = mcusPerColumn;\r\n      }\r\n\r\n      var offset = 0, length = data.length;\r\n      var jfif = null;\r\n      var adobe = null;\r\n      var pixels = null;\r\n      var frame, resetInterval;\r\n      var quantizationTables = [];\r\n      var huffmanTablesAC = [], huffmanTablesDC = [];\r\n      var fileMarker = readUint16();\r\n      if (fileMarker !== 0xFFD8) { // SOI (Start of Image)\r\n        throw 'SOI not found';\r\n      }\r\n\r\n      fileMarker = readUint16();\r\n      while (fileMarker !== 0xFFD9) { // EOI (End of image)\r\n        var i, j, l;\r\n        switch(fileMarker) {\r\n          case 0xFFE0: // APP0 (Application Specific)\r\n          case 0xFFE1: // APP1\r\n          case 0xFFE2: // APP2\r\n          case 0xFFE3: // APP3\r\n          case 0xFFE4: // APP4\r\n          case 0xFFE5: // APP5\r\n          case 0xFFE6: // APP6\r\n          case 0xFFE7: // APP7\r\n          case 0xFFE8: // APP8\r\n          case 0xFFE9: // APP9\r\n          case 0xFFEA: // APP10\r\n          case 0xFFEB: // APP11\r\n          case 0xFFEC: // APP12\r\n          case 0xFFED: // APP13\r\n          case 0xFFEE: // APP14\r\n          case 0xFFEF: // APP15\r\n          case 0xFFFE: // COM (Comment)\r\n            var appData = readDataBlock();\r\n\r\n            if (fileMarker === 0xFFE0) {\r\n              if (appData[0] === 0x4A && appData[1] === 0x46 &&\r\n                  appData[2] === 0x49 && appData[3] === 0x46 &&\r\n                  appData[4] === 0) { // 'JFIF\\x00'\r\n                jfif = {\r\n                  version: { major: appData[5], minor: appData[6] },\r\n                  densityUnits: appData[7],\r\n                  xDensity: (appData[8] << 8) | appData[9],\r\n                  yDensity: (appData[10] << 8) | appData[11],\r\n                  thumbWidth: appData[12],\r\n                  thumbHeight: appData[13],\r\n                  thumbData: appData.subarray(14, 14 +\r\n                                              3 * appData[12] * appData[13])\r\n                };\r\n              }\r\n            }\r\n            // TODO APP1 - Exif\r\n            if (fileMarker === 0xFFEE) {\r\n              if (appData[0] === 0x41 && appData[1] === 0x64 &&\r\n                  appData[2] === 0x6F && appData[3] === 0x62 &&\r\n                  appData[4] === 0x65) { // 'Adobe'\r\n                adobe = {\r\n                  version: (appData[5] << 8) | appData[6],\r\n                  flags0: (appData[7] << 8) | appData[8],\r\n                  flags1: (appData[9] << 8) | appData[10],\r\n                  transformCode: appData[11]\r\n                };\r\n              }\r\n            }\r\n            break;\r\n\r\n          case 0xFFDB: // DQT (Define Quantization Tables)\r\n            var quantizationTablesLength = readUint16();\r\n            var quantizationTablesEnd = quantizationTablesLength + offset - 2;\r\n            var z;\r\n            while (offset < quantizationTablesEnd) {\r\n              var quantizationTableSpec = data[offset++];\r\n              var tableData = new Uint16Array(64);\r\n              if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\r\n                for (j = 0; j < 64; j++) {\r\n                  z = dctZigZag[j];\r\n                  tableData[z] = data[offset++];\r\n                }\r\n              } else if ((quantizationTableSpec >> 4) === 1) { //16 bit\r\n                for (j = 0; j < 64; j++) {\r\n                  z = dctZigZag[j];\r\n                  tableData[z] = readUint16();\r\n                }\r\n              } else {\r\n                throw 'DQT: invalid table spec';\r\n              }\r\n              quantizationTables[quantizationTableSpec & 15] = tableData;\r\n            }\r\n            break;\r\n\r\n          case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\r\n          case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\r\n          case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)\r\n            if (frame) {\r\n              throw 'Only single frame JPEGs supported';\r\n            }\r\n            readUint16(); // skip data length\r\n            frame = {};\r\n            frame.extended = (fileMarker === 0xFFC1);\r\n            frame.progressive = (fileMarker === 0xFFC2);\r\n            frame.precision = data[offset++];\r\n            frame.scanLines = readUint16();\r\n            frame.samplesPerLine = readUint16();\r\n            frame.components = [];\r\n            frame.componentIds = {};\r\n            var componentsCount = data[offset++], componentId;\r\n            var maxH = 0, maxV = 0;\r\n            for (i = 0; i < componentsCount; i++) {\r\n              componentId = data[offset];\r\n              var h = data[offset + 1] >> 4;\r\n              var v = data[offset + 1] & 15;\r\n              if (maxH < h) {\r\n                maxH = h;\r\n              }\r\n              if (maxV < v) {\r\n                maxV = v;\r\n              }\r\n              var qId = data[offset + 2];\r\n              l = frame.components.push({\r\n                h: h,\r\n                v: v,\r\n                quantizationTable: quantizationTables[qId]\r\n              });\r\n              frame.componentIds[componentId] = l - 1;\r\n              offset += 3;\r\n            }\r\n            frame.maxH = maxH;\r\n            frame.maxV = maxV;\r\n            prepareComponents(frame);\r\n            break;\r\n\r\n          case 0xFFC4: // DHT (Define Huffman Tables)\r\n            var huffmanLength = readUint16();\r\n            for (i = 2; i < huffmanLength;) {\r\n              var huffmanTableSpec = data[offset++];\r\n              var codeLengths = new Uint8Array(16);\r\n              var codeLengthSum = 0;\r\n              for (j = 0; j < 16; j++, offset++) {\r\n                codeLengthSum += (codeLengths[j] = data[offset]);\r\n              }\r\n              var huffmanValues = new Uint8Array(codeLengthSum);\r\n              for (j = 0; j < codeLengthSum; j++, offset++) {\r\n                huffmanValues[j] = data[offset];\r\n              }\r\n              i += 17 + codeLengthSum;\r\n\r\n              ((huffmanTableSpec >> 4) === 0 ?\r\n                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =\r\n                buildHuffmanTable(codeLengths, huffmanValues);\r\n            }\r\n            break;\r\n\r\n          case 0xFFDD: // DRI (Define Restart Interval)\r\n            readUint16(); // skip data length\r\n            resetInterval = readUint16();\r\n            break;\r\n\r\n          case 0xFFDA: // SOS (Start of Scan)\r\n            var scanLength = readUint16();\r\n            var selectorsCount = data[offset++];\r\n            var components = [], component;\r\n            for (i = 0; i < selectorsCount; i++) {\r\n              var componentIndex = frame.componentIds[data[offset++]];\r\n              component = frame.components[componentIndex];\r\n              var tableSpec = data[offset++];\r\n              component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\r\n              component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\r\n              components.push(component);\r\n            }\r\n            var spectralStart = data[offset++];\r\n            var spectralEnd = data[offset++];\r\n            var successiveApproximation = data[offset++];\r\n            var processed = decodeScan(data, offset,\r\n              frame, components, resetInterval,\r\n              spectralStart, spectralEnd,\r\n              successiveApproximation >> 4, successiveApproximation & 15);\r\n            offset += processed;\r\n            break;\r\n\r\n          case 0xFFFF: // Fill bytes\r\n            if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\r\n              offset--;\r\n            }\r\n            break;\r\n\r\n          default:\r\n            if (data[offset - 3] === 0xFF &&\r\n                data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\r\n              // could be incorrect encoding -- last 0xFF byte of the previous\r\n              // block was eaten by the encoder\r\n              offset -= 3;\r\n              break;\r\n            }\r\n            throw 'unknown JPEG marker ' + fileMarker.toString(16);\r\n        }\r\n        fileMarker = readUint16();\r\n      }\r\n\r\n      this.width = frame.samplesPerLine;\r\n      this.height = frame.scanLines;\r\n      this.jfif = jfif;\r\n      this.adobe = adobe;\r\n      this.components = [];\r\n      for (i = 0; i < frame.components.length; i++) {\r\n        component = frame.components[i];\r\n        this.components.push({\r\n          output: buildComponentData(frame, component),\r\n          scaleX: component.h / frame.maxH,\r\n          scaleY: component.v / frame.maxV,\r\n          blocksPerLine: component.blocksPerLine,\r\n          blocksPerColumn: component.blocksPerColumn\r\n        });\r\n      }\r\n      this.numComponents = this.components.length;\r\n    },\r\n\r\n    _getLinearizedBlockData: function getLinearizedBlockData(width, height) {\r\n      var scaleX = this.width / width, scaleY = this.height / height;\r\n\r\n      var component, componentScaleX, componentScaleY, blocksPerScanline;\r\n      var x, y, i, j, k;\r\n      var index;\r\n      var offset = 0;\r\n      var output;\r\n      var numComponents = this.components.length;\r\n      var dataLength = width * height * numComponents;\r\n      var data = new Uint8Array(dataLength);\r\n      var xScaleBlockOffset = new Uint32Array(width);\r\n      var mask3LSB = 0xfffffff8; // used to clear the 3 LSBs\r\n\r\n      for (i = 0; i < numComponents; i++) {\r\n        component = this.components[i];\r\n        componentScaleX = component.scaleX * scaleX;\r\n        componentScaleY = component.scaleY * scaleY;\r\n        offset = i;\r\n        output = component.output;\r\n        blocksPerScanline = (component.blocksPerLine + 1) << 3;\r\n        // precalculate the xScaleBlockOffset\r\n        for (x = 0; x < width; x++) {\r\n          j = 0 | (x * componentScaleX);\r\n          xScaleBlockOffset[x] = ((j & mask3LSB) << 3) | (j & 7);\r\n        }\r\n        // linearize the blocks of the component\r\n        for (y = 0; y < height; y++) {\r\n          j = 0 | (y * componentScaleY);\r\n          index = blocksPerScanline * (j & mask3LSB) | ((j & 7) << 3);\r\n          for (x = 0; x < width; x++) {\r\n            data[offset] = output[index + xScaleBlockOffset[x]];\r\n            offset += numComponents;\r\n          }\r\n        }\r\n      }\r\n\r\n      // decodeTransform contains pairs of multiplier (-256..256) and additive\r\n      var transform = this.decodeTransform;\r\n      if (transform) {\r\n        for (i = 0; i < dataLength;) {\r\n          for (j = 0, k = 0; j < numComponents; j++, i++, k += 2) {\r\n            data[i] = ((data[i] * transform[k]) >> 8) + transform[k + 1];\r\n          }\r\n        }\r\n      }\r\n      return data;\r\n    },\r\n\r\n    _isColorConversionNeeded: function isColorConversionNeeded() {\r\n      if (this.adobe && this.adobe.transformCode) {\r\n        // The adobe transform marker overrides any previous setting\r\n        return true;\r\n      } else if (this.numComponents === 3) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    },\r\n\r\n    _convertYccToRgb: function convertYccToRgb(data) {\r\n      var Y, Cb, Cr;\r\n      for (var i = 0, length = data.length; i < length; i += 3) {\r\n        Y  = data[i    ];\r\n        Cb = data[i + 1];\r\n        Cr = data[i + 2];\r\n        data[i    ] = clamp0to255(Y - 179.456 + 1.402 * Cr);\r\n        data[i + 1] = clamp0to255(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);\r\n        data[i + 2] = clamp0to255(Y - 226.816 + 1.772 * Cb);\r\n      }\r\n      return data;\r\n    },\r\n\r\n    _convertYcckToRgb: function convertYcckToRgb(data) {\r\n      var Y, Cb, Cr, k;\r\n      var offset = 0;\r\n      for (var i = 0, length = data.length; i < length; i += 4) {\r\n        Y  = data[i];\r\n        Cb = data[i + 1];\r\n        Cr = data[i + 2];\r\n        k = data[i + 3];\r\n\r\n        var r = -122.67195406894 +\r\n          Cb * (-6.60635669420364e-5 * Cb + 0.000437130475926232 * Cr -\r\n                5.4080610064599e-5 * Y + 0.00048449797120281 * k -\r\n                0.154362151871126) +\r\n          Cr * (-0.000957964378445773 * Cr + 0.000817076911346625 * Y -\r\n                0.00477271405408747 * k + 1.53380253221734) +\r\n          Y * (0.000961250184130688 * Y - 0.00266257332283933 * k +\r\n               0.48357088451265) +\r\n          k * (-0.000336197177618394 * k + 0.484791561490776);\r\n\r\n        var g = 107.268039397724 +\r\n          Cb * (2.19927104525741e-5 * Cb - 0.000640992018297945 * Cr +\r\n                0.000659397001245577 * Y + 0.000426105652938837 * k -\r\n                0.176491792462875) +\r\n          Cr * (-0.000778269941513683 * Cr + 0.00130872261408275 * Y +\r\n                0.000770482631801132 * k - 0.151051492775562) +\r\n          Y * (0.00126935368114843 * Y - 0.00265090189010898 * k +\r\n               0.25802910206845) +\r\n          k * (-0.000318913117588328 * k - 0.213742400323665);\r\n\r\n        var b = -20.810012546947 +\r\n          Cb * (-0.000570115196973677 * Cb - 2.63409051004589e-5 * Cr +\r\n                0.0020741088115012 * Y - 0.00288260236853442 * k +\r\n                0.814272968359295) +\r\n          Cr * (-1.53496057440975e-5 * Cr - 0.000132689043961446 * Y +\r\n                0.000560833691242812 * k - 0.195152027534049) +\r\n          Y * (0.00174418132927582 * Y - 0.00255243321439347 * k +\r\n               0.116935020465145) +\r\n          k * (-0.000343531996510555 * k + 0.24165260232407);\r\n\r\n        data[offset++] = clamp0to255(r);\r\n        data[offset++] = clamp0to255(g);\r\n        data[offset++] = clamp0to255(b);\r\n      }\r\n      return data;\r\n    },\r\n\r\n    _convertYcckToCmyk: function convertYcckToCmyk(data) {\r\n      var Y, Cb, Cr;\r\n      for (var i = 0, length = data.length; i < length; i += 4) {\r\n        Y  = data[i];\r\n        Cb = data[i + 1];\r\n        Cr = data[i + 2];\r\n        data[i    ] = clamp0to255(434.456 - Y - 1.402 * Cr);\r\n        data[i + 1] = clamp0to255(119.541 - Y + 0.344 * Cb + 0.714 * Cr);\r\n        data[i + 2] = clamp0to255(481.816 - Y - 1.772 * Cb);\r\n        // K in data[i + 3] is unchanged\r\n      }\r\n      return data;\r\n    },\r\n\r\n    _convertCmykToRgb: function convertCmykToRgb(data) {\r\n      var c, m, y, k;\r\n      var offset = 0;\r\n      var min = -255 * 255 * 255;\r\n      var scale = 1 / 255 / 255;\r\n      for (var i = 0, length = data.length; i < length; i += 4) {\r\n        c = data[i];\r\n        m = data[i + 1];\r\n        y = data[i + 2];\r\n        k = data[i + 3];\r\n\r\n        var r =\r\n          c * (-4.387332384609988 * c + 54.48615194189176 * m +\r\n               18.82290502165302 * y + 212.25662451639585 * k -\r\n               72734.4411664936) +\r\n          m * (1.7149763477362134 * m - 5.6096736904047315 * y -\r\n               17.873870861415444 * k - 1401.7366389350734) +\r\n          y * (-2.5217340131683033 * y - 21.248923337353073 * k +\r\n               4465.541406466231) -\r\n          k * (21.86122147463605 * k + 48317.86113160301);\r\n        var g =\r\n          c * (8.841041422036149 * c + 60.118027045597366 * m +\r\n               6.871425592049007 * y + 31.159100130055922 * k -\r\n               20220.756542821975) +\r\n          m * (-15.310361306967817 * m + 17.575251261109482 * y +\r\n               131.35250912493976 * k - 48691.05921601825) +\r\n          y * (4.444339102852739 * y + 9.8632861493405 * k -\r\n               6341.191035517494) -\r\n          k * (20.737325471181034 * k + 47890.15695978492);\r\n        var b =\r\n          c * (0.8842522430003296 * c + 8.078677503112928 * m +\r\n               30.89978309703729 * y - 0.23883238689178934 * k -\r\n               3616.812083916688) +\r\n          m * (10.49593273432072 * m + 63.02378494754052 * y +\r\n               50.606957656360734 * k - 28620.90484698408) +\r\n          y * (0.03296041114873217 * y + 115.60384449646641 * k -\r\n               49363.43385999684) -\r\n          k * (22.33816807309886 * k + 45932.16563550634);\r\n\r\n        data[offset++] = r >= 0 ? 255 : r <= min ? 0 : 255 + r * scale | 0;\r\n        data[offset++] = g >= 0 ? 255 : g <= min ? 0 : 255 + g * scale | 0;\r\n        data[offset++] = b >= 0 ? 255 : b <= min ? 0 : 255 + b * scale | 0;\r\n      }\r\n      return data;\r\n    },\r\n\r\n    getData: function getData(width, height, forceRGBoutput) {\r\n      if (this.numComponents > 4) {\r\n        throw 'Unsupported color mode';\r\n      }\r\n      // type of data: Uint8Array(width * height * numComponents)\r\n      var data = this._getLinearizedBlockData(width, height);\r\n\r\n      if (this.numComponents === 3) {\r\n        return this._convertYccToRgb(data);\r\n      } else if (this.numComponents === 4) {\r\n        if (this._isColorConversionNeeded()) {\r\n          if (forceRGBoutput) {\r\n            return this._convertYcckToRgb(data);\r\n          } else {\r\n            return this._convertYcckToCmyk(data);\r\n          }\r\n        } else if (forceRGBoutput) {\r\n          return this._convertCmykToRgb(data);\r\n        }\r\n      }\r\n      return data;\r\n    }\r\n  });\r\n\r\n  function isAdobeImage(bytes) {\r\n      var maxBytesScanned = Math.max(bytes.length - 16, 1024);\r\n      // Looking for APP14, 'Adobe'\r\n      for (var i = 0; i < maxBytesScanned; ++i) {\r\n          if (bytes[i] == 0xFF && bytes[i + 1] == 0xEE &&\r\n              bytes[i + 2] == 0x00 && bytes[i + 3] == 0x0E &&\r\n              bytes[i + 4] == 0x41 && bytes[i + 5] == 0x64 &&\r\n              bytes[i + 6] == 0x6F && bytes[i + 7] == 0x62 &&\r\n              bytes[i + 8] == 0x65 && bytes[i + 9] == 0x00)\r\n              return true;\r\n          // scanning until frame tag\r\n          if (bytes[i] == 0xFF && bytes[i + 1] == 0xC0)\r\n              break;\r\n      }\r\n      return false;\r\n  }\r\n\r\n  function fixAdobeImage(bytes) {\r\n      // Inserting 'EMBED' marker after JPEG signature\r\n      var embedMarker = new Uint8Array([0xFF, 0xEC, 0, 8, 0x45, 0x4D, 0x42, 0x45,\r\n          0x44, 0\r\n      ]);\r\n      var newBytes = new Uint8Array(bytes.length + embedMarker.length);\r\n      newBytes.set(bytes, embedMarker.length);\r\n      // copy JPEG header\r\n      newBytes[0] = bytes[0];\r\n      newBytes[1] = bytes[1];\r\n      newBytes.set(embedMarker, 2);\r\n      return newBytes;\r\n  }\r\n\r\n  var JpegStream = DecodeStream.inherit({\r\n      klassName : \"JpegStream\",\r\n\r\n      init : function(bytes, dict, xref) {\r\n        // TODO: per poppler, some images may have 'junk' before that\r\n        // need to be removed\r\n        this.dict = dict;\r\n\r\n        this.isAdobeImage = false;\r\n        this.colorTransform = dict.get('ColorTransform') || -1;\r\n\r\n        if (isAdobeImage(bytes)) {\r\n            this.isAdobeImage = true;\r\n            bytes = fixAdobeImage(bytes);\r\n        }\r\n\r\n        this.bytes = bytes;\r\n\r\n          this.overrided();          \r\n      },\r\n\r\n      ensureBuffer : function(req) {\r\n          if (this.bufferLength)\r\n              return;\r\n          try {\r\n              var jpegImage = new JpegImage();\r\n              if (this.colorTransform != -1)\r\n                  jpegImage.colorTransform = this.colorTransform;\r\n              jpegImage.parse(this.bytes);\r\n              var width = jpegImage.width;\r\n              var height = jpegImage.height;\r\n              var data = jpegImage.getData(width, height);\r\n              this.buffer = data;\r\n              this.bufferLength = data.length;\r\n          } catch (e) {\r\n              error('JPEG error: ' + e);\r\n          }\r\n      },\r\n\r\n      getIR : function () {\r\n          return bytesToString(this.bytes);\r\n      },\r\n\r\n      getChar : function () {\r\n          error('internal error: getChar is not valid on JpegStream');\r\n      },\r\n\r\n      /**\r\n       * Checks if the image can be decoded and displayed by the browser without any\r\n       * further processing such as color space conversions.\r\n       */\r\n      isNativelySupported : function(xref, res) {\r\n              var cs = ColorSpace.parse(this.dict.get('ColorSpace', 'CS'), xref, res);\r\n              // when bug 674619 lands, let's check if browser can do\r\n              // normal cmyk and then we won't need to decode in JS\r\n              if (cs.name === 'DeviceGray' || cs.name === 'DeviceRGB')\r\n                  return true;\r\n              if (cs.name === 'DeviceCMYK' && !this.isAdobeImage &&\r\n                  this.colorTransform < 1)\r\n                  return true;\r\n              return false;\r\n      },\r\n\r\n      /**\r\n       * Checks if the image can be decoded by the browser.\r\n       */\r\n      isNativelyDecodable : function(xref, res) {\r\n              var cs = ColorSpace.parse(this.dict.get('ColorSpace', 'CS'), xref, res);\r\n              var numComps = cs.numComps;\r\n              if (numComps == 1 || numComps == 3)\r\n                  return true;\r\n\r\n              return false;\r\n      }\r\n\r\n  });\r\n\r\n\r\n  return codec.jpeg = {\r\n    \"JpegImage\" :JpegImage,\r\n    \"JpegStream\" : JpegStream\r\n  };\r\n\r\n});\ndefine('skylark-utils-codec/jpx',[\n  \"skylark-langx/langx\",\n  \"skylark-utils-stream/DecodeStream\",\n  \"./codec\"\n],function(langx,DecodeStream,codec){\n  'use strict';\n\nvar JpxImage = (function JpxImageClosure() {\n  // Table E.1\n  var SubbandsGainLog2 = {\n    'LL': 0,\n    'LH': 1,\n    'HL': 1,\n    'HH': 2\n  };\n  function JpxImage() {\n    this.failOnCorruptedImage = false;\n  }\n  JpxImage.prototype = {\n    load: function JpxImage_load(url) {\n      var xhr = new XMLHttpRequest();\n      xhr.open('GET', url, true);\n      xhr.responseType = 'arraybuffer';\n      xhr.onload = (function() {\n        // TODO catch parse error\n        var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);\n        this.parse(data);\n        if (this.onload)\n          this.onload();\n      }).bind(this);\n      xhr.send(null);\n    },\n    parse: function JpxImage_parse(data) {\n      function readUint(data, offset, bytes) {\n        var n = 0;\n        for (var i = 0; i < bytes; i++)\n          n = n * 256 + (data[offset + i] & 0xFF);\n        return n;\n      }\n      var position = 0, length = data.length;\n      while (position < length) {\n        var headerSize = 8;\n        var lbox = readUint(data, position, 4);\n        var tbox = readUint(data, position + 4, 4);\n        position += headerSize;\n        if (lbox == 1) {\n          lbox = readUint(data, position, 8);\n          position += 8;\n          headerSize += 8;\n        }\n        if (lbox === 0)\n          lbox = length - position + headerSize;\n        if (lbox < headerSize)\n          error('JPX error: Invalid box field size');\n        var dataLength = lbox - headerSize;\n        var jumpDataLength = true;\n        switch (tbox) {\n          case 0x6A501A1A: // 'jP\\032\\032'\n            // TODO\n            break;\n          case 0x6A703268: // 'jp2h'\n            jumpDataLength = false; // parsing child boxes\n            break;\n          case 0x636F6C72: // 'colr'\n            // TODO\n            break;\n          case 0x6A703263: // 'jp2c'\n            this.parseCodestream(data, position, position + dataLength);\n            break;\n        }\n        if (jumpDataLength)\n          position += dataLength;\n      }\n    },\n    parseCodestream: function JpxImage_parseCodestream(data, start, end) {\n      var context = {};\n      try {\n        var position = start;\n        while (position < end) {\n          var code = readUint16(data, position);\n          position += 2;\n\n          var length = 0, j;\n          switch (code) {\n            case 0xFF4F: // Start of codestream (SOC)\n              context.mainHeader = true;\n              break;\n            case 0xFFD9: // End of codestream (EOC)\n              break;\n            case 0xFF51: // Image and tile size (SIZ)\n              length = readUint16(data, position);\n              var siz = {};\n              siz.Xsiz = readUint32(data, position + 4);\n              siz.Ysiz = readUint32(data, position + 8);\n              siz.XOsiz = readUint32(data, position + 12);\n              siz.YOsiz = readUint32(data, position + 16);\n              siz.XTsiz = readUint32(data, position + 20);\n              siz.YTsiz = readUint32(data, position + 24);\n              siz.XTOsiz = readUint32(data, position + 28);\n              siz.YTOsiz = readUint32(data, position + 32);\n              var componentsCount = readUint16(data, position + 36);\n              siz.Csiz = componentsCount;\n              var components = [];\n              j = position + 38;\n              for (var i = 0; i < componentsCount; i++) {\n                var component = {\n                  precision: (data[j] & 0x7F) + 1,\n                  isSigned: !!(data[j] & 0x80),\n                  XRsiz: data[j + 1],\n                  YRsiz: data[j + 1]\n                };\n                calculateComponentDimensions(component, siz);\n                components.push(component);\n              }\n              context.SIZ = siz;\n              context.components = components;\n              calculateTileGrids(context, components);\n              context.QCC = [];\n              context.COC = [];\n              break;\n            case 0xFF5C: // Quantization default (QCD)\n              length = readUint16(data, position);\n              var qcd = {};\n              j = position + 2;\n              var sqcd = data[j++];\n              var spqcdSize, scalarExpounded;\n              switch (sqcd & 0x1F) {\n                case 0:\n                  spqcdSize = 8;\n                  scalarExpounded = true;\n                  break;\n                case 1:\n                  spqcdSize = 16;\n                  scalarExpounded = false;\n                  break;\n                case 2:\n                  spqcdSize = 16;\n                  scalarExpounded = true;\n                  break;\n                default:\n                  throw 'Invalid SQcd value ' + sqcd;\n              }\n              qcd.noQuantization = spqcdSize == 8;\n              qcd.scalarExpounded = scalarExpounded;\n              qcd.guardBits = sqcd >> 5;\n              var spqcds = [];\n              while (j < length + position) {\n                var spqcd = {};\n                if (spqcdSize == 8) {\n                  spqcd.epsilon = data[j++] >> 3;\n                  spqcd.mu = 0;\n                } else {\n                  spqcd.epsilon = data[j] >> 3;\n                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];\n                  j += 2;\n                }\n                spqcds.push(spqcd);\n              }\n              qcd.SPqcds = spqcds;\n              if (context.mainHeader)\n                context.QCD = qcd;\n              else {\n                context.currentTile.QCD = qcd;\n                context.currentTile.QCC = [];\n              }\n              break;\n            case 0xFF5D: // Quantization component (QCC)\n              length = readUint16(data, position);\n              var qcc = {};\n              j = position + 2;\n              var cqcc;\n              if (context.SIZ.Csiz < 257)\n                cqcc = data[j++];\n              else {\n                cqcc = readUint16(data, j);\n                j += 2;\n              }\n              var sqcd = data[j++];\n              var spqcdSize, scalarExpounded;\n              switch (sqcd & 0x1F) {\n                case 0:\n                  spqcdSize = 8;\n                  scalarExpounded = true;\n                  break;\n                case 1:\n                  spqcdSize = 16;\n                  scalarExpounded = false;\n                  break;\n                case 2:\n                  spqcdSize = 16;\n                  scalarExpounded = true;\n                  break;\n                default:\n                  throw 'Invalid SQcd value ' + sqcd;\n              }\n              qcc.noQuantization = spqcdSize == 8;\n              qcc.scalarExpounded = scalarExpounded;\n              qcc.guardBits = sqcd >> 5;\n              var spqcds = [];\n              while (j < length + position) {\n                var spqcd = {};\n                if (spqcdSize == 8) {\n                  spqcd.epsilon = data[j++] >> 3;\n                  spqcd.mu = 0;\n                } else {\n                  spqcd.epsilon = data[j] >> 3;\n                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];\n                  j += 2;\n                }\n                spqcds.push(spqcd);\n              }\n              qcc.SPqcds = spqcds;\n              if (context.mainHeader)\n                context.QCC[cqcc] = qcc;\n              else\n                context.currentTile.QCC[cqcc] = qcc;\n              break;\n            case 0xFF52: // Coding style default (COD)\n              length = readUint16(data, position);\n              var cod = {};\n              j = position + 2;\n              var scod = data[j++];\n              cod.entropyCoderWithCustomPrecincts = !!(scod & 1);\n              cod.sopMarkerUsed = !!(scod & 2);\n              cod.ephMarkerUsed = !!(scod & 4);\n              var codingStyle = {};\n              cod.progressionOrder = data[j++];\n              cod.layersCount = readUint16(data, j);\n              j += 2;\n              cod.multipleComponentTransform = data[j++];\n\n              cod.decompositionLevelsCount = data[j++];\n              cod.xcb = (data[j++] & 0xF) + 2;\n              cod.ycb = (data[j++] & 0xF) + 2;\n              var blockStyle = data[j++];\n              cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);\n              cod.resetContextProbabilities = !!(blockStyle & 2);\n              cod.terminationOnEachCodingPass = !!(blockStyle & 4);\n              cod.verticalyStripe = !!(blockStyle & 8);\n              cod.predictableTermination = !!(blockStyle & 16);\n              cod.segmentationSymbolUsed = !!(blockStyle & 32);\n              cod.transformation = data[j++];\n              if (cod.entropyCoderWithCustomPrecincts) {\n                var precinctsSizes = {};\n                while (j < length + position) {\n                  var precinctsSize = data[j];\n                  precinctsSizes.push({\n                    PPx: precinctsSize & 0xF,\n                    PPy: precinctsSize >> 4\n                  });\n                }\n                cod.precinctsSizes = precinctsSizes;\n              }\n\n              if (cod.sopMarkerUsed || cod.ephMarkerUsed ||\n                  cod.selectiveArithmeticCodingBypass ||\n                  cod.resetContextProbabilities ||\n                  cod.terminationOnEachCodingPass ||\n                  cod.verticalyStripe || cod.predictableTermination)\n                throw 'Unsupported COD options: ' +\n                  globalScope.JSON.stringify(cod);\n\n              if (context.mainHeader)\n                context.COD = cod;\n              else {\n                context.currentTile.COD = cod;\n                context.currentTile.COC = [];\n              }\n              break;\n            case 0xFF90: // Start of tile-part (SOT)\n              length = readUint16(data, position);\n              var tile = {};\n              tile.index = readUint16(data, position + 2);\n              tile.length = readUint32(data, position + 4);\n              tile.dataEnd = tile.length + position - 2;\n              tile.partIndex = data[position + 8];\n              tile.partsCount = data[position + 9];\n\n              context.mainHeader = false;\n              if (tile.partIndex === 0) {\n                // reset component specific settings\n                tile.COD = context.COD;\n                tile.COC = context.COC.slice(0); // clone of the global COC\n                tile.QCD = context.QCD;\n                tile.QCC = context.QCC.slice(0); // clone of the global COC\n              }\n              context.currentTile = tile;\n              break;\n            case 0xFF93: // Start of data (SOD)\n              var tile = context.currentTile;\n              if (tile.partIndex === 0) {\n                initializeTile(context, tile.index);\n                buildPackets(context);\n              }\n\n              // moving to the end of the data\n              length = tile.dataEnd - position;\n\n              parseTilePackets(context, data, position, length);\n              break;\n            case 0xFF64: // Comment (COM)\n              length = readUint16(data, position);\n              // skipping content\n              break;\n            default:\n              throw 'Unknown codestream code: ' + code.toString(16);\n          }\n          position += length;\n        }\n      } catch (e) {\n        if (this.failOnCorruptedImage)\n          error('JPX error: ' + e);\n        else\n          warn('JPX error: ' + e + '. Trying to recover');\n      }\n      this.tiles = transformComponents(context);\n      this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;\n      this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;\n      this.componentsCount = context.SIZ.Csiz;\n    }\n  };\n  function readUint32(data, offset) {\n    return (data[offset] << 24) | (data[offset + 1] << 16) |\n      (data[offset + 2] << 8) | data[offset + 3];\n  }\n  function readUint16(data, offset) {\n    return (data[offset] << 8) | data[offset + 1];\n  }\n  function log2(x) {\n    var n = 1, i = 0;\n    while (x > n) {\n      n <<= 1;\n      i++;\n    }\n    return i;\n  }\n  function calculateComponentDimensions(component, siz) {\n    // Section B.2 Component mapping\n    component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);\n    component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);\n    component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);\n    component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);\n    component.width = component.x1 - component.x0;\n    component.height = component.y1 - component.y0;\n  }\n  function calculateTileGrids(context, components) {\n    var siz = context.SIZ;\n    // Section B.3 Division into tile and tile-components\n    var tiles = [];\n    var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);\n    var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);\n    for (var q = 0; q < numYtiles; q++) {\n      for (var p = 0; p < numXtiles; p++) {\n        var tile = {};\n        tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);\n        tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);\n        tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);\n        tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);\n        tile.width = tile.tx1 - tile.tx0;\n        tile.height = tile.ty1 - tile.ty0;\n        tile.components = [];\n        tiles.push(tile);\n      }\n    }\n    context.tiles = tiles;\n\n    var componentsCount = siz.Csiz;\n    for (var i = 0, ii = componentsCount; i < ii; i++) {\n      var component = components[i];\n      var tileComponents = [];\n      for (var j = 0, jj = tiles.length; j < jj; j++) {\n        var tileComponent = {}, tile = tiles[j];\n        tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);\n        tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);\n        tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);\n        tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);\n        tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;\n        tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;\n        tile.components[i] = tileComponent;\n      }\n    }\n  }\n  function getBlocksDimensions(context, component, r) {\n    var codOrCoc = component.codingStyleParameters;\n    var result = {};\n    if (!codOrCoc.entropyCoderWithCustomPrecincts) {\n      result.PPx = 15;\n      result.PPy = 15;\n    } else {\n      result.PPx = codOrCoc.precinctsSizes[r].PPx;\n      result.PPy = codOrCoc.precinctsSizes[r].PPy;\n    }\n    // calculate codeblock size as described in section B.7\n    result.xcb_ = r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) :\n      Math.min(codOrCoc.xcb, result.PPx);\n    result.ycb_ = r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) :\n      Math.min(codOrCoc.ycb, result.PPy);\n    return result;\n  }\n  function buildPrecincts(context, resolution, dimensions) {\n    // Section B.6 Division resolution to precincts\n    var precinctWidth = 1 << dimensions.PPx;\n    var precinctHeight = 1 << dimensions.PPy;\n    var numprecinctswide = resolution.trx1 > resolution.trx0 ?\n      Math.ceil(resolution.trx1 / precinctWidth) -\n      Math.floor(resolution.trx0 / precinctWidth) : 0;\n    var numprecinctshigh = resolution.try1 > resolution.try0 ?\n      Math.ceil(resolution.try1 / precinctHeight) -\n      Math.floor(resolution.try0 / precinctHeight) : 0;\n    var numprecincts = numprecinctswide * numprecinctshigh;\n    var precinctXOffset = Math.floor(resolution.trx0 / precinctWidth) *\n      precinctWidth;\n    var precinctYOffset = Math.floor(resolution.try0 / precinctHeight) *\n      precinctHeight;\n    resolution.precinctParameters = {\n      precinctXOffset: precinctXOffset,\n      precinctYOffset: precinctYOffset,\n      precinctWidth: precinctWidth,\n      precinctHeight: precinctHeight,\n      numprecinctswide: numprecinctswide,\n      numprecinctshigh: numprecinctshigh,\n      numprecincts: numprecincts\n    };\n  }\n  function buildCodeblocks(context, subband, dimensions) {\n    // Section B.7 Division sub-band into code-blocks\n    var xcb_ = dimensions.xcb_;\n    var ycb_ = dimensions.ycb_;\n    var codeblockWidth = 1 << xcb_;\n    var codeblockHeight = 1 << ycb_;\n    var cbx0 = Math.floor(subband.tbx0 / codeblockWidth);\n    var cby0 = Math.floor(subband.tby0 / codeblockHeight);\n    var cbx1 = Math.ceil(subband.tbx1 / codeblockWidth);\n    var cby1 = Math.ceil(subband.tby1 / codeblockHeight);\n    var precinctParameters = subband.resolution.precinctParameters;\n    var codeblocks = [];\n    var precincts = [];\n    for (var j = cby0; j < cby1; j++) {\n      for (var i = cbx0; i < cbx1; i++) {\n        var codeblock = {\n          cbx: i,\n          cby: j,\n          tbx0: codeblockWidth * i,\n          tby0: codeblockHeight * j,\n          tbx1: codeblockWidth * (i + 1),\n          tby1: codeblockHeight * (j + 1)\n        };\n        // calculate precinct number\n        var pi = Math.floor((codeblock.tbx0 -\n          precinctParameters.precinctXOffset) /\n          precinctParameters.precinctWidth);\n        var pj = Math.floor((codeblock.tby0 -\n          precinctParameters.precinctYOffset) /\n          precinctParameters.precinctHeight);\n        var precinctNumber = pj +\n          pi * precinctParameters.numprecinctswide;\n        codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);\n        codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);\n        codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);\n        codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);\n        codeblock.precinctNumber = precinctNumber;\n        codeblock.subbandType = subband.type;\n        var coefficientsLength = (codeblock.tbx1_ - codeblock.tbx0_) *\n          (codeblock.tby1_ - codeblock.tby0_);\n        codeblock.Lblock = 3;\n        codeblocks.push(codeblock);\n        // building precinct for the sub-band\n        var precinct;\n        if (precinctNumber in precincts) {\n          precinct = precincts[precinctNumber];\n          precinct.cbxMin = Math.min(precinct.cbxMin, i);\n          precinct.cbyMin = Math.min(precinct.cbyMin, j);\n          precinct.cbxMax = Math.max(precinct.cbxMax, i);\n          precinct.cbyMax = Math.max(precinct.cbyMax, j);\n        } else {\n          precincts[precinctNumber] = precinct = {\n            cbxMin: i,\n            cbyMin: j,\n            cbxMax: i,\n            cbyMax: j\n          };\n        }\n        codeblock.precinct = precinct;\n      }\n    }\n    subband.codeblockParameters = {\n      codeblockWidth: xcb_,\n      codeblockHeight: ycb_,\n      numcodeblockwide: cbx1 - cbx0 + 1,\n      numcodeblockhigh: cby1 - cby1 + 1\n    };\n    subband.codeblocks = codeblocks;\n    for (var i = 0, ii = codeblocks.length; i < ii; i++) {\n      var codeblock = codeblocks[i];\n      var precinctNumber = codeblock.precinctNumber;\n    }\n    subband.precincts = precincts;\n  }\n  function createPacket(resolution, precinctNumber, layerNumber) {\n    var precinctCodeblocks = [];\n    // Section B.10.8 Order of info in packet\n    var subbands = resolution.subbands;\n    // sub-bands already ordered in 'LL', 'HL', 'LH', and 'HH' sequence\n    for (var i = 0, ii = subbands.length; i < ii; i++) {\n      var subband = subbands[i];\n      var codeblocks = subband.codeblocks;\n      for (var j = 0, jj = codeblocks.length; j < jj; j++) {\n        var codeblock = codeblocks[j];\n        if (codeblock.precinctNumber != precinctNumber)\n          continue;\n        precinctCodeblocks.push(codeblock);\n      }\n    }\n    return {\n      layerNumber: layerNumber,\n      codeblocks: precinctCodeblocks\n    };\n  }\n  function LayerResolutionComponentPositionIterator(context) {\n    var siz = context.SIZ;\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var layersCount = tile.codingStyleDefaultParameters.layersCount;\n    var componentsCount = siz.Csiz;\n    var maxDecompositionLevelsCount = 0;\n    for (var q = 0; q < componentsCount; q++) {\n      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,\n        tile.components[q].codingStyleParameters.decompositionLevelsCount);\n    }\n\n    var l = 0, r = 0, i = 0, k = 0;\n\n    this.nextPacket = function JpxImage_nextPacket() {\n      // Section B.12.1.1 Layer-resolution-component-position\n      for (; l < layersCount; l++) {\n        for (; r <= maxDecompositionLevelsCount; r++) {\n          for (; i < componentsCount; i++) {\n            var component = tile.components[i];\n            if (r > component.codingStyleParameters.decompositionLevelsCount)\n              continue;\n\n            var resolution = component.resolutions[r];\n            var numprecincts = resolution.precinctParameters.numprecincts;\n            for (; k < numprecincts;) {\n              var packet = createPacket(resolution, k, l);\n              k++;\n              return packet;\n            }\n            k = 0;\n          }\n          i = 0;\n        }\n        r = 0;\n      }\n      throw 'Out of packets';\n    };\n  }\n  function ResolutionLayerComponentPositionIterator(context) {\n    var siz = context.SIZ;\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var layersCount = tile.codingStyleDefaultParameters.layersCount;\n    var componentsCount = siz.Csiz;\n    var maxDecompositionLevelsCount = 0;\n    for (var q = 0; q < componentsCount; q++) {\n      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,\n        tile.components[q].codingStyleParameters.decompositionLevelsCount);\n    }\n\n    var r = 0, l = 0, i = 0, k = 0;\n\n    this.nextPacket = function JpxImage_nextPacket() {\n      // Section B.12.1.2 Resolution-layer-component-position\n      for (; r <= maxDecompositionLevelsCount; r++) {\n        for (; l < layersCount; l++) {\n          for (; i < componentsCount; i++) {\n            var component = tile.components[i];\n            if (r > component.codingStyleParameters.decompositionLevelsCount)\n              continue;\n\n            var resolution = component.resolutions[r];\n            var numprecincts = resolution.precinctParameters.numprecincts;\n            for (; k < numprecincts;) {\n              var packet = createPacket(resolution, k, l);\n              k++;\n              return packet;\n            }\n            k = 0;\n          }\n          i = 0;\n        }\n        l = 0;\n      }\n      throw 'Out of packets';\n    };\n  }\n  function buildPackets(context) {\n    var siz = context.SIZ;\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var componentsCount = siz.Csiz;\n    // Creating resolutions and sub-bands for each component\n    for (var c = 0; c < componentsCount; c++) {\n      var component = tile.components[c];\n      var decompositionLevelsCount =\n        component.codingStyleParameters.decompositionLevelsCount;\n      // Section B.5 Resolution levels and sub-bands\n      var resolutions = [];\n      var subbands = [];\n      for (var r = 0; r <= decompositionLevelsCount; r++) {\n        var blocksDimensions = getBlocksDimensions(context, component, r);\n        var resolution = {};\n        var scale = 1 << (decompositionLevelsCount - r);\n        resolution.trx0 = Math.ceil(component.tcx0 / scale);\n        resolution.try0 = Math.ceil(component.tcy0 / scale);\n        resolution.trx1 = Math.ceil(component.tcx1 / scale);\n        resolution.try1 = Math.ceil(component.tcy1 / scale);\n        buildPrecincts(context, resolution, blocksDimensions);\n        resolutions.push(resolution);\n\n        var subband;\n        if (r === 0) {\n          // one sub-band (LL) with last decomposition\n          subband = {};\n          subband.type = 'LL';\n          subband.tbx0 = Math.ceil(component.tcx0 / scale);\n          subband.tby0 = Math.ceil(component.tcy0 / scale);\n          subband.tbx1 = Math.ceil(component.tcx1 / scale);\n          subband.tby1 = Math.ceil(component.tcy1 / scale);\n          subband.resolution = resolution;\n          buildCodeblocks(context, subband, blocksDimensions);\n          subbands.push(subband);\n          resolution.subbands = [subband];\n        } else {\n          var bscale = 1 << (decompositionLevelsCount - r + 1);\n          var resolutionSubbands = [];\n          // three sub-bands (HL, LH and HH) with rest of decompositions\n          subband = {};\n          subband.type = 'HL';\n          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);\n          subband.tby0 = Math.ceil(component.tcy0 / bscale);\n          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);\n          subband.tby1 = Math.ceil(component.tcy1 / bscale);\n          subband.resolution = resolution;\n          buildCodeblocks(context, subband, blocksDimensions);\n          subbands.push(subband);\n          resolutionSubbands.push(subband);\n\n          subband = {};\n          subband.type = 'LH';\n          subband.tbx0 = Math.ceil(component.tcx0 / bscale);\n          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);\n          subband.tbx1 = Math.ceil(component.tcx1 / bscale);\n          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);\n          subband.resolution = resolution;\n          buildCodeblocks(context, subband, blocksDimensions);\n          subbands.push(subband);\n          resolutionSubbands.push(subband);\n\n          subband = {};\n          subband.type = 'HH';\n          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);\n          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);\n          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);\n          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);\n          subband.resolution = resolution;\n          buildCodeblocks(context, subband, blocksDimensions);\n          subbands.push(subband);\n          resolutionSubbands.push(subband);\n\n          resolution.subbands = resolutionSubbands;\n        }\n      }\n      component.resolutions = resolutions;\n      component.subbands = subbands;\n    }\n    // Generate the packets sequence\n    var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;\n    var packetsIterator;\n    switch (progressionOrder) {\n      case 0:\n        tile.packetsIterator =\n          new LayerResolutionComponentPositionIterator(context);\n        break;\n      case 1:\n        tile.packetsIterator =\n          new ResolutionLayerComponentPositionIterator(context);\n        break;\n      default:\n        throw 'Unsupported progression order ' + progressionOrder;\n    }\n  }\n  function parseTilePackets(context, data, offset, dataLength) {\n    var position = 0;\n    var buffer, bufferSize = 0, skipNextBit = false;\n    function readBits(count) {\n      while (bufferSize < count) {\n        var b = data[offset + position];\n        position++;\n        if (skipNextBit) {\n          buffer = (buffer << 7) | b;\n          bufferSize += 7;\n          skipNextBit = false;\n        } else {\n          buffer = (buffer << 8) | b;\n          bufferSize += 8;\n        }\n        if (b == 0xFF) {\n          skipNextBit = true;\n        }\n      }\n      bufferSize -= count;\n      return (buffer >>> bufferSize) & ((1 << count) - 1);\n    }\n    function alignToByte() {\n      bufferSize = 0;\n      if (skipNextBit) {\n        position++;\n        skipNextBit = false;\n      }\n    }\n    function readCodingpasses() {\n      var value = readBits(1);\n      if (value === 0)\n        return 1;\n      value = (value << 1) | readBits(1);\n      if (value == 0x02)\n        return 2;\n      value = (value << 2) | readBits(2);\n      if (value <= 0x0E)\n        return (value & 0x03) + 3;\n      value = (value << 5) | readBits(5);\n      if (value <= 0x1FE)\n        return (value & 0x1F) + 6;\n      value = (value << 7) | readBits(7);\n      return (value & 0x7F) + 37;\n    }\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var packetsIterator = tile.packetsIterator;\n    while (position < dataLength) {\n      var packet = packetsIterator.nextPacket();\n      if (!readBits(1)) {\n        alignToByte();\n        continue;\n      }\n      var layerNumber = packet.layerNumber;\n      var queue = [];\n      for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {\n        var codeblock = packet.codeblocks[i];\n        var precinct = codeblock.precinct;\n        var codeblockColumn = codeblock.cbx - precinct.cbxMin;\n        var codeblockRow = codeblock.cby - precinct.cbyMin;\n        var codeblockIncluded = false;\n        var firstTimeInclusion = false;\n        if ('included' in codeblock) {\n          codeblockIncluded = !!readBits(1);\n        } else {\n          // reading inclusion tree\n          var precinct = codeblock.precinct;\n          var inclusionTree, zeroBitPlanesTree;\n          if ('inclusionTree' in precinct) {\n            inclusionTree = precinct.inclusionTree;\n          } else {\n            // building inclusion and zero bit-planes trees\n            var width = precinct.cbxMax - precinct.cbxMin + 1;\n            var height = precinct.cbyMax - precinct.cbyMin + 1;\n            inclusionTree = new InclusionTree(width, height, layerNumber);\n            zeroBitPlanesTree = new TagTree(width, height);\n            precinct.inclusionTree = inclusionTree;\n            precinct.zeroBitPlanesTree = zeroBitPlanesTree;\n          }\n\n          if (inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber)) {\n            while (true) {\n              if (readBits(1)) {\n                var valueReady = !inclusionTree.nextLevel();\n                if (valueReady) {\n                  codeblock.included = true;\n                  codeblockIncluded = firstTimeInclusion = true;\n                  break;\n                }\n              } else {\n                inclusionTree.incrementValue(layerNumber);\n                break;\n              }\n            }\n          }\n        }\n        if (!codeblockIncluded)\n          continue;\n        if (firstTimeInclusion) {\n          zeroBitPlanesTree = precinct.zeroBitPlanesTree;\n          zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);\n          while (true) {\n            if (readBits(1)) {\n              var valueReady = !zeroBitPlanesTree.nextLevel();\n              if (valueReady)\n                break;\n            } else\n              zeroBitPlanesTree.incrementValue();\n          }\n          codeblock.zeroBitPlanes = zeroBitPlanesTree.value;\n        }\n        var codingpasses = readCodingpasses();\n        while (readBits(1))\n          codeblock.Lblock++;\n        var codingpassesLog2 = log2(codingpasses);\n        // rounding down log2\n        var bits = ((codingpasses < (1 << codingpassesLog2)) ?\n          codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;\n        var codedDataLength = readBits(bits);\n        queue.push({\n          codeblock: codeblock,\n          codingpasses: codingpasses,\n          dataLength: codedDataLength\n        });\n      }\n      alignToByte();\n      while (queue.length > 0) {\n        var packetItem = queue.shift();\n        var codeblock = packetItem.codeblock;\n        if (!('data' in codeblock))\n          codeblock.data = [];\n        codeblock.data.push({\n          data: data,\n          start: offset + position,\n          end: offset + position + packetItem.dataLength,\n          codingpasses: packetItem.codingpasses\n        });\n        position += packetItem.dataLength;\n      }\n    }\n    return position;\n  }\n  function copyCoefficients(coefficients, x0, y0, width, height,\n                            delta, mb, codeblocks, transformation,\n                            segmentationSymbolUsed) {\n    var r = 0.5; // formula (E-6)\n    for (var i = 0, ii = codeblocks.length; i < ii; ++i) {\n      var codeblock = codeblocks[i];\n      var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;\n      var blockHeight = codeblock.tby1_ - codeblock.tby0_;\n      if (blockWidth === 0 || blockHeight === 0)\n        continue;\n      if (!('data' in codeblock))\n        continue;\n\n      var bitModel, currentCodingpassType;\n      bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType,\n        codeblock.zeroBitPlanes);\n      currentCodingpassType = 2; // first bit plane starts from cleanup\n\n      // collect data\n      var data = codeblock.data, totalLength = 0, codingpasses = 0;\n      for (var q = 0, qq = data.length; q < qq; q++) {\n        var dataItem = data[q];\n        totalLength += dataItem.end - dataItem.start;\n        codingpasses += dataItem.codingpasses;\n      }\n      var encodedData = new Uint8Array(totalLength), k = 0;\n      for (var q = 0, qq = data.length; q < qq; q++) {\n        var dataItem = data[q];\n        var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);\n        encodedData.set(chunk, k);\n        k += chunk.length;\n      }\n      // decoding the item\n      var decoder = new ArithmeticDecoder(encodedData, 0, totalLength);\n      bitModel.setDecoder(decoder);\n\n      for (var q = 0; q < codingpasses; q++) {\n        switch (currentCodingpassType) {\n          case 0:\n            bitModel.runSignificancePropogationPass();\n            break;\n          case 1:\n            bitModel.runMagnitudeRefinementPass();\n            break;\n          case 2:\n            bitModel.runCleanupPass();\n            if (segmentationSymbolUsed)\n              bitModel.checkSegmentationSymbol();\n            break;\n        }\n        currentCodingpassType = (currentCodingpassType + 1) % 3;\n      }\n\n      var offset = (codeblock.tbx0_ - x0) + (codeblock.tby0_ - y0) * width;\n      var position = 0;\n      for (var j = 0; j < blockHeight; j++) {\n        for (var k = 0; k < blockWidth; k++) {\n          var n = (bitModel.coefficentsSign[position] ? -1 : 1) *\n            bitModel.coefficentsMagnitude[position];\n          var nb = bitModel.bitsDecoded[position], correction;\n          if (transformation === 0 || mb > nb) {\n            // use r only if transformation is irreversible or\n            // not all bitplanes were decoded for reversible transformation\n            n += n < 0 ? n - r : n > 0 ? n + r : 0;\n            correction = 1 << (mb - nb);\n          } else\n            correction = 1;\n          coefficients[offset++] = n * correction * delta;\n          position++;\n        }\n        offset += width - blockWidth;\n      }\n    }\n  }\n  function transformTile(context, tile, c) {\n    var component = tile.components[c];\n    var codingStyleParameters = component.codingStyleParameters;\n    var quantizationParameters = component.quantizationParameters;\n    var decompositionLevelsCount =\n      codingStyleParameters.decompositionLevelsCount;\n    var spqcds = quantizationParameters.SPqcds;\n    var scalarExpounded = quantizationParameters.scalarExpounded;\n    var guardBits = quantizationParameters.guardBits;\n    var transformation = codingStyleParameters.transformation;\n    var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;\n    var precision = context.components[c].precision;\n\n    var subbandCoefficients = [];\n    var k = 0, b = 0;\n    for (var i = 0; i <= decompositionLevelsCount; i++) {\n      var resolution = component.resolutions[i];\n\n      for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {\n        var mu, epsilon;\n        if (!scalarExpounded) {\n          // formula E-5\n          mu = spqcds[0].mu;\n          epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);\n        } else {\n          mu = spqcds[b].mu;\n          epsilon = spqcds[b].epsilon;\n        }\n\n        var subband = resolution.subbands[j];\n        var width = subband.tbx1 - subband.tbx0;\n        var height = subband.tby1 - subband.tby0;\n        var gainLog2 = SubbandsGainLog2[subband.type];\n\n        // calulate quantization coefficient (Section E.1.1.1)\n        var delta = Math.pow(2, (precision + gainLog2) - epsilon) *\n          (1 + mu / 2048);\n        var mb = (guardBits + epsilon - 1);\n\n        var coefficients = new Float32Array(width * height);\n        copyCoefficients(coefficients, subband.tbx0, subband.tby0,\n          width, height, delta, mb, subband.codeblocks, transformation,\n          segmentationSymbolUsed);\n\n        subbandCoefficients.push({\n          width: width,\n          height: height,\n          items: coefficients\n        });\n\n        b++;\n      }\n    }\n\n    var transformation = codingStyleParameters.transformation;\n    var transform = transformation === 0 ? new IrreversibleTransform() :\n      new ReversibleTransform();\n    var result = transform.calculate(subbandCoefficients,\n      component.tcx0, component.tcy0);\n    return {\n      left: component.tcx0,\n      top: component.tcy0,\n      width: result.width,\n      height: result.height,\n      items: result.items\n    };\n  }\n  function transformComponents(context) {\n    var siz = context.SIZ;\n    var components = context.components;\n    var componentsCount = siz.Csiz;\n    var resultImages = [];\n    for (var i = 0, ii = context.tiles.length; i < ii; i++) {\n      var tile = context.tiles[i];\n      var result = [];\n      for (var c = 0; c < componentsCount; c++) {\n        var image = transformTile(context, tile, c);\n        result.push(image);\n      }\n\n      // Section G.2.2 Inverse multi component transform\n      if (tile.codingStyleDefaultParameters.multipleComponentTransform) {\n        var y0items = result[0].items;\n        var y1items = result[1].items;\n        var y2items = result[2].items;\n        for (var j = 0, jj = y0items.length; j < jj; j++) {\n          var y0 = y0items[j], y1 = y1items[j], y2 = y2items[j];\n          var i1 = y0 - ((y2 + y1) >> 2);\n          y1items[j] = i1;\n          y0items[j] = y2 + i1;\n          y2items[j] = y1 + i1;\n        }\n      }\n\n      // Section G.1 DC level shifting to unsigned component values\n      for (var c = 0; c < componentsCount; c++) {\n        var component = components[c];\n        if (component.isSigned)\n          continue;\n\n        var offset = 1 << (component.precision - 1);\n        var tileImage = result[c];\n        var items = tileImage.items;\n        for (var j = 0, jj = items.length; j < jj; j++)\n          items[j] += offset;\n      }\n\n      // To simplify things: shift and clamp output to 8 bit unsigned\n      for (var c = 0; c < componentsCount; c++) {\n        var component = components[c];\n        var offset = component.isSigned ? 128 : 0;\n        var shift = component.precision - 8;\n        var tileImage = result[c];\n        var items = tileImage.items;\n        var data = new Uint8Array(items.length);\n        for (var j = 0, jj = items.length; j < jj; j++) {\n          var value = (items[j] >> shift) + offset;\n          data[j] = value < 0 ? 0 : value > 255 ? 255 : value;\n        }\n        result[c].items = data;\n      }\n\n      resultImages.push(result);\n    }\n    return resultImages;\n  }\n  function initializeTile(context, tileIndex) {\n    var siz = context.SIZ;\n    var componentsCount = siz.Csiz;\n    var tile = context.tiles[tileIndex];\n    var resultTiles = [];\n    for (var c = 0; c < componentsCount; c++) {\n      var component = tile.components[c];\n      var qcdOrQcc = c in context.currentTile.QCC ?\n        context.currentTile.QCC[c] : context.currentTile.QCD;\n      component.quantizationParameters = qcdOrQcc;\n      var codOrCoc = c in context.currentTile.COC ?\n        context.currentTile.COC[c] : context.currentTile.COD;\n      component.codingStyleParameters = codOrCoc;\n    }\n    tile.codingStyleDefaultParameters = context.currentTile.COD;\n  }\n\n  // Section B.10.2 Tag trees\n  var TagTree = (function TagTreeClosure() {\n    function TagTree(width, height) {\n      var levelsLength = log2(Math.max(width, height)) + 1;\n      this.levels = [];\n      for (var i = 0; i < levelsLength; i++) {\n        var level = {\n          width: width,\n          height: height,\n          items: []\n        };\n        this.levels.push(level);\n        width = Math.ceil(width / 2);\n        height = Math.ceil(height / 2);\n      }\n    }\n    TagTree.prototype = {\n      reset: function TagTree_reset(i, j) {\n        var currentLevel = 0, value = 0;\n        while (currentLevel < this.levels.length) {\n          var level = this.levels[currentLevel];\n          var index = i + j * level.width;\n          if (index in level.items) {\n            value = level.items[index];\n            break;\n          }\n          level.index = index;\n          i >>= 1;\n          j >>= 1;\n          currentLevel++;\n        }\n        currentLevel--;\n        var level = this.levels[currentLevel];\n        level.items[level.index] = value;\n        this.currentLevel = currentLevel;\n        delete this.value;\n      },\n      incrementValue: function TagTree_incrementValue() {\n        var level = this.levels[this.currentLevel];\n        level.items[level.index]++;\n      },\n      nextLevel: function TagTree_nextLevel() {\n        var currentLevel = this.currentLevel;\n        var level = this.levels[currentLevel];\n        var value = level.items[level.index];\n        currentLevel--;\n        if (currentLevel < 0) {\n          this.value = value;\n          return false;\n        }\n\n        this.currentLevel = currentLevel;\n        var level = this.levels[currentLevel];\n        level.items[level.index] = value;\n        return true;\n      }\n    };\n    return TagTree;\n  })();\n\n  var InclusionTree = (function InclusionTreeClosure() {\n    function InclusionTree(width, height,  defaultValue) {\n      var levelsLength = log2(Math.max(width, height)) + 1;\n      this.levels = [];\n      for (var i = 0; i < levelsLength; i++) {\n        var items = new Uint8Array(width * height);\n        for (var j = 0, jj = items.length; j < jj; j++)\n          items[j] = defaultValue;\n\n        var level = {\n          width: width,\n          height: height,\n          items: items\n        };\n        this.levels.push(level);\n\n        width = Math.ceil(width / 2);\n        height = Math.ceil(height / 2);\n      }\n    }\n    InclusionTree.prototype = {\n      reset: function InclusionTree_reset(i, j, stopValue) {\n        var currentLevel = 0;\n        while (currentLevel < this.levels.length) {\n          var level = this.levels[currentLevel];\n          var index = i + j * level.width;\n          level.index = index;\n          var value = level.items[index];\n\n          if (value == 0xFF)\n            break;\n\n          if (value > stopValue) {\n            this.currentLevel = currentLevel;\n            // already know about this one, propagating the value to top levels\n            this.propagateValues();\n            return false;\n          }\n\n          i >>= 1;\n          j >>= 1;\n          currentLevel++;\n        }\n        this.currentLevel = currentLevel - 1;\n        return true;\n      },\n      incrementValue: function InclusionTree_incrementValue(stopValue) {\n        var level = this.levels[this.currentLevel];\n        level.items[level.index] = stopValue + 1;\n        this.propagateValues();\n      },\n      propagateValues: function InclusionTree_propagateValues() {\n        var levelIndex = this.currentLevel;\n        var level = this.levels[levelIndex];\n        var currentValue = level.items[level.index];\n        while (--levelIndex >= 0) {\n          var level = this.levels[levelIndex];\n          level.items[level.index] = currentValue;\n        }\n      },\n      nextLevel: function InclusionTree_nextLevel() {\n        var currentLevel = this.currentLevel;\n        var level = this.levels[currentLevel];\n        var value = level.items[level.index];\n        level.items[level.index] = 0xFF;\n        currentLevel--;\n        if (currentLevel < 0)\n          return false;\n\n        this.currentLevel = currentLevel;\n        var level = this.levels[currentLevel];\n        level.items[level.index] = value;\n        return true;\n      }\n    };\n    return InclusionTree;\n  })();\n\n  // Implements C.3. Arithmetic decoding procedures\n  var ArithmeticDecoder = (function ArithmeticDecoderClosure() {\n    var QeTable = [\n      {qe: 0x5601, nmps: 1, nlps: 1, switchFlag: 1},\n      {qe: 0x3401, nmps: 2, nlps: 6, switchFlag: 0},\n      {qe: 0x1801, nmps: 3, nlps: 9, switchFlag: 0},\n      {qe: 0x0AC1, nmps: 4, nlps: 12, switchFlag: 0},\n      {qe: 0x0521, nmps: 5, nlps: 29, switchFlag: 0},\n      {qe: 0x0221, nmps: 38, nlps: 33, switchFlag: 0},\n      {qe: 0x5601, nmps: 7, nlps: 6, switchFlag: 1},\n      {qe: 0x5401, nmps: 8, nlps: 14, switchFlag: 0},\n      {qe: 0x4801, nmps: 9, nlps: 14, switchFlag: 0},\n      {qe: 0x3801, nmps: 10, nlps: 14, switchFlag: 0},\n      {qe: 0x3001, nmps: 11, nlps: 17, switchFlag: 0},\n      {qe: 0x2401, nmps: 12, nlps: 18, switchFlag: 0},\n      {qe: 0x1C01, nmps: 13, nlps: 20, switchFlag: 0},\n      {qe: 0x1601, nmps: 29, nlps: 21, switchFlag: 0},\n      {qe: 0x5601, nmps: 15, nlps: 14, switchFlag: 1},\n      {qe: 0x5401, nmps: 16, nlps: 14, switchFlag: 0},\n      {qe: 0x5101, nmps: 17, nlps: 15, switchFlag: 0},\n      {qe: 0x4801, nmps: 18, nlps: 16, switchFlag: 0},\n      {qe: 0x3801, nmps: 19, nlps: 17, switchFlag: 0},\n      {qe: 0x3401, nmps: 20, nlps: 18, switchFlag: 0},\n      {qe: 0x3001, nmps: 21, nlps: 19, switchFlag: 0},\n      {qe: 0x2801, nmps: 22, nlps: 19, switchFlag: 0},\n      {qe: 0x2401, nmps: 23, nlps: 20, switchFlag: 0},\n      {qe: 0x2201, nmps: 24, nlps: 21, switchFlag: 0},\n      {qe: 0x1C01, nmps: 25, nlps: 22, switchFlag: 0},\n      {qe: 0x1801, nmps: 26, nlps: 23, switchFlag: 0},\n      {qe: 0x1601, nmps: 27, nlps: 24, switchFlag: 0},\n      {qe: 0x1401, nmps: 28, nlps: 25, switchFlag: 0},\n      {qe: 0x1201, nmps: 29, nlps: 26, switchFlag: 0},\n      {qe: 0x1101, nmps: 30, nlps: 27, switchFlag: 0},\n      {qe: 0x0AC1, nmps: 31, nlps: 28, switchFlag: 0},\n      {qe: 0x09C1, nmps: 32, nlps: 29, switchFlag: 0},\n      {qe: 0x08A1, nmps: 33, nlps: 30, switchFlag: 0},\n      {qe: 0x0521, nmps: 34, nlps: 31, switchFlag: 0},\n      {qe: 0x0441, nmps: 35, nlps: 32, switchFlag: 0},\n      {qe: 0x02A1, nmps: 36, nlps: 33, switchFlag: 0},\n      {qe: 0x0221, nmps: 37, nlps: 34, switchFlag: 0},\n      {qe: 0x0141, nmps: 38, nlps: 35, switchFlag: 0},\n      {qe: 0x0111, nmps: 39, nlps: 36, switchFlag: 0},\n      {qe: 0x0085, nmps: 40, nlps: 37, switchFlag: 0},\n      {qe: 0x0049, nmps: 41, nlps: 38, switchFlag: 0},\n      {qe: 0x0025, nmps: 42, nlps: 39, switchFlag: 0},\n      {qe: 0x0015, nmps: 43, nlps: 40, switchFlag: 0},\n      {qe: 0x0009, nmps: 44, nlps: 41, switchFlag: 0},\n      {qe: 0x0005, nmps: 45, nlps: 42, switchFlag: 0},\n      {qe: 0x0001, nmps: 45, nlps: 43, switchFlag: 0},\n      {qe: 0x5601, nmps: 46, nlps: 46, switchFlag: 0}\n    ];\n\n    function ArithmeticDecoder(data, start, end) {\n      this.data = data;\n      this.bp = start;\n      this.dataEnd = end;\n\n      this.chigh = data[start];\n      this.clow = 0;\n\n      this.byteIn();\n\n      this.chigh = ((this.chigh << 7) & 0xFFFF) | ((this.clow >> 9) & 0x7F);\n      this.clow = (this.clow << 7) & 0xFFFF;\n      this.ct -= 7;\n      this.a = 0x8000;\n    }\n\n    ArithmeticDecoder.prototype = {\n      byteIn: function ArithmeticDecoder_byteIn() {\n        var data = this.data;\n        var bp = this.bp;\n        if (data[bp] == 0xFF) {\n          var b1 = data[bp + 1];\n          if (b1 > 0x8F) {\n            this.clow += 0xFF00;\n            this.ct = 8;\n          } else {\n            bp++;\n            this.clow += (data[bp] << 9);\n            this.ct = 7;\n            this.bp = bp;\n          }\n        } else {\n          bp++;\n          this.clow += bp < this.dataEnd ? (data[bp] << 8) : 0xFF00;\n          this.ct = 8;\n          this.bp = bp;\n        }\n        if (this.clow > 0xFFFF) {\n          this.chigh += (this.clow >> 16);\n          this.clow &= 0xFFFF;\n        }\n      },\n      readBit: function ArithmeticDecoder_readBit(cx) {\n        var qeIcx = QeTable[cx.index].qe;\n        this.a -= qeIcx;\n\n        if (this.chigh < qeIcx) {\n          var d = this.exchangeLps(cx);\n          this.renormD();\n          return d;\n        } else {\n          this.chigh -= qeIcx;\n          if ((this.a & 0x8000) === 0) {\n            var d = this.exchangeMps(cx);\n            this.renormD();\n            return d;\n          } else {\n            return cx.mps;\n          }\n        }\n      },\n      renormD: function ArithmeticDecoder_renormD() {\n        do {\n          if (this.ct === 0)\n            this.byteIn();\n\n          this.a <<= 1;\n          this.chigh = ((this.chigh << 1) & 0xFFFF) | ((this.clow >> 15) & 1);\n          this.clow = (this.clow << 1) & 0xFFFF;\n          this.ct--;\n        } while ((this.a & 0x8000) === 0);\n      },\n      exchangeMps: function ArithmeticDecoder_exchangeMps(cx) {\n        var d;\n        var qeTableIcx = QeTable[cx.index];\n        if (this.a < qeTableIcx.qe) {\n          d = 1 - cx.mps;\n\n          if (qeTableIcx.switchFlag == 1) {\n            cx.mps = 1 - cx.mps;\n          }\n          cx.index = qeTableIcx.nlps;\n        } else {\n          d = cx.mps;\n          cx.index = qeTableIcx.nmps;\n        }\n        return d;\n      },\n      exchangeLps: function ArithmeticDecoder_exchangeLps(cx) {\n        var d;\n        var qeTableIcx = QeTable[cx.index];\n        if (this.a < qeTableIcx.qe) {\n          this.a = qeTableIcx.qe;\n          d = cx.mps;\n          cx.index = qeTableIcx.nmps;\n        } else {\n          this.a = qeTableIcx.qe;\n          d = 1 - cx.mps;\n\n          if (qeTableIcx.switchFlag == 1) {\n            cx.mps = 1 - cx.mps;\n          }\n          cx.index = qeTableIcx.nlps;\n        }\n        return d;\n      }\n    };\n\n    return ArithmeticDecoder;\n  })();\n\n  // Section D. Coefficient bit modeling\n  var BitModel = (function BitModelClosure() {\n    // Table D-1\n    // The index is binary presentation: 0dddvvhh, ddd - sum of Di (0..4),\n    // vv - sum of Vi (0..2), and hh - sum of Hi (0..2)\n    var LLAndLHContextsLabel = new Uint8Array([\n      0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4,\n      7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6,\n      8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8\n    ]);\n    var HLContextLabel = new Uint8Array([\n      0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8,\n      8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3,\n      4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8\n    ]);\n    var HHContextLabel = new Uint8Array([\n      0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5,\n      5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8,\n      8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8\n    ]);\n\n    // Table D-2\n    function calcSignContribution(significance0, sign0, significance1, sign1) {\n      if (significance1) {\n        if (!sign1)\n          return significance0 ? (!sign0 ? 1 : 0) : 1;\n        else\n          return significance0 ? (!sign0 ? 0 : -1) : -1;\n      } else\n        return significance0 ? (!sign0 ? 1 : -1) : 0;\n    }\n    // Table D-3\n    var SignContextLabels = [\n      {contextLabel: 13, xorBit: 0},\n      {contextLabel: 12, xorBit: 0},\n      {contextLabel: 11, xorBit: 0},\n      {contextLabel: 10, xorBit: 0},\n      {contextLabel: 9, xorBit: 0},\n      {contextLabel: 10, xorBit: 1},\n      {contextLabel: 11, xorBit: 1},\n      {contextLabel: 12, xorBit: 1},\n      {contextLabel: 13, xorBit: 1}\n    ];\n\n    function BitModel(width, height, subband, zeroBitPlanes) {\n      this.width = width;\n      this.height = height;\n\n      this.contextLabelTable = subband == 'HH' ? HHContextLabel :\n        subband == 'HL' ? HLContextLabel : LLAndLHContextsLabel;\n\n      var coefficientCount = width * height;\n\n      // coefficients outside the encoding region treated as insignificant\n      // add border state cells for significanceState\n      this.neighborsSignificance = new Uint8Array(coefficientCount);\n      this.coefficentsSign = new Uint8Array(coefficientCount);\n      this.coefficentsMagnitude = new Uint32Array(coefficientCount);\n      this.processingFlags = new Uint8Array(coefficientCount);\n\n      var bitsDecoded = new Uint8Array(this.width * this.height);\n      for (var i = 0, ii = bitsDecoded.length; i < ii; i++)\n        bitsDecoded[i] = zeroBitPlanes;\n      this.bitsDecoded = bitsDecoded;\n\n      this.reset();\n    }\n\n    BitModel.prototype = {\n      setDecoder: function BitModel_setDecoder(decoder) {\n        this.decoder = decoder;\n      },\n      reset: function BitModel_reset() {\n        this.uniformContext = {index: 46, mps: 0};\n        this.runLengthContext = {index: 3, mps: 0};\n        this.contexts = [];\n        this.contexts.push({index: 4, mps: 0});\n        for (var i = 1; i <= 16; i++)\n          this.contexts.push({index: 0, mps: 0});\n      },\n      setNeighborsSignificance:\n        function BitModel_setNeighborsSignificance(row, column) {\n        var neighborsSignificance = this.neighborsSignificance;\n        var width = this.width, height = this.height;\n        var index = row * width + column;\n        if (row > 0) {\n          if (column > 0)\n            neighborsSignificance[index - width - 1] += 0x10;\n          if (column + 1 < width)\n            neighborsSignificance[index - width + 1] += 0x10;\n          neighborsSignificance[index - width] += 0x04;\n        }\n        if (row + 1 < height) {\n          if (column > 0)\n            neighborsSignificance[index + width - 1] += 0x10;\n          if (column + 1 < width)\n            neighborsSignificance[index + width + 1] += 0x10;\n          neighborsSignificance[index + width] += 0x04;\n        }\n        if (column > 0)\n          neighborsSignificance[index - 1] += 0x01;\n        if (column + 1 < width)\n          neighborsSignificance[index + 1] += 0x01;\n        neighborsSignificance[index] |= 0x80;\n      },\n      runSignificancePropogationPass:\n        function BitModel_runSignificancePropogationPass() {\n        var decoder = this.decoder;\n        var width = this.width, height = this.height;\n        var coefficentsMagnitude = this.coefficentsMagnitude;\n        var coefficentsSign = this.coefficentsSign;\n        var contextLabels = this.contextLabels;\n        var neighborsSignificance = this.neighborsSignificance;\n        var processingFlags = this.processingFlags;\n        var contexts = this.contexts;\n        var labels = this.contextLabelTable;\n        var bitsDecoded = this.bitsDecoded;\n        // clear processed flag\n        var processedInverseMask = ~1;\n        var processedMask = 1;\n        var firstMagnitudeBitMask = 2;\n        for (var q = 0, qq = width * height; q < qq; q++)\n          processingFlags[q] &= processedInverseMask;\n\n        for (var i0 = 0; i0 < height; i0 += 4) {\n          for (var j = 0; j < width; j++) {\n            var index = i0 * width + j;\n            for (var i1 = 0; i1 < 4; i1++, index += width) {\n              var i = i0 + i1;\n              if (i >= height)\n                break;\n\n              if (coefficentsMagnitude[index] || !neighborsSignificance[index])\n                continue;\n\n              var contextLabel = labels[neighborsSignificance[index]];\n              var cx = contexts[contextLabel];\n              var decision = decoder.readBit(cx);\n              if (decision) {\n                var sign = this.decodeSignBit(i, j);\n                coefficentsSign[index] = sign;\n                coefficentsMagnitude[index] = 1;\n                this.setNeighborsSignificance(i, j);\n                processingFlags[index] |= firstMagnitudeBitMask;\n              }\n              bitsDecoded[index]++;\n              processingFlags[index] |= processedMask;\n            }\n          }\n        }\n      },\n      decodeSignBit: function BitModel_decodeSignBit(row, column) {\n        var width = this.width, height = this.height;\n        var index = row * width + column;\n        var coefficentsMagnitude = this.coefficentsMagnitude;\n        var coefficentsSign = this.coefficentsSign;\n        var horizontalContribution = calcSignContribution(\n          column > 0 && coefficentsMagnitude[index - 1],\n          coefficentsSign[index - 1],\n          column + 1 < width && coefficentsMagnitude[index + 1],\n          coefficentsSign[index + 1]);\n        var verticalContribution = calcSignContribution(\n          row > 0 && coefficentsMagnitude[index - width],\n          coefficentsSign[index - width],\n          row + 1 < height && coefficentsMagnitude[index + width],\n          coefficentsSign[index + width]);\n\n        var contextLabelAndXor = SignContextLabels[\n          3 * (1 - horizontalContribution) + (1 - verticalContribution)];\n        var contextLabel = contextLabelAndXor.contextLabel;\n        var cx = this.contexts[contextLabel];\n        var decoded = this.decoder.readBit(cx);\n        return decoded ^ contextLabelAndXor.xorBit;\n      },\n      runMagnitudeRefinementPass:\n        function BitModel_runMagnitudeRefinementPass() {\n        var decoder = this.decoder;\n        var width = this.width, height = this.height;\n        var coefficentsMagnitude = this.coefficentsMagnitude;\n        var neighborsSignificance = this.neighborsSignificance;\n        var contexts = this.contexts;\n        var bitsDecoded = this.bitsDecoded;\n        var processingFlags = this.processingFlags;\n        var processedMask = 1;\n        var firstMagnitudeBitMask = 2;\n        for (var i0 = 0; i0 < height; i0 += 4) {\n          for (var j = 0; j < width; j++) {\n            for (var i1 = 0; i1 < 4; i1++) {\n              var i = i0 + i1;\n              if (i >= height)\n                break;\n              var index = i * width + j;\n\n              // significant but not those that have just become\n              if (!coefficentsMagnitude[index] ||\n                (processingFlags[index] & processedMask) !== 0)\n                continue;\n\n              var contextLabel = 16;\n              if ((processingFlags[index] &\n                firstMagnitudeBitMask) !== 0) {\n                processingFlags[i * width + j] ^= firstMagnitudeBitMask;\n                // first refinement\n                var significance = neighborsSignificance[index];\n                var sumOfSignificance = (significance & 3) +\n                  ((significance >> 2) & 3) + ((significance >> 4) & 7);\n                contextLabel = sumOfSignificance >= 1 ? 15 : 14;\n              }\n\n              var cx = contexts[contextLabel];\n              var bit = decoder.readBit(cx);\n              coefficentsMagnitude[index] =\n                (coefficentsMagnitude[index] << 1) | bit;\n              bitsDecoded[index]++;\n              processingFlags[index] |= processedMask;\n            }\n          }\n        }\n      },\n      runCleanupPass: function BitModel_runCleanupPass() {\n        var decoder = this.decoder;\n        var width = this.width, height = this.height;\n        var neighborsSignificance = this.neighborsSignificance;\n        var significanceState = this.significanceState;\n        var coefficentsMagnitude = this.coefficentsMagnitude;\n        var coefficentsSign = this.coefficentsSign;\n        var contexts = this.contexts;\n        var labels = this.contextLabelTable;\n        var bitsDecoded = this.bitsDecoded;\n        var processingFlags = this.processingFlags;\n        var processedMask = 1;\n        var firstMagnitudeBitMask = 2;\n        var oneRowDown = width;\n        var twoRowsDown = width * 2;\n        var threeRowsDown = width * 3;\n        for (var i0 = 0; i0 < height; i0 += 4) {\n          for (var j = 0; j < width; j++) {\n            var index0 = i0 * width + j;\n            // using the property: labels[neighborsSignificance[index]] == 0\n            // when neighborsSignificance[index] == 0\n            var allEmpty = i0 + 3 < height &&\n              processingFlags[index0] === 0 &&\n              processingFlags[index0 + oneRowDown] === 0 &&\n              processingFlags[index0 + twoRowsDown] === 0 &&\n              processingFlags[index0 + threeRowsDown] === 0 &&\n              neighborsSignificance[index0] === 0 &&\n              neighborsSignificance[index0 + oneRowDown] === 0 &&\n              neighborsSignificance[index0 + twoRowsDown] === 0 &&\n              neighborsSignificance[index0 + threeRowsDown] === 0;\n            var i1 = 0, index = index0;\n            var cx, i;\n            if (allEmpty) {\n              cx = this.runLengthContext;\n              var hasSignificantCoefficent = decoder.readBit(cx);\n              if (!hasSignificantCoefficent) {\n                bitsDecoded[index0]++;\n                bitsDecoded[index0 + oneRowDown]++;\n                bitsDecoded[index0 + twoRowsDown]++;\n                bitsDecoded[index0 + threeRowsDown]++;\n                continue; // next column\n              }\n              cx = this.uniformContext;\n              i1 = (decoder.readBit(cx) << 1) | decoder.readBit(cx);\n              i = i0 + i1;\n              index += i1 * width;\n\n              var sign = this.decodeSignBit(i, j);\n              coefficentsSign[index] = sign;\n              coefficentsMagnitude[index] = 1;\n              this.setNeighborsSignificance(i, j);\n              processingFlags[index] |= firstMagnitudeBitMask;\n\n              index = index0;\n              for (var i2 = i0; i2 <= i; i2++, index += width)\n                bitsDecoded[index]++;\n\n              i1++;\n            }\n            for (; i1 < 4; i1++, index += width) {\n              i = i0 + i1;\n              if (i >= height)\n                break;\n\n              if (coefficentsMagnitude[index] ||\n                (processingFlags[index] & processedMask) !== 0)\n                continue;\n\n              var contextLabel = labels[neighborsSignificance[index]];\n              cx = contexts[contextLabel];\n              var decision = decoder.readBit(cx);\n              if (decision == 1) {\n                var sign = this.decodeSignBit(i, j);\n                coefficentsSign[index] = sign;\n                coefficentsMagnitude[index] = 1;\n                this.setNeighborsSignificance(i, j);\n                processingFlags[index] |= firstMagnitudeBitMask;\n              }\n              bitsDecoded[index]++;\n            }\n          }\n        }\n      },\n      checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {\n        var decoder = this.decoder;\n        var cx = this.uniformContext;\n        var symbol = (decoder.readBit(cx) << 3) | (decoder.readBit(cx) << 2) |\n                     (decoder.readBit(cx) << 1) | decoder.readBit(cx);\n        if (symbol != 0xA)\n          throw 'Invalid segmentation symbol';\n      }\n    };\n\n    return BitModel;\n  })();\n\n  // Section F, Discrete wavelet transofrmation\n  var Transform = (function TransformClosure() {\n    function Transform() {\n    }\n    Transform.prototype.calculate =\n      function transformCalculate(subbands, u0, v0) {\n      var ll = subbands[0];\n      for (var i = 1, ii = subbands.length, j = 1; i < ii; i += 3, j++) {\n        ll = this.iterate(ll, subbands[i], subbands[i + 1],\n                          subbands[i + 2], u0, v0);\n      }\n      return ll;\n    };\n    Transform.prototype.expand = function expand(buffer, bufferPadding, step) {\n        // Section F.3.7 extending... using max extension of 4\n        var i1 = bufferPadding - 1, j1 = bufferPadding + 1;\n        var i2 = bufferPadding + step - 2, j2 = bufferPadding + step;\n        buffer[i1--] = buffer[j1++];\n        buffer[j2++] = buffer[i2--];\n        buffer[i1--] = buffer[j1++];\n        buffer[j2++] = buffer[i2--];\n        buffer[i1--] = buffer[j1++];\n        buffer[j2++] = buffer[i2--];\n        buffer[i1--] = buffer[j1++];\n        buffer[j2++] = buffer[i2--];\n    };\n    Transform.prototype.iterate = function Transform_iterate(ll, hl, lh, hh,\n                                                            u0, v0) {\n      var llWidth = ll.width, llHeight = ll.height, llItems = ll.items;\n      var hlWidth = hl.width, hlHeight = hl.height, hlItems = hl.items;\n      var lhWidth = lh.width, lhHeight = lh.height, lhItems = lh.items;\n      var hhWidth = hh.width, hhHeight = hh.height, hhItems = hh.items;\n\n      // Section F.3.3 interleave\n      var width = llWidth + hlWidth;\n      var height = llHeight + lhHeight;\n      var items = new Float32Array(width * height);\n      for (var i = 0, ii = llHeight; i < ii; i++) {\n        var k = i * llWidth, l = i * 2 * width;\n        for (var j = 0, jj = llWidth; j < jj; j++, k++, l += 2)\n          items[l] = llItems[k];\n      }\n      for (var i = 0, ii = hlHeight; i < ii; i++) {\n        var k = i * hlWidth, l = i * 2 * width + 1;\n        for (var j = 0, jj = hlWidth; j < jj; j++, k++, l += 2)\n          items[l] = hlItems[k];\n      }\n      for (var i = 0, ii = lhHeight; i < ii; i++) {\n        var k = i * lhWidth, l = (i * 2 + 1) * width;\n        for (var j = 0, jj = lhWidth; j < jj; j++, k++, l += 2)\n          items[l] = lhItems[k];\n      }\n      for (var i = 0, ii = hhHeight; i < ii; i++) {\n        var k = i * hhWidth, l = (i * 2 + 1) * width + 1;\n        for (var j = 0, jj = hhWidth; j < jj; j++, k++, l += 2)\n          items[l] = hhItems[k];\n      }\n\n      var bufferPadding = 4;\n      var bufferLength = new Float32Array(Math.max(width, height) +\n        2 * bufferPadding);\n      var buffer = new Float32Array(bufferLength);\n      var bufferOut = new Float32Array(bufferLength);\n\n      // Section F.3.4 HOR_SR\n      for (var v = 0; v < height; v++) {\n        if (width == 1) {\n          // if width = 1, when u0 even keep items as is, when odd divide by 2\n          if ((u0 % 1) !== 0) {\n            items[v * width] /= 2;\n          }\n          continue;\n        }\n\n        var k = v * width;\n        var l = bufferPadding;\n        for (var u = 0; u < width; u++, k++, l++)\n          buffer[l] = items[k];\n\n        this.expand(buffer, bufferPadding, width);\n        this.filter(buffer, bufferPadding, width, u0, bufferOut);\n\n        k = v * width;\n        l = bufferPadding;\n        for (var u = 0; u < width; u++, k++, l++)\n          items[k] = bufferOut[l];\n      }\n\n      // Section F.3.5 VER_SR\n      for (var u = 0; u < width; u++) {\n        if (height == 1) {\n          // if height = 1, when v0 even keep items as is, when odd divide by 2\n          if ((v0 % 1) !== 0) {\n            items[u] /= 2;\n          }\n          continue;\n        }\n\n        var k = u;\n        var l = bufferPadding;\n        for (var v = 0; v < height; v++, k += width, l++)\n          buffer[l] = items[k];\n\n        this.expand(buffer, bufferPadding, height);\n        this.filter(buffer, bufferPadding, height, v0, bufferOut);\n\n        k = u;\n        l = bufferPadding;\n        for (var v = 0; v < height; v++, k += width, l++)\n          items[k] = bufferOut[l];\n      }\n      return {\n        width: width,\n        height: height,\n        items: items\n      };\n    };\n    return Transform;\n  })();\n\n  // Section 3.8.2 Irreversible 9-7 filter\n  var IrreversibleTransform = (function IrreversibleTransformClosure() {\n    function IrreversibleTransform() {\n      Transform.call(this);\n    }\n\n    IrreversibleTransform.prototype = Object.create(Transform.prototype);\n    IrreversibleTransform.prototype.filter =\n      function irreversibleTransformFilter(y, offset, length, i0, x) {\n      var i0_ = Math.floor(i0 / 2);\n      var i1_ = Math.floor((i0 + length) / 2);\n      var offset_ = offset - (i0 % 1);\n\n      var alpha = -1.586134342059924;\n      var beta = -0.052980118572961;\n      var gamma = 0.882911075530934;\n      var delta = 0.443506852043971;\n      var K = 1.230174104914001;\n      var K_ = 1 / K;\n\n      // step 1\n      var j = offset_ - 2;\n      for (var n = i0_ - 1, nn = i1_ + 2; n < nn; n++, j += 2)\n        x[j] = K * y[j];\n\n      // step 2\n      var j = offset_ - 3;\n      for (var n = i0_ - 2, nn = i1_ + 2; n < nn; n++, j += 2)\n        x[j] = K_ * y[j];\n\n      // step 3\n      var j = offset_ - 2;\n      for (var n = i0_ - 1, nn = i1_ + 2; n < nn; n++, j += 2)\n        x[j] -= delta * (x[j - 1] + x[j + 1]);\n\n      // step 4\n      var j = offset_ - 1;\n      for (var n = i0_ - 1, nn = i1_ + 1; n < nn; n++, j += 2)\n        x[j] -= gamma * (x[j - 1] + x[j + 1]);\n\n      // step 5\n      var j = offset_;\n      for (var n = i0_, nn = i1_ + 1; n < nn; n++, j += 2)\n        x[j] -= beta * (x[j - 1] + x[j + 1]);\n\n      // step 6\n      var j = offset_ + 1;\n      for (var n = i0_, nn = i1_; n < nn; n++, j += 2)\n        x[j] -= alpha * (x[j - 1] + x[j + 1]);\n    };\n\n    return IrreversibleTransform;\n  })();\n\n  // Section 3.8.1 Reversible 5-3 filter\n  var ReversibleTransform = (function ReversibleTransformClosure() {\n    function ReversibleTransform() {\n      Transform.call(this);\n    }\n\n    ReversibleTransform.prototype = Object.create(Transform.prototype);\n    ReversibleTransform.prototype.filter =\n      function reversibleTransformFilter(y, offset, length, i0, x) {\n      var i0_ = Math.floor(i0 / 2);\n      var i1_ = Math.floor((i0 + length) / 2);\n      var offset_ = offset - (i0 % 1);\n\n      for (var n = i0_, nn = i1_ + 1, j = offset_; n < nn; n++, j += 2)\n        x[j] = y[j] - Math.floor((y[j - 1] + y[j + 1] + 2) / 4);\n\n      for (var n = i0_, nn = i1_, j = offset_ + 1; n < nn; n++, j += 2)\n        x[j] = y[j] + Math.floor((x[j - 1] + x[j + 1]) / 2);\n    };\n\n    return ReversibleTransform;\n  })();\n\n\n  })();\n\n  /**\n   * For JPEG 2000's we use a library to decode these images and\n   * the stream behaves like all the other DecodeStreams.\n   */\n\n    var JpxStream = DecodeStream.inherit({\n        klassName : \"JpxStream\",\n\n        init : function(bytes, dict) {\n          this.dict = dict;\n          this.bytes = bytes;\n\n            this.overrided();          \n        },\n      ensureBuffer : function(req) {\n          if (this.bufferLength)\n              return;\n\n          var jpxImage = new JpxImage();\n          jpxImage.parse(this.bytes);\n\n          var width = jpxImage.width;\n          var height = jpxImage.height;\n          var componentsCount = jpxImage.componentsCount;\n          if (componentsCount != 1 && componentsCount != 3 && componentsCount != 4)\n              error('JPX with ' + componentsCount + ' components is not supported');\n\n          var data = new Uint8Array(width * height * componentsCount);\n\n          for (var k = 0, kk = jpxImage.tiles.length; k < kk; k++) {\n              var tileCompoments = jpxImage.tiles[k];\n              var tileWidth = tileCompoments[0].width;\n              var tileHeight = tileCompoments[0].height;\n              var tileLeft = tileCompoments[0].left;\n              var tileTop = tileCompoments[0].top;\n\n              var dataPosition, sourcePosition, data0, data1, data2, data3, rowFeed;\n              switch (componentsCount) {\n                  case 1:\n                      data0 = tileCompoments[0].items;\n\n                      dataPosition = width * tileTop + tileLeft;\n                      rowFeed = width - tileWidth;\n                      sourcePosition = 0;\n                      for (var j = 0; j < tileHeight; j++) {\n                          for (var i = 0; i < tileWidth; i++)\n                              data[dataPosition++] = data0[sourcePosition++];\n                          dataPosition += rowFeed;\n                      }\n                      break;\n                  case 3:\n                      data0 = tileCompoments[0].items;\n                      data1 = tileCompoments[1].items;\n                      data2 = tileCompoments[2].items;\n\n                      dataPosition = (width * tileTop + tileLeft) * 3;\n                      rowFeed = (width - tileWidth) * 3;\n                      sourcePosition = 0;\n                      for (var j = 0; j < tileHeight; j++) {\n                          for (var i = 0; i < tileWidth; i++) {\n                              data[dataPosition++] = data0[sourcePosition];\n                              data[dataPosition++] = data1[sourcePosition];\n                              data[dataPosition++] = data2[sourcePosition];\n                              sourcePosition++;\n                          }\n                          dataPosition += rowFeed;\n                      }\n                      break;\n                  case 4:\n                      data0 = tileCompoments[0].items;\n                      data1 = tileCompoments[1].items;\n                      data2 = tileCompoments[2].items;\n                      data3 = tileCompoments[3].items;\n\n                      dataPosition = (width * tileTop + tileLeft) * 4;\n                      rowFeed = (width - tileWidth) * 4;\n                      sourcePosition = 0;\n                      for (var j = 0; j < tileHeight; j++) {\n                          for (var i = 0; i < tileWidth; i++) {\n                              data[dataPosition++] = data0[sourcePosition];\n                              data[dataPosition++] = data1[sourcePosition];\n                              data[dataPosition++] = data2[sourcePosition];\n                              data[dataPosition++] = data3[sourcePosition];\n                              sourcePosition++;\n                          }\n                          dataPosition += rowFeed;\n                      }\n                      break;\n              }\n          }\n\n          this.buffer = data;\n          this.bufferLength = data.length;\n      },\n\n      getChar : function JpxStream_getChar() {\n          error('internal error: getChar is not valid on JpxStream');\n      }\n    });\n\n  return codec.jpx = {\n    \"JpxImage\" :JpxImage,\n    \"JpxStream\" : JpxStream\n  };\n  \n});\n\ndefine('skylark-utils-codec/main',[\r\n    \"./codec\",\r\n    \"./base64\",\r\n    \"./jbig2\",\r\n    \"./jpeg\",\r\n    \"./jpx\",\r\n], function(codec) {\r\n\r\n\treturn codec;\r\n});\ndefine('skylark-utils-codec', ['skylark-utils-codec/main'], function (main) { return main; });\n\n"]}